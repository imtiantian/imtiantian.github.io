{"pages":[{"text":"《Python+Cookbook》第三版中文","url":"pages/shu-ji.html","tags":"pages","title":"书籍"},{"text":"最近经常需要用Python计算时间日期，如：计算两个日期间的日期列表，函数如下： from datetime import datetime , timedelta def get_date_among_two_date ( start_date , end_date ): a_day = timedelta ( days = 1 ) res = [] while start_date <= end_date : res . append ( start_date ) start_date += a_day return res 后来了解到了 dateutil 库，发现用 dateutil 库实现更为简单,实现如下： from dateutil.rrule import * def get_date_among_two_date ( start_date , end_date ): return list ( rrule ( DAILY , dtstart = start_date , until = end_date )) dateutil 用法 relativedelta （时间偏移） 例： from datetime import datetime ; from dateutil.relativedelta import relativedelta #计算指定日期与现在的差值 now_date = datetime . now () relativedelta ( datetime ( 2003 , 10 , 24 , 10 , 0 ), now_date ) ''' 结果：relativedelta(years=-14, months=-1, days=-15, hours=-5, minutes=-33, seconds=-38, microseconds=+866005) ''' #计算下个月的今天 datetime . today () + relativelta ( months =+ 1 ) parser （根据字符串解析成datetime） 例： from dateutil import parser parser . parse ( \"2003-09-25T10:49:41\" ) parser . parse ( \"20030925T104941\" ) #fuzzy开启模糊匹配，过滤掉无法识别的时间日期字符 parse ( \"this is 12:00:00\" , fuzzy = True ) ''' fuzzy_with_tokens开启模糊匹配,返回一个元组 其中第一个元素是已解析的datetime 第二个元素是一个包含被忽略的字符串的部分的元组 ''' parse ( 'this is 12:00:00' , fuzzy_with_tokens = True ) rrule （根据定义的规则来生成datetime） class dateutil.rrule.rrule(freq, dtstart=None, interval=1, wkst=None, count=None, until=None, bysetpos=None, bymonth=None, bymonthday=None, byyearday=None, byeaster=None, byweekno=None, byweekday=None, byhour=None, byminute=None, bysecond=None, cache=False) freq --- 时间单位。可以是 YEARLY, MONTHLY, WEEKLY, DAILY,HOURLY, MINUTELY, SECONDLY。即年月日周时分秒。 dtstart --- 开始时间 until --- 结束时间 wkst --- 周开始时间。 interval --- 间隔。 count --- 指定生成多少个。 by*** --- 指定匹配的周期。比如byweekday=(MO,TU)则只有周一周二的匹配。byweekday可以指定MO,TU,WE,TH,FR,SA,SU。即周一到周日。 例： from dateutil.rrule import * #计算两日期之间的日期，间隔为3 list ( rrule ( DAILY , interval = 3 , dtstart = parse ( '2017-12-01' ), until = parse ( '2017-12-24' ))) #计算两日期之间的日期，返回前三个 list ( rrule ( DAILY , count = 3 , dtstart = parse ( '2017-12-01' ))) #计算两日期之间的周六周天的日期 list ( rrule ( DAILY , byweekday = ( SA , SU ), dtstart = parse ( '2017-12-01' ), until = parse ( '2018-02-24' ))) #按月为单位 list ( rrule ( MONTHLY , dtstart = parse ( '2017-05-19' ), until = parse ( '2017-12-20' ))) dateutil 文档地址","url":"posts/python/dateutil库（datetime模块的扩展）.html","tags":"python","title":"dateutil库（datetime模块的扩展）"},{"text":"数据类型 Redis支持五种数据类型： string （字符串）， hash （哈希）， list （列表）， set （集合）及 zset (sorted set：有序集合)。 1. String （字符串）操作 redis中的String在在内存中按照一个name对应一个value来存储 set(name, value, ex=None, px=None, nx=False, xx=False) 在Redis中设置值，不存在则创建，存在则修改 参数 意义 ex 过期时间（秒） px 过期时间（毫秒） nx 如果设置为True，则只有name不存在时，当前set操作才执行,同setnx(name, value) xx 如果设置为True，则只有name存在时，当前set操作才执行 setex(name, value, time) 设置过期时间（秒） psetex(name, time_ms, value) 设置过期时间（豪秒） mset(name1='***', name2='***',......) 批量设置值 get(name) 获取值 mget(*keys) 批量获取值 getset(name, value) 设置新值，打印原值 getrange(key, start, end) 获取值,并切片，返回切片后的结果 setrange(name, offset, value) 修改字符串内容，从指定字符串索引开始向后替换，如果新值太长时，则向后添加 setbit(name, offset, value) 对二进制表示位进行操作 getbit(name, offset) 获取name对应值的二进制中某位的值(0或1) bitcount(key, start=None, end=None) 获取对应二进制中1的个数 strlen(name) 返回name对应值的字节长度（一个汉字3个字节） incr(name, amount=1) 自增name对应的值，当name不存在时，则创建name＝amount，否则，则自增,amount为自增数(整数) incrbyfloat(name, amount=1.0) 类似 incr() 自增,amount为自增数(浮点数) decr(name, amount=1) 自减name对应的值,当name不存在时,则创建name＝amount，否则，则自减，amount为自增数(整数) append(name, value) 在name对应的值后面追加内容 2. Hash （哈希）操作 redis中的Hash 在内存中类似于一个name对应一个dic来存储 hset(name, key, value) name对应的hash中设置一个键值对。不存在，则创建，否则，修改。 hget(name,key) 在name对应的hash中根据key获取value hgetall(name) 获取name对应hash的所有键值 hmset(name, dict) 在name对应的hash中批量设置键值对 hmget(name, keys) 在name对应的hash中获取多个key的值 hlen(name) 获取hash中键值对的个数 hkeys(name) 获取hash中所有的key的值 hvals(name) 获取hash中所有的value的值 hexists(name, key) 检查name对应的hash是否存在当前传入的key hdel(name,*keys) 删除指定name对应的key所在的键值对 hincrby(name, key, amount) 自增hash中key对应的值，不存在则创建key=amount(amount为整数) hincrbyfloat(name, key, amount) 自增hash中key对应的值，不存在则创建key=amount(amount为浮点数) hscan(name, cursor=0, match=None, count=None) hscan_iter(name, match=None, count=None) List （列表）操作 redis中的List在在内存中按照一个name对应一个List来存储 lpush(name,*values) 在name对应的list中添加元素，每个新的元素都添加到列表的最左边 rpush(name,*values) 同 lpush ，但每个新的元素都添加到列表的最右边 lpushx(name,value) 在name对应的list中添加元素，只有name已经存在时，值添加到列表的最左边 rpushx(name,value) 在name对应的list中添加元素，只有name已经存在时，值添加到列表的最右边 llen(name) name对应的list元素的个数 linsert(name, where, refvalue, value)) 在name对应的列表的某一个值前或后插入一个新值 参数 意义 name redis的name where BEFORE（前）或AFTER（后） refvalue 列表内的值 value 要插入的数据 r.lset(name, index, value) 对list中的某一个索引位置重新赋值 lrem(name, value, num) 删除name对应的list中的指定值 name --- redis的name value --- 要删除的值 num --- num为0，表示删除列表中所有的指定值； num为n，表示从前到后删除n个； num为-n：从后向前删除n个 lpop(name) 移除列表的左侧第一个元素，返回值是移除的元素 lindex(name, index) 根据索引获取列表内元素 lrange(name, start, end) 分片获取元素 ltrim(name, start, end) 移除列表内没有在该索引之内的值 rpoplpush(src, dst) # 从一个列表取出最右边的元素，同时将其添加至另一个列表的最左边，src要取数据的列表，dst要添加数据的列表 brpoplpush(src, dst, timeout=0) 同rpoplpush，多了个timeout, timeout：取数据的列表没元素后的阻塞时间，0为一直阻塞 blpop(keys, timeout) 将多个列表排列,按照从左到右去移除各个列表内的元素；timeout: 超时时间，获取完所有列表的元素之后，阻塞等待列表内有数据的时间（秒）, 0 表示永远阻塞 brpop(keys, timeout) 同blpop，将多个列表排列,按照从右像左去移除各个列表内的元素 Set （集合）操作 Set集合就是不允许重复的列表 sadd(name,*values) 给name对应的集合中添加元素 smembers(name) 获取name对应的集合的所有成员 scard(name) 获取name对应的集合中的元素个数 sdiff(name, *names) 在第一个name对应的集合中且不在其他name对应的集合的元素集合 例： import redis , time r = redis . Redis ( host = '127.0.0.1' , port = 6379 ) r . sadd ( \"name\" , \"a\" , \"b\" ) r . sadd ( \"name1\" , \"b\" , \"c\" ) r . sadd ( \"name2\" , \"b\" , \"c\" , \"d\" ) print ( r . sdiff ( \"name\" , \"name1\" , \"name2\" )) #输出:｛a｝ sdiffstore(dest, name, *names) 相当于把 sdiff 获取的值加入到dest对应的集合中 sinter(*names) 获取多个name对应集合的交集 例： import redis , time r = redis . Redis ( host = '127.0.0.1' , port = 6379 ) r . sadd ( \"name\" , \"a\" , \"b\" ) r . sadd ( \"name1\" , \"b\" , \"c\" ) r . sadd ( \"name2\" , \"b\" , \"c\" , \"d\" ) print ( r . sinter ( \"name\" , \"name1\" , \"name2\" )) #输出:｛b｝ sinterstore(dest, name, *names) 获取多个name对应集合的交集，再讲其加入到dest对应的集合中；相当于把 sinter 获取的值加入到dest对应的集合中 sismember(name, value) 检查value是否是name对应的集合内的元素 smove(src, dst, value) 将某个元素从一个集合中移动到另外一个集合 spop(name) 从集合的右侧移除一个元素，并将其返回 srandmember(name, numbers) 从name对应的集合中随机获取numbers个元素 srem(name, *values) 删除name对应的集合中的某些值 sunion(*names) 获取多个name对应的集合的并集 sunionstore(dest,*names) 获取多个name对应的集合的并集，并将结果保存到dest对应的集合中 zset （有序集合） 在集合的基础上，为每元素排序，元素的排序需要根据另外一个值来进行比较，所以，对于有序集合，每一个元素有两个值，即：值和分数，分数专门用来做排序 zadd(name, *args, **kwargs) 在name对应的有序集合中添加元素 zcard(name) 获取有序集合内元素的数量 zcount(name, min, max) 获取有序集合中分数在min~max之间的个数 zincrby(name, value, amount) 自增有序集合内value对应的分数 zrange( name, start, end, desc=False, withscores=False, score_cast_func=float) 按照索引范围获取name对应的有序集合的元素 参数 意义 name redis的name start 有序集合索引起始位置 end 有序集合索引结束位置 desc 排序规则，默认按照分数从小到大排序 withscores 是否获取元素的分数，默认只获取元素的值 score_cast_func 对分数进行数据转换的函数 zrevrange(name, start, end, withscores=False, score_cast_func=float) 同 zrange ，集合是从大到小排序的 zrank(name, value) 获取value值在name对应的有序集合中的排行位置（从0开始） zrevrank(name, value) 同 zrank ，集合是从大到小排序的 zscore(name, value) 获取name对应有序集合中 value 对应的分数 zrem(name, *values) 删除name对应的有序集合中值是values的成员 zremrangebyrank(name, min, max) 根据排行范围删除 zremrangebyscore(name, min, max) 根据分数范围删除 zinterstore(dest, *keys, aggregate=None) 获取两个有序集合的交集并放入dest集合，如果遇到相同值不同分数，则按照aggregate进行操作。aggregate的值为: SUM MIN MAX zunionstore(dest, keys, aggregate=None) 获取两个有序集合的并集并放入dest集合，其他同 zinterstore 其他常用操作 delete(*names) 根据name删除redis中的任意数据类型 exists(name) 检测redis的name是否存在 keys(pattern='*') 根据* ？等通配符匹配获取redis的name expire(name ,time) 为某个name设置超时时间 rename(src, dst) 重命名 move(name, db)) 将redis的某个值移动到指定的db下 randomkey() 随机获取一个redis的name（不删除） type(name) 获取name对应值的类型","url":"posts/python/python操作redis.html","tags":"python","title":"python操作redis"},{"text":"打算将博客移到github上，比较过hexo,jekyll,pelican等静态博客生成工具，个人对于Python比较熟悉，于是选择了pelican. 安装 安装pelican pip install pelican 安装可选包 如果您打算使用Markdown作为标记格式，则需要安装Markdown库： pip install Markdown 可以在设置文件中启用排印增强功能，但首先必须安装必需的Typogrify库： pip install typogrify 搭建博客站点 创建目录，存放pelican的框架 mkdir blog //创建文件夹 生成pelican的框架 pelican-quickstart//执行命令，生成pelican的框架 命令成功执行后，会出现pelican的框架，目录结构如下所示 blog/ ├── content # 存放输入的markdown或RST源文件 │ └── (pages) # 存放手工创建的静态页面，可选 │ └── (posts) # 存放手工创建的文章，可选 ├── output # 存放最终生成的静态博客 ├── develop_server.sh # 测试服务器 ├── Makefile # 管理博客的Makefile ├── pelicanconf.py # 配置文件 └── publishconf.py # 发布文件，可删除 为了层次清楚，可以在 content 目录下新建 pages 和 posts 目录，分别存放单页面和文章 选择博客主题 在 blog 目录下，执行如下操作： ·克隆主题到本地 git clone https://github.com/getpelican/pelican-themes.git ·使用主题，在 pelicanconf.py 配置文件中，添加下面行 #这里根据自己喜好选择主题模板 THEME = 'pelican-themes/pelican-bootstrap3' 书写文章 在posts Title : 测试文章 Date : 2010 - 12 - 03 10 : 20 Modified : 2010 - 12 - 05 19 : 30 Category : Python Tags : pelican , ceshi Slug : ceshi Authors : admin Summary : Short version for index and feeds 测试文章内容 . 上面个选项与其意义如下： 选项 意义 Title 文章标题 Date 发布时间 Modified 更新时间 Category 文章所属分类 Tags 文章标签 Slug url名称 Authors 作者 Summary 简介 生成博客站点 pelican /path/to/your/content/ [-s path/to/your/settings.py] 如：在 blog 目录下执行 pelican content/ 命令 预览生成的站点 在 output 目录下执行： python -m http.server 9000 浏览 \"http://localhost:9000/ \"地址预览效果 pelicanconf.py 配置文件详解 注：以下配置选项部分为 pelican 通用的配置选项，部分为 pelican-bootstrap3 模板独有的配置选项 选项 意义 AUTHOR 默认作者 SITENAME 网站名称 SITEURL 网站url SITELOGO 网站logo FAVICON 网站FAVICON PATH 内容路径 STATIC_PATHS 静态资源目录 SUMMARY_MAX_LENGTH 文章摘要的长度 ARTICLE_URL 文章页url,例：'posts/ ARTICLE_SAVE_AS 生成的文章保存路径,例：'posts/ PAGE_URL 单页面url,'pages/ PAGE_SAVE_AS 生成的单页面保存路径,'pages/ DISPLAY_BREADCRUMBS 是否开启面包屑导航 DISPLAY_CATEGORY_IN_BREADCRUMBS 分类或单页面是否开启面包屑导航 DISPLAY_CATEGORIES_ON_MENU 是否在菜单上显示分类 DISPLAY_CATEGORIES_ON_SIDEBAR 是否在侧边栏上显示分类 DISPLAY_TAGS_ON_SIDEBAR 是否在侧边栏上显示标签 TAG_CLOUD_MAX_ITEMS 侧边栏显示标签的最大数量 DISPLAY_TAGS_INLINE 侧边栏标签样式是否内联 AVATAR 侧边栏用户头像 ABOUT_ME 侧边栏用户简介 GITHUB_USER github用户名 GITHUB_SKIP_FORK 未知 GITHUB_SHOW_USER_LINK 是否展示github链接 HIDE_SIDEBAR 是否隐藏侧边栏 PYGMENTS_STYLE 代码块样式 1 BOOTSTRAP_FLUID 是否使用bootstrap流式布局 DEFAULT_DATE_FORMAT 文章时间格式 TIMEZONE 时区 DEFAULT_LANG 语言 DIRECT_TEMPLATES 内容集合索引页面,值为一个列表 2 BANNER 索引页的横幅图片 BANNER_SUBTITLE 横幅文字 DISPLAY_ARTICLE_INFO_ON_INDEX 索引页是否显示文章日期，标签等信息 SHOW_ARTICLE_CATEGORY 文章页是否显示文章分类 BOOTSTRAP_NAVBAR_INVERSE 是否为bootstrap反向导航条 BOOTSTRAP_THEME bootstrap样式 3 TAGS_URL 标签页url CUSTOM_CSS 自定义css样式文件路径 CUSTOM_JS 自定义js文件路径 MARKDOWN markdown配置 MENUITEMS 额外菜单,如： (('标签', '/tags.html'),) LINKS 链接，如： (('我的博客', 'https://imtiantian.github.io'),) SOCIAL 如：(('给我写信', 'http://mail.qq.com/cgi-bin/**','envelope'),) DEFAULT_PAGINATION 每页文章数量 PLUGIN_PATHS 插件路径 PLUGINS 使用的插件名称 JINJA_ENVIRONMENT 位置 OUTPUT_PATH 静态博客输出路径 THEME 使用的模板路径 文章详情页，添加内容导航 // 根据h1,h2,h3,h4标签，生成文章内容导航目录 function articleIndex() { var $article = $ ( '#content>article>.entry-content' ); var $header = $article . find ( 'h1, h2, h3,h4' ); if ( $header . length > 0 ){ var _html = '<div class=\"panel panel-default widget-outline\"><div class=\"panel-heading\" id=\"hideOutline\"><a data-toggle=\"collapse\" href=\"#collapseDir\">目录结构<span class=\"pull-right glyphicon glyphicon-chevron-down\"></span></a></div><div id=\"collapseDir\" class=\"panel-body panel-collapse collapse in\"><ul id=\"articleIndex\"></ul></div></div>' ; $ ( '#sidebar' ). prepend ( _html ); var _tagLevel = 1 ; // 最初的level var _$wrap = $ ( '#articleIndex' ); // 最初的wrap $header . each ( function ( index ) { if ( $ ( this ). text (). trim () === '' ) { // 空的title return ; } //$(this).attr('id', 'articleHeader' + index); // 加id //var this_id = 'articleHeader' + index; var this_id = $ ( this ). attr ( 'id' ); var _tl = parseInt ( $ ( this )[ 0 ]. tagName . slice ( 1 )); // 当前的tagLevel var _$li = null ; if ( index === 0 || _tl === _tagLevel ) { // 第一个或者是与上一个相同 _$li = $ ( '<li><a href=\"#' + this_id + '\">' + $ ( this ). text () + '</a></li>' ); _$wrap . append ( _$li ); } else if ( _tl > _tagLevel ) { // 当前的大于上次的 _$li = $ ( '<ul><li><a href=\"#' + this_id + '\">' + $ ( this ). text () + '</a></li></ul>' ); _$wrap . append ( _$li ); _$wrap = _$li ; } else if ( _tl < _tagLevel ) { // 当前的小于上次的 _$li = $ ( '<li><a href=\"#' + this_id + '\">' + $ ( this ). text () + '</a></li>' ); if ( _tl === 1 ) { $ ( '#articleIndex' ). append ( _$li ); _$wrap = $ ( '#articleIndex' ); } else { _$wrap . parent ( 'ul' ). append ( _$li ); _$wrap = _$wrap . parent ( 'ul' ); } } _tagLevel = _tl ; }); } } 代码块样式选项：autumn，borland，bw，colorful，default，emacs，friendly，fruity，manni，monokai，murphy，native，pastie，perldoc，solarizeddark，solarizedlight，tango，trac，vim，vs，zenburn。默认为native ↩ 内容集合索引：index，categories，authors，archives ↩ bootstrap样式选项:simplex，yeti，superhero，cosmo，flatly，journal，readable，paper，cerulean ↩","url":"posts/python/使用pelican搭建github pages博客.html","tags":"python","title":"使用pelican搭建github pages博客"},{"text":"crontab配置文件格式 * * * * * COMMAND | | | | | | | | | |__星期0~7，（0或7表示星期天） | | | |_____月份1~12 | | |________日期1~31 | |___________小时0~23 |______________分钟0~59 小结： *表示任何时候都匹配 可以用\"A,B,C\"表示A或者B或者C时执行命令 可以用\"A-B\"表示A到B之间时执行命令 可以用\"\\*/A\"表示每A分钟（小时）等执行一次命令 crontab举例： 每晚21:30重启Apache 30 21 * * * service httpd restart 每月1,10,24号的4:45重启Apach 45 4 1,10,24 * * service httpd restart 每月1到10号的4:45重启Apache 45 4 1-10 * * service httpd restart 每隔两分钟重启Apache */2 * * * * service httpd restart 1-59/2 * * * * service httpd restart 晚上11点到早上7点之间，每隔一小时重启Apache 0 23-7/1 * * * service httpd restart 每天18:00到23:00之间，每隔30分钟重启Apache 0,30 18-23 * * * service httpd restart 0-59/30 18-23 * * * service httpd restart","url":"posts/linux/crontab定时任务.html","tags":"linux","title":"crontab定时任务"},{"text":"开发环境配置静态文件目录： setting.py文件中： INSTALLED_APPS中加入 django.contrib.staticfiles ； 最后面加上下面代码： STATICFILES_DIRS = ( #这里的\"common\"是manage.py同目录下存放静态文件的目录，可随意改名 os.path.join(BASE_DIR, \"common\"), #'D:\\WWW\\demo\\demo1\\common', ) url.py文件后面加上下面代码： from django.contrib.staticfiles.urls import staticfiles_urlpatterns urlpatterns += staticfiles_urlpatterns () 这样就已经可以访问静态文件了\"http:127.0.0.1:8000/common/00000.css\" 为了避免模板中引入静态文件的时候，将路径写死，需配置settings变量的全局引用： 在view 里面引用setting里面的配置信息 from django.conf import settings 接着在view里面定义一个函数读取我们的setting文件的变量 def my_setting(request): return {\"STATIC_URL\":settings.STATIC_URL} 最后我们需要把这个my_setting 函数的方法加入到们到settings 的 TEMPLATES 的配置项里面 TEMPLATES = [ { 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [], 'APP_DIRS': True, 'OPTIONS': { 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', 'LinkageAndPage.views.my_setting'#在这里 ], }, }, ] 模板中引入静态资源 <a href= \" {{ STATIC_URL }} style.css\" > 这是静态资源 </a>","url":"posts/python/Django配置静态文件目录.html","tags":"python","title":"Django配置静态文件目录"},{"text":"首先，安装uwsgi,命令 pip3 install uwsgi ; 在nginx.conf配置文件中， http{} 的最后加上一行： include vhost/*.conf; 目的是引入vhost文件夹下的配置文件； 在 nginx.conf 同目录下创建 vhost 文件夹，用来专门存放你的各种项目应用的配置文件。 假设你已经创建好了Django应用，名字叫‘djangoceshi'；在 vhost 文件夹下新建 djangoceshi.conf 文件，内容： upstream djangoceshi { server unix : /// tmp / djangoceshi . sock ; } server { listen 80 ; server_name djangoceshi.xzwphp.com ; access_log /data/wwwlogs/djangoceshi.xzwphp.com_nginx.log combined ; index index.html index.htm index.py ; #include /usr/local/nginx/conf/rewrite/djangoceshi.conf ; charset utf-8 ; client_max_body_size 75M ; location /media { alias /data/wwwroot/djangoceshi/media ; } location / static { alias /data/wwwroot/djangoceshi/static ; } location / { uwsgi_pass djangoceshi ; include uwsgi_params ; } } #include /usr/local/nginx/conf/rewrite/djangoceshi.conf; 这一行引入的是你的 dangoceshi 的路由规则，我在这里注释掉了。 server_name djangoceshi.xzwphp.com; 这一行是你解析到服务器ip的域名。 charset utf-8; 指定编码。 client_max_body_size 75M; 指定最大上传尺寸。 alias /data/wwwroot/djangoceshi/media; 指定你的媒体文件目录。 alias /data/wwwroot/djangoceshi/static; 指定你的项目的静态资源文件目录，css，js等。 运行命令 nginx -t ，查看配置是否有语法错误；然后再输入命令‘nginx -s reload'使修改的配置生效。 在你的项目所在文件夹，和 manage.py 同目录，创建djangoceshi.ini文件，内容： [uwsgi] chdir = /data/wwwroot/djangoceshi module = djangoceshi.wsgi master = true processes = 10 socket = /tmp/djangoceshi.sock chmod-socket = 664 vacuum = true daemonize = /data/nginx/wsgilogs/djangoceshi.log module = djangoceshi.wsgi 引入你项目的wsgi.py文件。 chdir = /data/wwwroot/djangoceshi 这里写上你项目的所在目录。 daemonize=/data/nginx/wsgilogs/djangoceshi.log 记录你项目的uwsgi的运行记录，需要先建好文件夹，不然会报错，找不到目录，我的文件夹是 /data/nginx/wsgilogs/ 。 启动uwsgi： uwsgi --ini /data/wwwroot/djangoceshi/djangoceshi.ini 然后访问域名 djangoceshi.xzwphp.com ，发现不成功，查看记录文件 djangoceshi.log 发现，报了一个错误： Sun Dec 4 12:57:43 2016 - *** WARNING: you are running uWSGI as root !!! (use the --uid flag) *** 解决办法： 创建 www 用户组和 www 用户； /usr/sbin/groupadd www /usr/sbin/useradd -g www www 编辑Nginx的配置文件 nginx.conf ，将第一行修改为 user www www; 去掉下面两行注释： #error_log logs/error.log; #pid logs/nginx.pid; 在 djangoceshi.ini 文件中添加两行： uid = www gid = www 如： [uwsgi] uid = www gid = www chdir = /data/wwwroot/djangoceshi ...... 再输入命令 nginx -s reload 使修改 nginx.conf 的配置生效; 启动uwsgi, uwsgi --ini /data/wwwroot/djangoceshi/djangoceshi.ini .","url":"posts/python/linux部署Django.html","tags":"python","title":"linux部署Django"},{"text":"找到下面行： AddHandler cgi-script .cgi 去掉前面的#，在后面加上 .py ,如下： AddHandler cgi-script .cgi .py 找到下面行： Options +Indexes +FollowSymLinks 在后面加上 +ExecCGI ,如下： Options +Indexes +FollowSymLinks +Multiviews +ExecCGI 保存，重启apache。 在index.py文件中添加如下： 1 2 3 4 5 6 7 # -*- coding : UTF - 8 -*- print ( ' Status : 200 OK ' ) print ( ' Content - type : text / html ' ) print ( '' ) print ( \"Hello word!\" ) 上面代码除了最后一行以外，其他都必须； 第一行写明python路径，下面要返回http头信息； 然后再打印一个空字符串； 最后一行输出你想要输出的内容。","url":"posts/python/python-CGI编程.html","tags":"python","title":"python-CGI编程"},{"text":"创建 复制一个已创建的仓库: $ git clone ssh://user@domain.com/repo.git 创建一个新的本地仓库: $ git init 本地修改 显示工作路径下已修改的文件： $ git status 显示与上次提交版本文件的不同： $ git diff 把当前所有修改添加到下次提交中： $ git add 把对某个文件的修改添加到下次提交中： $ git add -p <file> 提交本地的所有修改： $ git commit -a 提交之前已标记的变化： $ git commit 附加消息提交： $ git commit -m 'message here' 提交，并将提交时间设置为之前的某个日期: git commit --date=\"`date --date='n day ago'`\" -am \"Commit Message\" 修改上次提交 请勿修改已发布的提交记录! $ git commit --amend 把当前分支中未提交的修改移动到其他分支 git stash git checkout branch2 git stash pop 搜索 从当前目录的所有文件中查找文本内容： $ git grep \"Hello\" 在某一版本中搜索文本： $ git grep \"Hello\" v2.5 提交历史 从最新提交开始，显示所有的提交记录（显示hash， 作者信息，提交的标题和时间）： $ git log 显示所有提交（仅显示提交的hash和message）： $ git log --oneline 显示某个用户的所有提交： $ git log --author = \"username\" 显示某个文件的所有修改： $ git log -p <file> 谁，在什么时间，修改了文件的什么内容： $ git blame <file> 分支与标签 列出所有的分支： $ git branch 切换分支： $ git checkout <branch> 创建并切换到新分支: $ git checkout -b <branch> 基于当前分支创建新分支： $ git branch <new-branch> 基于远程分支创建新的可追溯的分支： $ git branch --track <new-branch> <remote-branch> 删除本地分支: $ git branch -d <branch> 给当前版本打标签： $ git tag <tag-name> 更新与发布 列出当前配置的远程端： $ git remote -v 显示远程端的信息： $ git remote show <remote> 添加新的远程端： $ git remote add <remote> <url> 下载远程端版本，但不合并到HEAD中： $ git fetch <remote> 下载远程端版本，并自动与HEAD版本合并： $ git remote pull <remote> <url> 将远程端版本合并到本地版本中： $ git pull origin master 将本地版本发布到远程端： $ git push remote <remote> <branch> 删除远程端分支： $ git push <remote> :<branch> ( since Git v1.5.0 ) 或 git push <remote> --delete <branch> ( since Git v1.7.0 ) 发布标签: $ git push --tags 合并与重置 将分支合并到当前HEAD中： $ git merge <branch> 将当前HEAD版本重置到分支中: 请勿重置已发布的提交! $ git rebase <branch> 退出重置: $ git rebase --abort 解决冲突后继续重置： $ git rebase --continue 使用配置好的merge tool 解决冲突： $ git mergetool 在编辑器中手动解决冲突后，标记文件为已解决冲突 $ git add <resolved-file> $ git rm <resolved-file> 撤销 放弃工作目录下的所有修改： $ git reset --hard HEAD 移除缓存区的所有文件（i.e. 撤销上次git add）: $ git reset HEAD 放弃某个文件的所有本地修改： $ git checkout HEAD <file> 重置一个提交（通过创建一个截然不同的新提交） $ git revert <commit> 将HEAD重置到指定的版本，并抛弃该版本之后的所有修改： $ git reset --hard <commit> 将HEAD重置到上一次提交的版本，并将之后的修改标记为未添加到缓存区的修改： $ git reset <commit> 将HEAD重置到上一次提交的版本，并保留未提交的本地修改： $ git reset --keep <commit> git速查表","url":"posts/qi-ta/git常用命令.html","tags":"其他","title":"git常用命令"},{"text":"用 django-admin.py startproject your-project 命令创建项目 报错：ImportError: No module named django.core 明明已经安装好了Django，却提示没有Django模块，搞什么鬼？ 最后查阅资料发现，是因为安装了多个版本Python。 解决办法： python3 /usr/local/python3.5.2/lib/python3.5/site-packages/django/bin/django-admin.py startproject your-project 注意：对于window用户，卸载其他版本Python，也可解决问题；但linux用户，万万不可卸载其他版本的Python，必须用上面方法解决。 配置MySQL数据库，用‘pip3 install PyMySQL'命令安装了pymysql扩展，却还是报错 报错：No module named 'MySQLdb' 在__init__.py文件中添加下面代码，即可解决： import pymysql pymysql . install_as_MySQLdb () 为了方便测试，在服务器上 python manage.py runserver 0.0.0.0:8080 ，外网却不能通过服务器ip访问，也不报错，后来发现是防火墙的原因，除了指定的端口外，其他端口访问都会被防火墙拒绝，解决办法： iptables -I INPUT 4 -p tcp -m state --state NEW -m tcp --dport 8080 -j ACCEPT 允许 8080 端口 service iptables save 保存 iptables 规则 然后再通过\"http://139.196.++.+++:8080\" 访问，报错了： 报错：You may need to add '139.196.++.+++' to ALLOWED_HOSTS. 解决办法：在setting.py文件中，找到 ALLOWED_HOSTS = [] ,在\"[]\"中添加你的服务器外网ip地址，如： ALLOWED_HOSTS = ['139.196.++.+++'] 然后在你本机，通过\"http://服务器ip:8080\" 就可以访问你服务器上面的Django项目啦","url":"posts/python/安装Django遇到的坑.html","tags":"python","title":"安装Django遇到的坑"},{"text":"class Ceshi { public $array ; /* * 对一个不存在的属性进行赋值时，触发此方法 * */ function __set ( $name , $value ) { // TODO: Implement __set() method. $this -> array [ $name ] = $value ; } /* * 获取一个不存在的属性时，触发此方法 * */ function __get ( $name ) { // TODO: Implement __get() method. return $this -> array [ $name ]; } /* *当调用一个不存在的非静态方法时，会触发此函数 * */ function __call ( $name , $arguments ) { // TODO: Implement __call() method. echo 'function\"' . $name . '\"不存在' ; } /* *当调用一个不存在的静态方法时，会触发此函数 * */ static function __callStatic ( $name , $arguments ) { // TODO: Implement __callStatic() method. echo '静态function\"' . $name . '\"不存在' ; } /* *当把对象当成字符串直接输出时，会触发此函数 * */ function __toString () { // TODO: Implement __toString() method. var_dump ( $this ); return '不能直接输出一个对象' ; } /* * 当把对象当成函数使用时，会触发此函数 * */ function __invoke ( $arguments ) { // TODO: Implement __invoke() method. echo '不能把对象当成函数使用' ; } }","url":"posts/php/php常用魔术方法.html","tags":"php","title":"php常用魔术方法"},{"text":"","url":"posts/shu-ju-ku/mysql开发技巧-join连表查询.html","tags":"数据库","title":"mysql开发技巧-join连表查询"},{"text":"当发生一个事件后，可能需要执行多种业务的逻辑操作，这里的每一种逻辑都是一个观察者。 观察者基类 abstract class EventGenerator{ private $observers = [];//观察者对象数组 /* * 添加观察者 * */ function addObserver(Observer $observer){ $this->observers[] = $observer; } /* * 通知观察者 * */ function notify(){ foreach ($this->observers as $observer){ $observer->logic(); } } } 观察者接口 interface Observer { function logic ( $event_info = '' ); } 触发事件，通知观察者的类 class Event extends EventGenerator { function trigger (){ echo 'Event' ; //触发了一个事件 $this -> notify (); //通知观察者 } } 这是一个观察者 class ObserverOne implements Observer { function logic ( $event_info = '' ){ echo '逻辑一' ; } } 触发事件 $event = new \\Event(); $event->addObserver(new \\ObserverOne());//添加观察者 $event->trigger();//触发事件","url":"posts/php/php观察者模式.html","tags":"php","title":"php观察者模式"},{"text":"有个 Databases 类，传统用法是，哪里需要，哪里 new Databases; ;这样若 Databases 对象发生了改变，则有实例化 Databases 的地方都要相应改变。 采用工厂模式实现： /* *工厂模式 **/ class Factory { static function createDatabases (){ $Databases = new Databases (); return $Databases ; } } // 通过工厂方法调用Databases类 \\ Factory :: createDatabases (); 好处：当我们对象所对应的类的类名发生变化的时候，我们只需要改一下工厂类类里面的实例化方法即可。不需要外部改所有的地方","url":"posts/php/php简单工厂模式.html","tags":"php","title":"php简单工厂模式"},{"text":"获取用户id为$id的用户对象 /* *数据映射模式 **/ class User { //这里的id,name,age属性和数据库中的字段相对应 public $id ; public $name ; public $age ; protected $db ; function __construct ( $id ) { $this -> id = $id ; $this -> db = new Db \\ Pdo (); $user = $this -> db -> connent ( '127.0.0.1' , 'blog' , 'root' , '123456' ) -> query ( \"select * from user where id={$id}\" ); $this -> name = $user [ 'name' ]; $this -> age = $user [ 'age' ]; } //这里实现当对象属性改变时，实现数据库修改 function __destruct () { $this -> db -> query ( \"update user set name={$this->name},age={$this->age} where id={$this->id}\" ); } } 注册id为$id的用户对象 /* *工厂模式 **/ class Factory { static function createUser ( $id ){ $user = new User ( $id ); Register :: _set ( 'user' , $user ); //注册User对象 } } 实现用户对象修改 \\ Factory :: createUser ( 1 );// 调用工厂方法 ， 注册id为1的用户对象 $ user = \\ Register :: _get ( 'user' ); 获取用户对象 // 这里修改id为1的用户对象的某个属性后 ， 就会调用对象的析构方法 ， 改变数据库相应字段 $ user- > name = 'tiantian' ;// 修改用户姓名 $ user- > age = 18 ;// 修改用户年龄","url":"posts/php/php数据映射模式.html","tags":"php","title":"php数据映射模式"},{"text":"需求：对于不同的用户展示不同的内容 定义接口 interface UserStrategy { function showAd (); //展示广告 function showCategory (); //展示分类 } 普通用户展示的内容 class CommonUser implements UserStrategy { public function showAd () { // TODO: Implement showAd() method. //展示普通用户广告 } public function showCategory () { // TODO: Implement showCategory() method. //展示普通用户商品分类 } } vip用户展示的内容 class VipUser implements UserStrategy { public function showAd () { // TODO: Implement showAd() method. //展示会员广告 } public function showCategory () { // TODO: Implement showCategory() method. //展示会员商品分类 } } 设置用户对象，展示用户页面 class UserPage { protected $user_object ; //用户对象，vip用户或普通用户 /* * 设置用户对象 * */ function strategy ( UserStrategy $strategy ){ $this -> user_object = $strategy ; } function index (){ $ad = $this -> user_object -> showAd (); //获取广告 $category = $this -> user_object -> showAd (); //获取商品分类 } } 根据不同用户，展示不同界面 if($is_vip == true){ $strategy = new \\VipUser(); }else{ $strategy = new \\CommonUser(); } $user_page = new UserPage(); $user_page->strategy($strategy)->index();","url":"posts/php/php策略模式.html","tags":"php","title":"php策略模式"},{"text":"像thinkphp，执行一个数据库查询操作； D('User')->field('id,name')->where(['age'=>['lt',18]])->order('age desc')->select(); 无论你是使用 pdo 或是 mysqli 还或是 其他 连接方式操作数据库，查询语句始终是上面那样。 数据库接口 interface Databases { //数据库连接 function connent ( $host , $dbname , $user , $password ); //数据库查询 function query ( $sql ); //关闭数据库连接 function close (); } pdo连接操作数据库 class Pdo implements Databases { protected $conn ; //保存当前对象 function connent ( $host , $dbname , $user , $password ) { // TODO: Implement connent() method. $conn = new \\ PDO ( \"mysql:dbname=$dbname;host=$host\" , $user , $password ); $this -> conn = $conn ; return $this ; } function query ( $sql ) { // TODO: Implement query() method. $result = $this -> conn -> query ( $sql ); $row = $result -> fetch (); return $row ; } function close () { // TODO: Implement close() method. mysqli_close ( $this -> conn ); } } mysqli连接操作数据库 class Mysqli implements Databases { protected $conn ; //保存当前对象 function connent ( $host , $dbname , $user , $password ) { // TODO: Implement connent() method. $conn = mysqli_connect ( $host , $user , $password , $dbname ); $this -> conn = $conn ; return $this ; } function query ( $sql ) { // TODO: Implement query() method. $result = mysqli_query ( $this -> conn , $sql ); $row = mysqli_fetch_all ( $result ); return $row ; } function close () { // TODO: Implement close() method. mysqli_close ( $this -> conn ); } } 查询操作 //$db = new Db\\Pdo(); $db = new Db\\Mysqli(); $result = $db->connent('127.0.0.1','blog','root','123456')->query();","url":"posts/php/php适配器模式.html","tags":"php","title":"php适配器模式"},{"text":"一个对象，可能很多地方需要用到；每用到一次，就new一次，浪费资源。通过注册器模式，初始化的时候注册对象，往后就可以直接获取注册器中的对象，而不用再new。 1. 注册器类 /* *注册树模式 **/ class Register { protected static $objects ; //对象数组 /* * 注册对象 * */ static function _set ( $name , $object ){ self :: $objects [ $name ] = $object ; } /* * 获取对象 * */ static function _get ( $name ){ return self :: $objects [ $name ]; } /* * 删除对象 * */ static function _unset ( $name ){ unset ( self :: $objects [ $name ]); } } 2. 注册databases对象的方法 /* *工厂模式 **/ class Factory { static function createDatabases (){ $db = Databases :: getDatabases (); Register :: _set ( 'databases' , $db ); //注册databases对象 } } 3. 注册databases对象 \\ Factory :: createDatabases (); 4. 通过注册器，获取databases对象 \\ Register :: _get ( 'databases' ); 初始化时，调用\"\\Factroy::createDatabase()\"，注册databases对象; 然后就可以在任何地方通过直接\"\\Register::get('databases')\"，获取databases对象； 也就是初始化时只需调用一次\"\\Factroy::createDatabase()\"，往后不用再调用\"\\Factroy::createDatabase()\"方法了，直接\"IMooc\\Register::get('databases')\"获取；","url":"posts/php/php注册树模式.html","tags":"php","title":"php注册树模式"},{"text":"通过单例模式获取 Databases 对象 class Databases { protected $db ; //保存当前对象 private function __construct () { //私有的构造方法，意在禁止外部直接new Databases() } /* * 实现单列模式 * 若需要调用对象，则通过下面方法调用 * */ static function getDatabases () { if ( self :: $db ) { return self :: $db ; } else { return self :: $db = new self (); } } } /* *工厂模式 **/ class Factory { //获取Databases对象 static function createDatabases (){ $db = Databases :: getDatabases (); return $db ; } } // 通过工厂方法调用Databases类 \\ Factory :: createDatabases ();","url":"posts/php/php单例模式.html","tags":"php","title":"php单例模式"},{"text":"","url":"posts/php/php常用函数.html","tags":"php","title":"php常用函数"},{"text":"相信大家经常看到对比一些 PHP 应用中，说用 isset() 替换 in_array()，isset 比 in_array 执行速度快等。 例子： if ( isset($user) ) { //do some thing } 原因是 isset 是语言结构，而 in_array 是一个函数。那什么是语言结构呢？它和函数有什 么不同吗？ 1、什么是语言结构和函数 语言结构：就是 PHP 语言的关键词，语言语法的一部分；它不可以被用户定义或者添加到 语言扩展或者库中；它可以有也可以没有变量和返回值。 函数：由代码块组成的，可以复用。从源码的角度来说，也就是基于 Zend 引擎的基础来 实现的，ext 拓展库中的函数都是这样实现的。 2、 语言结构为什么比函数快 原因是在 PHP 中，函数都要先被 PHP 解析器（Zend 引擎）分解成语言结构，所以有此 可见，函数比语言结构多了一层解析器解析。这样就能比较好的理解，什么语言结构比函 数快了。 3、语言结构和函数的不同 语言结构比对应功能的函数快 语言结构在错误处理上比较鲁莽，由于是语言关键词，所以不具备再处理的环节 语言结构不能在配置项(php.ini)中禁用，函数则可以。 语言结构不能被用做回调函数 4、语言结构列表 echo() print() die() isset() unset() include()，注意，include_once()是函数 require()，注意，require_once()是函数 array() list() empty()","url":"posts/php/php语言结构和函数.html","tags":"php","title":"php语言结构和函数"},{"text":"一、数学函数 abs(x) 返回x的绝对值 bin(x) 返回x的二进制（oct返回八进制，hex返回十六进制） ceiling(x) 返回大于x的最小整数值 exp(x) 返回值e（自然对数的底）的x次方 floor(x) 返回小于x的最大整数值 greatest(x1,x2,...,xn) 返回集合中最大的值 least(x1,x2,...,xn) 返回集合中最小的值 ln(x) 返回x的自然对数 log(x,y) 返回x的以y为底的对数 mod(x,y) 返回x/y的模（余数） pi() 返回pi的值（圆周率） rand() 返回０到１内的随机值,可以通过提供一个参数(种子)使rand()随机数生成器生成一个指定的值。 round(x,y) 返回参数x的四舍五入的有y位小数的值 sign(x) 返回代表数字x的符号的值 sqrt(x) 返回一个数的平方根 truncate(x,y) 返回数字x截短为y位小数的结果 二、聚合函数(常用于group by从句的select查询中) avg(col) 返回指定列的平均值 count(col) 返回指定列中非null值的个数 min(col) 返回指定列的最小值 max(col) 返回指定列的最大值 sum(col) 返回指定列的所有值之和 group_concat(col) 返回由属于一组的列值连接组合而成的结果 三、字符串函数 ascii(char) 返回字符的ascii码值 bit_length(str) 返回字符串的比特长度 concat(s1,s2...,sn) 将s1,s2...,sn连接成字符串 concat_ws(sep,s1,s2...,sn) 将s1,s2...,sn连接成字符串，并用sep字符间隔 insert(str,x,y,instr) 将字符串str从第x位置开始，y个字符长的子串替换为字符串instr，返回结果 find_in_set(str,list) 分析逗号分隔的list列表，如果发现str，返回str在list中的位置 lcase(str) 或 lower(str) 返回将字符串str中所有字符改变为小写后的结果 left(str,x) 返回字符串str中最左边的x个字符 length(s) 返回字符串str中的字符数 ltrim(str) 从字符串str中切掉开头的空格 position(substr,str) 返回子串substr在字符串str中第一次出现的位置 quote(str) 用反斜杠转义str中的单引号 repeat(str,srchstr,rplcstr) 返回字符串str重复x次的结果 reverse(str) 返回颠倒字符串str的结果 right(str,x) 返回字符串str中最右边的x个字符 rtrim(str) 返回字符串str尾部的空格 strcmp(s1,s2) 比较字符串s1和s2 trim(str) 去除字符串首部和尾部的所有空格 ucase(str) 或 upper(str) 返回将字符串str中所有字符转变为大写后的结果 四、日期和时间函数 curdate() 或 current_date() 返回当前的日期 curtime() 或 current_time() 返回当前的时间 date_add(date,interval int keyword) 返回日期date加上间隔时间int的结果(int必须按照关键字进行格式化),如： select date_add(current_date,interval 6 month) ; date_format(date,fmt) 依照指定的fmt格式格式化日期date值 date_sub(date,interval int keyword) 返回日期date加上间隔时间int的结果(int必须按照关键字进行格式化),如： select date_sub(current_date,interval 6 month) ; dayofweek(date) 返回date所代表的一星期中的第几天(1~7) dayofmonth(date) 返回date是一个月的第几天(1~31) dayofyear(date) 返回date是一年的第几天(1~366) dayname(date) 返回date的星期名，如：select dayname(current_date); from_unixtime(ts,fmt) 根据指定的fmt格式，格式化unix时间戳ts hour(time) 返回time的小时值(0~23) minute(time) 返回time的分钟值(0~59) month(date) 返回date的月份值(1~12) monthname(date) 返回date的月份名，如： select monthname(current_date) ; now() 返回当前的日期和时间 quarter(date) 返回date在一年中的季度(1~4)，如 select quarter(current_date) ; week(date) 返回日期date为一年中第几周(0~53) year(date) 返回日期date的年份(1000~9999) 一些示例： 获取当前系统时间： select from_unixtime(unix_timestamp()); select extract(year_month from current_date); select extract(day_second from current_date); select extract(hour_minute from current_date); 返回两个日期值之间的差值(月数)： select period_diff(200302,199802); 在mysql中计算年龄： select date_format(from_days(to_days(now())-to_days(birthday)),'%y')+0 as age from employee; 这样，如果brithday是未来的年月日的话，计算结果为0。 下面的sql语句计算员工的绝对年龄，即当birthday是未来的日期时，将得到负值。 select date_format(now(), '%y') - date_format(birthday, '%y') -(date_format(now(), '00-%m-%d') \\<date_format(birthday, '00-%m-%d')) as age from employee 五、加密函数 aes_encrypt(str,key) 返回用密钥key对字符串str利用高级加密标准算法加密后的结果，调用aes_encrypt的结果是一个二进制字符串，以blob类型存储 aes_decrypt(str,key) 返回用密钥key对字符串str利用高级加密标准算法解密后的结果 decode(str,key) 使用key作为密钥解密加密字符串str encrypt(str,salt) 使用 unixcrypt() 函数，用关键词salt(一个可以惟一确定口令的字符串，就像钥匙一样)加密字符串str encode(str,key) 使用key作为密钥加密字符串str，调用 encode() 的结果是一个二进制字符串，它以blob类型存储 md5() 计算字符串str的md5校验和 password(str) 返回字符串str的加密版本，这个加密过程是不可逆转的，和unix密码加密过程使用不同的算法。 sha() 计算字符串str的安全散列算法(sha)校验和 示例： select encrypt('root','salt'); select encode('xufeng','key'); select decode(encode('xufeng','key'),'key');#加解密放在一起 select aes_encrypt('root','key'); select aes_decrypt(aes_encrypt('root','key'),'key'); select md5('123456'); select sha('123456'); 六、控制流函数 mysql有4个函数是用来进行条件操作的，这些函数可以实现sql的条件逻辑，允许开发者将一些应用程序业务逻辑转换到数据库后台。 mysql控制流函数： case when[test1] then [result1]...else [default] end 如果testn是真，则返回resultn，否则返回default case [test] when[val1] then [result]...else [default]end 如果test和valn相等，则返回resultn，否则返回default if(test,t,f) 如果test是真，返回t；否则返回f ifnull(arg1,arg2) 如果arg1不是空，返回arg1，否则返回arg2 nullif(arg1,arg2) 如果arg1=arg2返回null；否则返回arg1 这些函数的第一个是ifnull()，它有两个参数，并且对第一个参数进行判断。如果第一个参数不是null，函数就会向调用者返回第一个参数；如果是null,将返回第二个参数。 如： select ifnull(1,2), ifnull(null,10),ifnull(4*null,'false') ; nullif()函数将会检验提供的两个参数是否相等，如果相等，则返回null，如果不相等，就返回第一个参数; 如： select nullif(1,1),nullif('a','b'),nullif(2+3,4+1) ; 和许多脚本语言提供的if()函数一样，mysql的if()函数也可以建立一个简单的条件测试，这个函数有三个参数，第一个是要被判断的表达式，如果表达式为真，if()将会返回第二个参数，如果为假，if()将会返回第三个参数。 如： select if(1<10,2,3),if(56>100,'true','false') ; if()函数在只有两种可能结果时才适合使用。然而，在现实世界中，我们可能发现在条件测试中会需要多个分支。在这种情况下，mysql提供了case函数，它和php及perl语言的switch-case条件例程一样。 case函数的格式有些复杂，通常如下所示： case [ expression to be evaluated ] when [ val 1 ] then [ result 1 ] when [ val 2 ] then [ result 2 ] when [ val 3 ] then [ result 3 ] ...... when [ val n ] then [ result n ] else [ default result ] end 这里，第一个参数是要被判断的值或表达式，接下来的是一系列的when-then块，每一块的第一个参数指定要比较的值，如果为真，就返回结果。 所有的when-then块将以else块结束，当end结束了所有外部的case块时，如果前面的每一个块都不匹配就会返回else块指定的默认结果。 如果没有指定else块，而且所有的when-then比较都不是真，mysql将会返回null。 case函数还有另外一种句法，有时使用起来非常方便，如下： case when [ conditional test 1 ] then [ result 1 ] when [ conditional test 2 ] then [ result 2 ] else [ default result ] end 这种条件下，返回的结果取决于相应的条件测试是否为真。 示例： select case 'green' when 'red' then 'stop' when 'green' then 'go' end; select case 9 when 1 then 'a' when 2 then 'b' else 'n/a' end; select case when (2+2)=4 then 'ok' when(2+2)<>4 then 'not ok' end asstatus; select name,if((isactive = 1),'已激活','未激活') as result fromuserlogininfo; select fname,lname,(math+sci+lit) as total, case when (math+sci+lit) < 50 then 'd' when (math+sci+lit) between 50 and 150 then 'c' when (math+sci+lit) between 151 and 250 then 'b' else 'a' end as grade from marks; select if(encrypt('sue','ts')=upass,'allow','deny') as loginresultfrom users where uname = 'sue';#一个登陆验证 七、格式化函数 date_format(date,fmt) 依照字符串fmt格式化日期date值 format(x,y) 把x格式化为以逗号隔开的数字序列，y是结果的小数位数 inet_aton(ip) 返回ip地址的数字表示 inet_ntoa(num) 返回数字所代表的ip地址 time_format(time,fmt) 依照字符串fmt格式化时间time值 其中最简单的是 format() 函数，它可以把大的数值格式化为以逗号间隔的易读的序列。 示例： select format ( 34234 . 34323432 , 3 ); select date_format ( now (), '%w,%d %m %y %r' ); select date_format ( now (), '%y-%m-%d' ); select date_format ( 19990330 , '%y-%m-%d' ); select date_format ( now (), '%h:%i %p' ); select inet_aton ( '10.122.89.47' ); select inet_ntoa ( 175790383 ); 八、类型转化函数 为了进行数据类型转化，mysql提供了 cast() 函数，它可以把一个值转化为指定的数据类型。类型有：binary,char,date,time,datetime,signed,unsigned 示例： select cast(now() as signed integer),curdate()+0; select 'f'=binary 'f','f'=cast('f' as binary); 九、系统信息函数 database() 返回当前数据库名 benchmark(count,expr) 将表达式expr重复运行count次 connection_id() 返回当前客户的连接id found_rows() 返回最后一个select查询进行检索的总行数 user() 或 system_user() 返回当前登陆用户名 version() 返回mysql服务器的版本 示例： select database(),version(),user(); select benchmark(9999999,log(rand()*pi()));#该例中,mysql计算log(rand()*pi())表达式9999999次。","url":"posts/shu-ju-ku/mysql常用函数.html","tags":"数据库","title":"mysql常用函数"},{"text":"一.数据库的连接 mysql -u -p -h -u 用户名 -p 密码 -h host主机 二.修改MySQL提示符 1.连接客户端时，通过参数指定 mysql -h localhost -u root --prompt 提示符 2.连接上客户端后，通过 prompt 命令修改 prompt 提示符 MySQL提示符 参数 描述 \\D 完整的日期 \\d 当前数据库 \\h 服务器名称 \\u 当前用户 三.库级知识 1 显示数据库: show databases ; 2 选择数据库: use dbname ; 3 创建数据库: create database dbname charset utf8 ; 4 删除数据库: drop database dbname ; 四. 表级操作 1 显示库下面的表: show tables ; 2 查看表的结构: desc tableName ; 3 查看表的创建过程: show create table tableName ; 4 创建表: create table tbName ( 列名称1 列类型 [列参数] [not null default ], ....列2... .... 列名称N 列类型 [列参数] [not null default ] )engine myisam/innodb charset utf8/gbk 例子: create table user ( id int auto_increment, name varchar(20) not null default '', age tinyint unsigned not null default 0, index id (id) )engine=innodb charset=utf8; 注：innodb是表引擎,也可以是myisam或其他,但最常用的是myisam和innodb,charset 常用的有utf8,gbk; 5 修改表 （1）修改表之增加列: alter table tbName add 列名称１ 列类型 [列参数] [not null default ] 注：add之后的旧列名之后的语法和创建表时的列声明一样 （2）修改表之修改列 alter table tbName change 旧列名 新列名 列类型 [列参数] [not null default ] 注：旧列名之后的语法和创建表时的列声明一样 （3）修改表之减少列: alter table tbName drop 列名称; （4）修改表之增加主键 alter table tbName add primary key(主键所在列名); 例: alter table goods add primary key(id) 该例是把主键建立在id列上 （5）修改表之删除主键 alter table tbName drop primary key; （6）修改表之增加索引 alter table tbName add [unique|fulltext] index 索引名(列名); （7）修改表之删除索引 alter table tbName drop index 索引名; （8）清空表的数据 truncate tableName; 五.列类型讲解 整型: tinyint ( 0 ~ 255 / -128 ~ 127 ) smallint ( 0 ~ 65535 / -32768 ~ 32767 ) mediumint int bigint 参数解释 : unsigned 无符号 ( 不能为负 ) zerofill 0填充 M 填充后的宽度 举例 : tinyint unsigned ; tinyint ( 6 ) zerofill ; 数值型 浮点型 : float double 格式 : float ( M , D ) unsigned \\ zerofill ; 字符型 char(m) 定长 varchar(m)变长 text 日期时间类型 year YYYY 范围:1901~2155. 可输入值2位和4位(如98,2012) date YYYY-MM-DD 如:2010-03-14 time HH:MM:SS 如:19:26:32 datetime YYYY-MM-DD HH:MM:SS 如:2010-03-14 19:26:32 timestamp YYYY-MM-DD HH:MM:SS 特性:不用赋值,该列会为自己赋当前的具体时间 六.增删改查 1.插入数据 insert into 表名(col1,col2,……) values(val1,val2……); -- 插入指定列 insert into 表名 values (,,,,); -- 插入所有列 insert into 表名 values -- 一次插入多行 (val1,val2……), (val1,val2……), (val1,val2……); 2.修改数据 update tablename set col1=newval1, col2=newval2, ... ... colN=newvalN where 条件; 3.删除数据 delete from tablenaeme where 条件; 4.select 查询 （1） 条件查询 where 1 比较运算符 = ，!=，< > <= >= 2 like , not like ('%'匹配任意多个字符,'_'匹配任意单个字符) 3 in , not in , between and 4 is null , is not null （2） 分组 group by 一般要配合5个聚合函数使用: max,min,sum,avg,count （3） 筛选 having （4） 排序 order by （5） 限制 limit 七.连接查询 1.左连接 .. left join .. on table A left join table B on tableA.col1 = tableB.col2 ; 例句: select 列名 from table A left join table B on tableA.col1 = tableB.col2 2.右链接: right join 3.内连接: inner join 左右连接都是以在左边的表的数据为准,沿着左表查右表. 内连接是以两张表都有的共同部分数据为准,也就是左右连接的数据之交集. 八.子查询 where 型子查询:内层sql的返回值在where后作为条件表达式的一部分 例句: select * from tableA where colA = (select colB from tableB where ...); from 型子查询:内层sql查询结果,作为一张表,供外层的sql语句再次查询 例句: select * from (select * from ...) as tableName where .... 存储引擎 engine=Myisam\\Innodb 1 Myisam 速度快 不支持事务 回滚 2 Innodb 速度慢 支持事务,回滚 ①开启事务 start transaction ; ②运行sql; ③提交,同时生效\\回滚 commit\\rollback ; 触发器 trigger 监视地点:表 监视行为:增 删 改 触发时间:after\\before 触发事件:增 删 改 创建触发器语法 create trigger tgName after/before insert/delete/update on tableName for each row sql; -- 触发语句 删除触发器: drop trigger tgName ; 索引 提高查询速度,但是降低了增删改的速度,所以使用索引时,要综合考虑. 索引不是越多越好,一般我们在常出现于条件表达式中的列加索引. 值越分散的列，索引的效果越好 索引类型 primary key 主键索引 index 普通索引 unique index 唯一性索引 fulltext index 全文索引 mysql的常用命令 显示当前服务器版本 select version() ; 显示当前日期时间 select now() ; 显示当前用户 select user ; 语法规则 关键字和函数名称全部大写 数据库形成、表名称、字段名称全部小写 SQL语句必须以分号结尾；","url":"posts/shu-ju-ku/mysql基础知识.html","tags":"数据库","title":"mysql基础知识"},{"text":"cURL可以使用URL的语法模拟浏览器来传输数据， 因为它是模拟浏览器，因此它同样支持多种协议， FTP, FTPS, HTTP, HTTPS, GOPHER, TELNET, DICT, FILE 以及 LDAP等协议都可以很好的支持，包括一些： HTTPS认证，HTTP POST方法，HTTP PUT方法，FTP上传，keyberos认证，HTTP上传，代理服务器，cookies，用户名/密码认证， 下载文件断点续传，上传文件断点续传，http代理服务器管道，甚至它还支持IPv6，scoket5代理服务器，通过http代理服务器上传文件 到FTP服务器等等。 这就是我们为什么要使用cURL的原因！ 使用cURL完成简单的请求主要分为以下四步： 1.初始化，创建一个新cURL资源 2.设置URL和相应的选项 3.抓取URL并把它传递给浏览器 4.关闭cURL资源，并且释放系统资源 我们来采集一个页面，通常情况下，我们会使用file_get_contents()函数来获取： 像这样： <?php $str = file_get_contents ( 'http://bbs.lampbrother.net' ); //或者是： $str = file ( \"http://bbs.lampbrother.net\" ); //或者是： readfile ( \"http://bbs.lampbrother.net\" ); ?> 这样我们会发现，我们没有办法有效地进行错误处理，更重要的是我们没有办法完成一些高难度的任务： 如：处理cookies，验证，表单提交，文件上传等等。 好，现在我们来用代码完成上述cURL的四步： <?php //1.初始化，创建一个新cURL资源 $ch = curl_init (); //2.设置URL和相应的选项 curl_setopt ( $ch , CURLOPT_URL , \"http://www.lampbrother.net/\" ); curl_setopt ( $ch , CURLOPT_HEADER , 0 ); //3.抓取URL并把它传递给浏览器 curl_exec ( $ch ); //4.关闭cURL资源，并且释放系统资源 curl_close ( $ch ); ?> 上述四步中，其中第二步最为关键，可以设置一些高级选项： 例如上例中的CURLOPT_URL和CURLOPT_HEADER，分别代表\"需要获取的URL地址\"和\"启用时会将头文件的信息作为数据流输出\"，这些只是冰山一角，我们还可以设置很多选项： 选项 可选value值 备注 CURLOPT_AUTOREFERER 当根据Location:重定向时，自动设置header中的Referer:信息。 CURLOPT_BINARYTRANSFER 在启用CURLOPT_RETURNTRANSFER的时候，返回原生的（Raw）输出。 CURLOPT_COOKIESESSION 状况下cURL会将所有的cookie返回给服务端。session cookie是指那些用来判断服务器端的session是否有效而存在的cookie。 CURLOPT_CRLF 启用时将Unix的换行符转换成回车换行符。 CURLOPT_DNS_USE_GLOBAL_CACHE 启用时会启用一个全局的DNS缓存，此项为线程安全的，并且默认启用。 CURLOPT_FAILONERROR 显示HTTP状态码，默认行为是忽略编号小于等于400的HTTP信息。 CURLOPT_FILETIME 启用时会尝试修改远程文档中的信息。结果信息会通过curl_getinfo()函数的CURLINFO_FILETIME选项返回。 curl_getinfo(). CURLOPT_FOLLOWLOCATION 启用时会将服务器服务器返回的\"Location: \"放在header中递归的返回给服务器，使用CURLOPT_MAXREDIRS可以限定递归返回的数量。 CURLOPT_FORBID_REUSE 在完成交互以后强迫断开连接，不能重用。 CURLOPT_FRESH_CONNECT 强制获取一个新的连接，替代缓存中的连接。 CURLOPT_FTP_USE_EPRT 启用时当FTP下载时，使用EPRT (或 LPRT)命令。设置为FALSE时禁用EPRT和LPRT，使用PORT命令 only. CURLOPT_FTP_USE_EPSV 启用时，在FTP传输过程中回复到PASV模式前首先尝试EPSV命令。设置为FALSE时禁用EPSV命令。 CURLOPT_FTPAPPEND 启用时追加写入文件而不是覆盖它。 CURLOPT_FTPASCII CURLOPT_TRANSFERTEXT的别名。 CURLOPT_FTPLISTONLY 启用时只列出FTP目录的名字。 CURLOPT_HEADER 启用时会将头文件的信息作为数据流输出。 CURLINFO_HEADER_OUT 启用时追踪句柄的请求字符串。 从 PHP 5.1.3 开始可用。CURLINFO_前缀是故意的(intentional)。 CURLOPT_HTTPGET 启用时会设置HTTP的method为GET，因为GET是默认是，所以只在被修改的情况下使用。 CURLOPT_HTTPPROXYTUNNEL 启用时会通过HTTP代理来传输。 CURLOPT_MUTE 启用时将cURL函数中所有修改过的参数恢复默认值。 CURLOPT_NETRC 在连接建立以后，访问~/.netrc文件获取用户名和密码信息连接远程站点。 CURLOPT_NOBODY 启用时将不对HTML中的BODY部分进行输出。 CURLOPT_NOPROGRESS 启用时关闭curl传输的进度条，此项的默认设置为启用。 PHP自动地设置这个选项为TRUE，这个选项仅仅应当在以调试为目的时被改变。 CURLOPT_NOSIGNAL 启用时忽略所有的curl传递给php进行的信号。在SAPI多线程传输时此项被默认启用。 cURL 7.10时被加入。 CURLOPT_POST 启用时会发送一个常规的POST请求，类型为：application/x-www-form-urlencoded，就像表单提交的一样。 CURLOPT_PUT 启用时允许HTTP发送文件，必须同时设置CURLOPT_INFILE和CURLOPT_INFILESIZE。 CURLOPT_RETURNTRANSFER 将curl_exec()获取的信息以文件流的形式返回，而不是直接输出。 CURLOPT_SSL_VERIFYPEER 禁用后cURL将终止从服务端进行验证。使用CURLOPT_CAINFO选项设置证书使用CURLOPT_CAPATH选项设置证书目录 如果CURLOPT_SSL_VERIFYPEER(默认值为2)被启用，CURLOPT_SSL_VERIFYHOST需要被设置成TRUE否则设置为FALSE。 自cURL 7.10开始默认为TRUE。从cURL 7.10开始默认绑定安装。 CURLOPT_TRANSFERTEXT 启用后对FTP传输使用ASCII模式。对于LDAP，它检索纯文本信息而非HTML。在Windows系统上，系统不会把STDOUT设置成binary模式。 CURLOPT_UNRESTRICTED_AUTH 在使用CURLOPT_FOLLOWLOCATION产生的header中的多个locations中持续追加用户名和密码信息，即使域名已发生改变。 CURLOPT_UPLOAD 启用后允许文件上传。 CURLOPT_VERBOSE 启用时会汇报所有的信息，存放在STDERR或指定的CURLOPT_STDERR中。 对于下面的这些option的可选参数，value应该被设置一个integer类型的值： 选项 可选value值 CURLOPT_BUFFERSIZE 每次获取的数据中读入缓存的大小，但是不保证这个值每次都会被填满。 CURLOPT_CLOSEPOLICY 不是CURLCLOSEPOLICY_LEAST_RECENTLY_USED就是CURLCLOSEPOLICY_OLDEST，还存在另外三个CURLCLOSEPOLICY_，但是cURL暂时还不支持。 CURLOPT_CONNECTTIMEOUT 在发起连接前等待的时间，如果设置为0，则无限等待。 CURLOPT_CONNECTTIMEOUT_MS 尝试连接等待的时间，以毫秒为单位。如果设置为0，则无限等待。 CURLOPT_DNS_CACHE_TIMEOUT 设置在内存中保存DNS信息的时间，默认为120秒。 CURLOPT_FTPSSLAUTH FTP验证方式：CURLFTPAUTH_SSL (首先尝试SSL)，CURLFTPAUTH_TLS (首先尝试TLS)或CURLFTPAUTH_DEFAULT (让cURL自动决定)。 CURLOPT_HTTP_VERSION CURL_HTTP_VERSION_NONE (默认值，让cURL自己判断使用哪个版本)，CURL_HTTP_VERSION_1_0 (强制使用 HTTP/1.0)或CURL_HTTP_VERSION_1_1 (强制使用 HTTP/1.1)。 CURLOPT_HTTPAUTH 使用的HTTP验证方法，可选的值有：CURLAUTH_BASIC、CURLAUTH_DIGEST、CURLAUTH_GSSNEGOTIATE、CURLAUTH_NTLM、CURLAUTH_ANY和CURLAUTH_ANYSAFE。 可以使用位域(或)操作符分隔多个值，cURL让服务器选择一个支持最好的值。 CURLAUTH_ANY等价于CURLAUTH_BASIC , CURLAUTH_DIGEST , CURLAUTH_GSSNEGOTIATE , CURLAUTH_NTLM。 CURLAUTH_ANYSAFE等价于CURLAUTH_DIGEST , CURLAUTH_GSSNEGOTIATE , CURLAUTH_NTLM. CURLOPT_INFILESIZE 设定上传文件的大小限制，字节(byte)为单位。 CURLOPT_LOW_SPEED_LIMIT 当传输速度小于CURLOPT_LOW_SPEED_LIMIT时(bytes/sec)，PHP会根据CURLOPT_LOW_SPEED_TIME来判断是否因太慢而取消传输。 CURLOPT_LOW_SPEED_TIME 当传输速度小于CURLOPT_LOW_SPEED_LIMIT时(bytes/sec)，PHP会根据CURLOPT_LOW_SPEED_TIME来判断是否因太慢而取消传输。 CURLOPT_MAXCONNECTS 允许的最大连接数量，超过是会通过CURLOPT_CLOSEPOLICY决定应该停止哪些连接。 CURLOPT_MAXREDIRS 指定最多的HTTP重定向的数量，这个选项是和CURLOPT_FOLLOWLOCATION一起使用的。 CURLOPT_PORT 用来指定连接端口。（可选项） CURLOPT_PROTOCOLS CURLPROTO_*的位域指。如果被启用，位域值会限定libcurl在传输过程中有哪些可使用的协议。这将允许你在编译libcurl时支持众多协议，但是限制只是用它们中被允许使用的一个子集。默认libcurl将会使用全部它支持的协议。参见CURLOPT_REDIR_PROTOCOLS. 可用的协议选项为：CURLPROTO_HTTP、CURLPROTO_HTTPS、CURLPROTO_FTP、CURLPROTO_FTPS、CURLPROTO_SCP、CURLPROTO_SFTP、CURLPROTO_TELNET、CURLPROTO_LDAP、CURLPROTO_LDAPS、CURLPROTO_DICT、CURLPROTO_FILE、CURLPROTO_TFTP、CURLPROTO_ALL CURLOPT_PROXYAUTH HTTP代理连接的验证方式。使用在CURLOPT_HTTPAUTH中的位域标志来设置相应选项。对于代理验证只有CURLAUTH_BASIC和CURLAUTH_NTLM当前被支持。 CURLOPT_PROXYPORT 代理服务器的端口。端口也可以在CURLOPT_PROXY中进行设置。 CURLOPT_PROXYTYPE 不是CURLPROXY_HTTP (默认值) 就是CURLPROXY_SOCKS5。 CURLOPT_REDIR_PROTOCOLS CURLPROTO_*中的位域值。如果被启用，位域值将会限制传输线程在CURLOPT_FOLLOWLOCATION开启时跟随某个重定向时可使用的协议。这将使你对重定向时限制传输线程使用被允许的协议子集默认libcurl将会允许除FILE和SCP之外的全部协议。这个和7.19.4预发布版本种无条件地跟随所有支持的协议有一些不同。关于协议常量，请参照CURLOPT_PROTOCOLS。 CURLOPT_RESUME_FROM 在恢复传输时传递一个字节偏移量（用来断点续传）。 CURLOPT_SSL_VERIFYHOST 1 检查服务器SSL证书中是否存在一个公用名(common name)。译者注：公用名(Common Name)一般来讲就是填写你将要申请SSL证书的域名 (domain)或子域名(sub domain)。2 检查公用名是否存在，并且是否与提供的主机名匹配。 CURLOPT_SSLVERSION 使用的SSL版本(2 或 3)。默认情况下PHP会自己检测这个值，尽管有些情况下需要手动地进行设置。 CURLOPT_TIMECONDITION 如果在CURLOPT_TIMEVALUE指定的某个时间以后被编辑过，则使用CURL_TIMECOND_IFMODSINCE返回页面，如果没有被修改过，并且CURLOPT_HEADER为true，则返回一个\"304 Not Modified\"的header， CURLOPT_HEADER为false，则使用CURL_TIMECOND_IFUNMODSINCE，默认值为CURL_TIMECOND_IFUNMODSINCE。 CURLOPT_TIMEOUT 设置cURL允许执行的最长秒数。 CURLOPT_TIMEOUT_MS 设置cURL允许执行的最长毫秒数。 CURLOPT_TIMEVALUE 设置一个CURLOPT_TIMECONDITION使用的时间戳，在默认状态下使用的是CURL_TIMECOND_IFMODSINCE。 对于下面的这些option的可选参数，value应该被设置一个string类型的值： 选项 可选value值 备注 CURLOPT_CAINFO 一个保存着1个或多个用来让服务端验证的证书的文件名。这个参数仅仅在和CURLOPT_SSL_VERIFYPEER一起使用时才有意义。 . CURLOPT_CAPATH 一个保存着多个CA证书的目录。这个选项是和CURLOPT_SSL_VERIFYPEER一起使用的。 CURLOPT_COOKIE 设定HTTP请求中\"Cookie: \"部分的内容。多个cookie用分号分隔，分号后带一个空格(例如， \"fruit=apple; colour=red\")。 CURLOPT_COOKIEFILE 包含cookie数据的文件名，cookie文件的格式可以是Netscape格式，或者只是纯HTTP头部信息存入文件。 CURLOPT_COOKIEJAR 连接结束后保存cookie信息的文件。 CURLOPT_CUSTOMREQUEST 使用一个自定义的请求信息来代替\"GET\"或\"HEAD\"作为HTTP请求。这对于执行\"DELETE\" 或者其他更隐蔽的HTTP请求。有效值如\"GET\"，\"POST\"，\"CONNECT\"等等。也就是说，不要在这里输入整个HTTP请求。例如输入\"GET /index.html HTTP/1.0 \"是不正确的。Note: 在确定服务器支持这个自定义请求的方法前不要使用。 CURLOPT_EGDSOCKET 类似CURLOPT_RANDOM_FILE，除了一个Entropy Gathering Daemon套接字。 CURLOPT_ENCODING HTTP请求头中\"Accept-Encoding: \"的值。支持的编码有\"identity\"，\"deflate\"和\"gzip\"。如果为空字符串\"\"，请求头会发送所有支持的编码类型。 在cURL 7.10中被加入。 CURLOPT_FTPPORT 这个值将被用来获取供FTP\"POST\"指令所需要的IP地址。\"POST\"指令告诉远程服务器连接到我们指定的IP地址。这个字符串可以是纯文本的IP地址、主机名、一个网络接口名（UNIX下）或者只是一个'-'来使用默认的IP地址。 CURLOPT_INTERFACE 网络发送接口名，可以是一个接口名、IP地址或者是一个主机名。 CURLOPT_KRB4LEVEL KRB4 (Kerberos 4) 安全级别。下面的任何值都是有效的(从低到高的顺序)：\"clear\"、\"safe\"、\"confidential\"、\"private\".。如果字符串和这些都不匹配，将使用\"private\"。这个选项设置为NULL时将禁用KRB4 安全认证。目前KRB4 安全认证只能用于FTP传输。 CURLOPT_POSTFIELDS 全部数据使用HTTP协议中的\"POST\"操作来发送。要发送文件，在文件名前面加上@前缀并使用完整路径。这个参数可以通过urlencoded后的字符串类似'para1=val1&para2=val2&...'或使用一个以字段名为键值，字段数据为值的数组。如果value是一个数组，Content-Type头将会被设置成multipart/form-data。 CURLOPT_PROXY HTTP代理通道。 CURLOPT_PROXYUSERPWD 一个用来连接到代理的\"[username]:[password]\"格式的字符串。 CURLOPT_RANDOM_FILE 一个被用来生成SSL随机数种子的文件名。 CURLOPT_RANGE 以\"X-Y\"的形式，其中X和Y都是可选项获取数据的范围，以字节计。HTTP传输线程也支持几个这样的重复项中间用逗号分隔如\"X-Y,N-M\"。 CURLOPT_REFERER 在HTTP请求头中\"Referer: \"的内容。 CURLOPT_SSL_CIPHER_LIST 一个SSL的加密算法列表。例如RC4-SHA和TLSv1都是可用的加密列表。 CURLOPT_SSLCERT 一个包含PEM格式证书的文件名。 CURLOPT_SSLCERTPASSWD 使用CURLOPT_SSLCERT证书需要的密码。 CURLOPT_SSLCERTTYPE 证书的类型。支持的格式有\"PEM\" (默认值), \"DER\"和\"ENG\"。 在cURL 7.9.3中被加入。 CURLOPT_SSLENGINE 用来在CURLOPT_SSLKEY中指定的SSL私钥的加密引擎变量。 CURLOPT_SSLENGINE_DEFAULT 用来做非对称加密操作的变量。 CURLOPT_SSLKEY 包含SSL私钥的文件名。 CURLOPT_SSLKEYPASSWD 在CURLOPT_SSLKEY中指定了的SSL私钥的密码。Note: 由于这个选项包含了敏感的密码信息，记得保证这个PHP脚本的安全。 CURLOPT_SSLKEYTYPE CURLOPT_SSLKEY中规定的私钥的加密类型，支持的密钥类型为\"PEM\"(默认值)、\"DER\"和\"ENG\"。 CURLOPT_URL 需要获取的URL地址，也可以在curl_init()函数中设置。 CURLOPT_USERAGENT 在HTTP请求中包含一个\"User-Agent: \"头的字符串。 CURLOPT_USERPWD 传递一个连接中需要的用户名和密码，格式为：\"[username]:[password]\"。 对于下面的这些option的可选参数，value应该被设置一个数组： 对于下面的这些option的可选参数，value应该被设置一个流资源 （例如使用fopen()）： 对于下面的这些option的可选参数，value应该被设置为一个回调函数名： 选项 可选value值 CURLOPT_HEADERFUNCTION 设置一个回调函数，这个函数有两个参数，第一个是cURL的资源句柄，第二个是输出的header数据。header数据的输出必须依赖这个函数，返回已写入的数据大小。 CURLOPT_PASSWDFUNCTION 设置一个回调函数，有三个参数，第一个是cURL的资源句柄，第二个是一个密码提示符，第三个参数是密码长度允许的最大值。返回密码的值。 CURLOPT_PROGRESSFUNCTION 设置一个回调函数，有三个参数，第一个是cURL的资源句柄，第二个是一个文件描述符资源，第三个是长度。返回包含的数据。 CURLOPT_READFUNCTION 拥有两个参数的回调函数，第一个是参数是会话句柄，第二是HTTP响应头信息的字符串。使用此函数，将自行处理返回的数据。返回值为数据大小，以字节计。返回0代表EOF信号。 CURLOPT_WRITEFUNCTION 拥有两个参数的回调函数，第一个是参数是会话句柄，第二是HTTP响应头信息的字符串。使用此回调函数，将自行处理响应头信息。响应头信息是整个字符串。设置返回值为精确的已写入字符串长度。发生错误时传输线程终止。 看到了吧，只要在第二个函数之内设置这些选项就可以完成相应的功能，cURL的功能是灰常强大滴，大家可以尝试一下哦！ 例如，我们只想把获取到的内容输入到文件，而不是直接输出给浏览器，我们就可以使用CURLOPT_RETURNTRANSFER选项！ 这样在curl执行的时候，就会把页面的内容输出到文件当中，我们就可以完成采集等功能啦！ 效率方面，curl的原理是模拟浏览器的操作，它的效率要比file_get_contents()高出四倍以上，试想一下，我们 要采集一个信息量特别庞大的站，运行效率的差别可想而知！ 不单单是效率上，稳定性上来说，curl也远比file_get_contents()函数要好很多！ 这就是强大的curl，下文将给大家详细介绍它的高级应用，我们可以模拟浏览器的post传值，甚至上传！","url":"posts/php/php中curl的详细解说.html","tags":"php","title":"php中curl的详细解说"},{"text":"/** * 生成从开始月份到结束月份的月份数组 * @param int $start 开始时间 * @param int $end 结束时间 */ function monthList ( $start , $end ){ $month_arr = array (); $start_timestamp = strtotime ( $start ); $end_timestamp = strtotime ( $end ); $start_timestamp = mktime ( 0 , 0 , 0 , date ( \"n\" , $start_timestamp ), 1 , date ( \"Y\" , $start_timestamp )); $next_timestamp = $start_timestamp ; while ( $next_timestamp <= $end_timestamp ) { $month_arr [] = date ( \"Y-m\" , $next_timestamp ); $next_timestamp = mktime ( 0 , 0 , 0 , date ( \"n\" , $next_timestamp ) + 1 , date ( \"j\" , $next_timestamp ), date ( \"Y\" , $next_timestamp )); }; return $month_arr ; } // 得到日期的上个月的今天 ， 如strtotime ( '2016-10-20' ) 返回得到2016-09-20 function last_month_today ($ time ) { $last_month_time = mktime(date(\"G\", $time), date(\"i\", $time), date(\"s\", $time), date(\"n\", $time), 0, date(\"Y\", $time)) ; $last_month_t = date(\"t\", $last_month_time) ; if ($last_month_t < date(\"j\", $time)) { return date(\"Ymt H : i : s \", $last_month_time); } return date(date(\" Ym \", $last_month_time) . \" d \" , $ time ); } /* * 根据两日期，获取之间的日期列表 * $start_time 开始日期 格式20160701 * $end_time 结束日期 格式20160916 * */ function get_d_list($start_time,$end_time){ $start_time = strtotime($start_time); $end_time = strtotime($end_time); $date_list = array(); for($start_time;$start_time<=$end_time;$start_time=$start_time+3600*24){ $date_list[] = date('Ymd',$start_time); } return $date_list; } /** * [显示友好的时间格式 xx分钟前 xx小时前 xx天 超过3天显示正常时间] * @param [type] $date [description] * @return [type] [description] */ function dataStr($date){ if((time()-$date)<60*10){ //十分钟内 echo '刚刚'; }elseif(((time()-$date)<60*60)&&((time()-$date)>=60*10)){ //超过十分钟少于1小时 $s = floor((time()-$date)/60); echo $s.\"分钟前\"; }elseif(((time()-$date)<60*60*24)&&((time()-$date)>=60*60)){ //超过1小时少于24小时 $s = floor((time()-$date)/60/60); echo $s.\"小时前\"; }elseif(((time()-$date)<60*60*24*3)&&((time()-$date)>=60*60*24)){ //超过1天少于3天内 $s = floor((time()-$date)/60/60/24); echo $s.\"天前\"; }else{ //超过3天 echo date(\"Y/m/d\",$date); } }","url":"posts/php/php日期时间函数.html","tags":"php","title":"php日期时间函数"},{"text":"原文链接： php JSON数据格式化方法 php 的json_encode能把数组转换为json格式的字符串。字符串没有缩进，中文会转为unicode编码，例如\\u975a\\u4ed4。人阅读比较困难。现在这个方法在json_encode的基础上再进行一次美化处理。使人能方便阅读内容。 1. 使用 json_encode 输出 <?php header ( 'content-type:application/json;charset=utf8' ); $arr = array ( 'status' => true , 'errMsg' => '' , 'member' => array ( array ( 'name' => '李逍遥' , 'gender' => '男' ), array ( 'name' => '赵灵儿' , 'gender' => '女' ) ) ); echo json_encode ( $arr ); ?> 输出： {\"status\":true,\"errMsg\":\"\",\"member\":[{\"name\":\"\\u674e\\u900d\\u9065\",\"gender\":\"\\u7537\"},{\"name\":\"\\u8d75\\u7075\\u513f\",\"gender\":\"\\u5973\"}]} 可以看出，这种格式人阅读很困难。 2. 使用 jsonFormat 输出 <? php /** Json数据格式化 * @param Mixed $data 数据 * @param String $indent 缩进字符，默认4个空格 * @return JSON */ function jsonFormat ( $data , $indent = null ){ // 对数组中每个元素递归进行urlencode操作，保护中文字符 array_walk_recursive ( $data , 'jsonFormatProtect' ); // json encode $data = json_encode ( $data ); // 将urlencode的内容进行urldecode $data = urldecode ( $data ); // 缩进处理 $ret = '' ; $pos = 0 ; $length = strlen ( $data ); $indent = isset ( $indent ) ? $indent : ' ' ; $newline = \"\\n\" ; $prevchar = '' ; $outofquotes = true ; for ( $i = 0 ; $i <= $length ; $i ++ ){ $char = substr ( $data , $i , 1 ); if ( $char == '\"' && $prevchar != '\\\\' ){ $outofquotes = ! $outofquotes ; } elseif (( $char == '}' || $char == ']' ) && $outofquotes ){ $ret . = $newline ; $pos -- ; for ( $j = 0 ; $j < $pos ; $j ++ ){ $ret . = $indent ; } } $ret . = $char ; if (( $char == ',' || $char == '{' || $char == '[' ) && $outofquotes ){ $ret . = $newline ; if ( $char == '{' || $char == '[' ){ $pos ++ ; } for ( $j = 0 ; $j < $pos ; $j ++ ){ $ret . = $indent ; } } $prevchar = $char ; } return $ret ; } /** 将数组元素进行urlencode * @param String $val */ function jsonFormatProtect ( & $val ){ if ( $val !== true && $val !== false && $val !== null ){ $val = urlencode ( $val ); } } header ( 'content-type:application/json;charset=utf8' ); $arr = array ( 'status' => true , 'errMsg' => '' , 'member' => array ( array ( 'name' => '李逍遥' , 'gender' => '男' ), array ( 'name' => '赵灵儿' , 'gender' => '女' ) ) ); echo jsonFormat ( $arr ); ?> 输出： { \"status\":true, \"errMsg\":\"\", \"member\":[ { \"name\":\"李逍遥\", \"gender\":\"男\" }, { \"name\":\"赵灵儿\", \"gender\":\"女\" } ] } php5.4 以后，json_encode增加了JSON_UNESCAPED_UNICODE , JSON_PRETTY_PRINT 等几个常量参数。使显示中文与格式化更方便。 header ( 'content-type:application/json;charset=utf8' ); $ arr = array ( 'status' => true , 'errMsg' => '' , 'member' => array ( array ( 'name' => '李逍遥' , 'gender' => '男' ), array ( 'name' => '赵灵儿' , 'gender' => '女' ) ) ); echo json_encode ($ arr , JSON_UNESCAPED_UNICODE | JSON_PRETTY_PRINT ); 输出： { \"status\": true, \"errMsg\": \"\", \"member\": [ { \"name\": \"李逍遥\", \"gender\": \"男\" }, { \"name\": \"赵灵儿\", \"gender\": \"女\" } ] } JSON常量参数说明： 以下常量表示了 json_last_error() 所返回的错误类型。 JSON_ERROR_NONE (integer) 没有错误发生。自 PHP 5.3.0 起生效。 JSON_ERROR_DEPTH (integer) 到达了最大堆栈深度。自 PHP 5.3.0 起生效。 JSON_ERROR_STATE_MISMATCH (integer) 出现了下溢（underflow）或者模式不匹配。自 PHP 5.3.0 起生效。 JSON_ERROR_CTRL_CHAR (integer) 控制字符错误，可能是编码不对。自 PHP 5.3.0 起生效。 JSON_ERROR_SYNTAX (integer) 语法错误。 自 PHP 5.3.0 起生效。 JSON_ERROR_UTF8 (integer) 异常的 UTF-8 字符，也许是因为不正确的编码。 此常量自 PHP 5.3.1 起生效。 下面的常量可以和 json_encode() 的 form 选项结合使用。 JSON_HEX_TAG (integer) 所有的 < 和 > 转换成 \\u003C 和 \\u003E。 自 PHP 5.3.0 起生效。 JSON_HEX_AMP (integer) 所有的 & 转换成 \\u0026。 自 PHP 5.3.0 起生效。 JSON_HEX_APOS (integer) 所有的 ' 转换成 \\u0027。 自 PHP 5.3.0 起生效。 JSON_HEX_QUOT (integer) 所有的 \" 转换成 \\u0022。 自 PHP 5.3.0 起生效。 JSON_FORCE_OBJECT (integer) 使一个非关联数组输出一个类（Object）而非数组。 在数组为空而接受者需要一个类（Object）的时候尤其有用。 自 PHP 5.3.0 起生效。 JSON_NUMERIC_CHECK (integer) 将所有数字字符串编码成数字（numbers）。 自 PHP 5.3.3 起生效。 JSON_BIGINT_AS_STRING (integer) 将大数字编码成原始字符原来的值。 自 PHP 5.4.0 起生效。 JSON_PRETTY_PRINT (integer) 用空白字符格式化返回的数据。 自 PHP 5.4.0 起生效。 JSON_UNESCAPED_SLASHES (integer) 不要编码 /。 自 PHP 5.4.0 起生效。 JSON_UNESCAPED_UNICODE (integer) 以字面编码多字节 Unicode 字符（默认是编码成 \\uXXXX）。 自 PHP 5.4.0 起生效。","url":"posts/php/php JSON数据格式化方法.html","tags":"php","title":"php JSON数据格式化方法"}]}