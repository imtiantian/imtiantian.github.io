<div id="pf19f" class="pf w0 h0" data-page-no="19f"><div class="pc pc19f w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg19f.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x16 hf y1ab ff8 fs5 fc0 sc0 ls0 ws161">resp <span class="fc6 ls33">=</span><span class="ws13a">time<span class="fc6 ls34">.</span>ctime()</span></div><div class="t m0 x16 hf y1ac ff8 fs5 fc0 sc0 ls0 ws13a">sock<span class="fc6">.</span>sendto(resp<span class="fc6 ls34">.</span>encode(<span class="ff9 fc9 ls34">&apos;</span><span class="fc9">ascii<span class="ff9 ws13b">&apos;</span></span><span class="ws15c">), </span><span class="fca">self<span class="fc6 ls34">.</span></span>client_address)</div><div class="t m0 x5 hf y1ae ff7 fs5 fca sc0 ls0 ws157">if <span class="ff8 fc0 ws16d">__name__ <span class="fc6 ws159">== <span class="ff9 fc9 ls34">&apos;</span><span class="fc9 ws13a">__main__<span class="ff9 ls34">&apos;</span></span></span>:</span></div><div class="t m0 x15 hf y1af ff8 fs5 fc0 sc0 ls0 ws13c">serv <span class="fc6 ls32">=</span><span class="ws13a">UDPServer((<span class="ff9 fc9 ws13b">&apos;&apos;</span><span class="ls33">,</span><span class="fc7">20000</span><span class="ws13b">), TimeHandler)</span></span></div><div class="t m0 x15 hf y1b0 ff8 fs5 fc0 sc0 ls0 ws13a">serv<span class="fc6 ls34">.</span>serve_forever()</div><div class="t m0 x0 h9 y2a38 ff1 fs3 fc0 sc0 ls0 wsedc">跟之前<span class="_ _6"></span>一样，<span class="_ _6"></span>你先定<span class="_ _6"></span>义一<span class="_ _6"></span>个实现 <span class="ff6 ws507">handle() </span><span class="wsa0">特<span class="_ _6"></span>殊方<span class="_ _6"></span>法的类，<span class="_ _6"></span>为客户<span class="_ _6"></span>端连<span class="_ _6"></span>接服务。<span class="_ _6"></span>这</span></div><div class="t m0 x5 h7 y2a39 ff1 fs3 fc0 sc0 ls51 wsedd">个类的 <span class="ff6 ls0 wsede">request </span><span class="wsedf">属性是一个包含了数据报和底层 <span class="ff4 ls0 wsee0">so<span class="_ _6"></span>c<span class="_ _1"></span>k<span class="_ _1"></span>et <span class="ff1 wsa0">对象的<span class="_ _6"></span>元组。<span class="ff6 ws3b7">client address</span></span></span></span></div><div class="t m0 x5 h9 y2a3a ff1 fs3 fc0 sc0 ls0">包含了客户端地址。</div><div class="t m0 x0 h7 y2a3b ff1 fs3 fc0 sc0 ls18 wsee1">我们来测试下这个服务器，首先运行它，然后打开另外一个 <span class="ff4 ls0 ws453">Python </span><span class="ws110">进程向服务器<span class="_ _1"></span></span></div><div class="t m0 x5 h9 y2a3c ff1 fs3 fc0 sc0 ls0">发送消息：</div><div class="t m0 x5 hf y2a3d ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="fca ws15a">from <span class="fcc ws146">socket <span class="fca">import <span class="ff8 fc0 ws13b">socket, AF_INET, SOCK_DGRAM</span></span></span></span></div><div class="t m0 x5 hf y2a3e ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls32">s<span class="fc6 ls33">=</span><span class="ls0 ws13b">socket(AF_INET, SOCK_DGRAM)</span></span></div><div class="t m0 x5 hf y2a3f ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls34">s<span class="fc6 ls0 ws13a">.<span class="fc0">sendto(b</span></span><span class="ff9 fc9">&apos;&apos;</span><span class="ls0 ws13b">, (</span><span class="ff9 fc9">&apos;<span class="ff8 ls0 ws13a">localhost</span>&apos;</span><span class="ls32">,<span class="fc7 ls0 ws13a">20000<span class="fc0">))</span></span></span></span></div><div class="t m0 x5 hf y2a40 ff8 fs5 fc8 sc0 ls0">0</div><div class="t m0 x5 hf y2a41 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls34">s<span class="fc6 ls0 ws13a">.<span class="fc0">recvfrom(<span class="fc7">8192</span>)</span></span></span></div><div class="t m0 x5 hf y2a42 ff8 fs5 fc8 sc0 ls0 ws13a">(b<span class="ff9 ls34">&apos;</span><span class="ws4">Wed Aug 15 20:35:08 2012<span class="ff9 ws13b">&apos;</span>, (<span class="ff9 ws13b">&apos;</span></span>127.0.0.1<span class="ff9 ls34">&apos;</span><span class="ws13b">, 20000))</span></div><div class="t m0 x5 hf y2a43 ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x5 he y18a7 ff2 fs2 fc4 sc0 ls0 ws212">13.3.3 <span class="ff1">讨论</span></div><div class="t m0 x0 h7 y1433 ff1 fs3 fc0 sc0 ls14 wsee2">一个典型的 <span class="ff4 ls0 wsee3">UPD </span><span class="wsee4">服务器接收到达的数据报 <span class="ff4 ls1b">(</span><span class="ls0 wsa0">消<span class="_ _6"></span>息<span class="ff4 ls1dc">)</span>和<span class="_ _6"></span>客<span class="_ _6"></span>户<span class="_ _6"></span>端<span class="_ _6"></span>地<span class="_ _6"></span>址。<span class="_ _6"></span>如<span class="_ _6"></span>果<span class="_ _6"></span>服<span class="_ _6"></span>务<span class="_ _6"></span>器<span class="_ _6"></span>需</span></span></div><div class="t m0 x5 h7 y2a44 ff1 fs3 fc0 sc0 lsa8 wsee5">要做应答，它要给客户端回发一个数据报<span class="_ _c"></span>。对于数据报的传送，你应该使用 <span class="ff4 ls0 wsee6">so<span class="_ _6"></span>c<span class="_ _1"></span>k<span class="_ _1"></span>et <span class="ff1">的</span></span></div><div class="t m0 x5 h9 y2a45 ff6 fs3 fc0 sc0 ls0 wsee7">sendto() <span class="ff1 ls1a6">和</span><span class="wsee8">recvfrom() <span class="ff1 wsee9">方<span class="_ _6"></span>法。<span class="_ _0"></span>尽<span class="_ _6"></span>管<span class="_ _6"></span>传<span class="_ _0"></span>统<span class="_ _6"></span>的 </span><span class="wsca8">send() <span class="ff1 ls1dd">和</span><span class="ws9a9">recv() <span class="ff1 ls16 wsf3">也可以达到同样的效<span class="_ _c"></span></span></span></span></span></div><div class="t m0 x5 h7 y2a46 ff1 fs3 fc0 sc0 ls0 ws38">果，但是前面的两个方法对于 <span class="ff4 ws54c">UDP </span>连接而言更普遍。</div><div class="t m0 x0 h7 y2a47 ff1 fs3 fc0 sc0 ls0 wsa0">由于没有底层的连接，<span class="_ _1"></span><span class="ff4 wseea">UPD <span class="ff1 ws1a7">服务器相对于 </span><span class="wseeb">TCP <span class="ff1 wsa0">服务器来讲实现起来更加简单。不</span></span></span></div><div class="t m0 x5 h7 y2a48 ff1 fs3 fc0 sc0 ls0 wsa0">过，<span class="ff4 wseec">UDP </span><span class="ls12 wse4">天生是不可靠的（因为通信没有建立连接，消息可能丢失<span class="_ _1"></span>）<span class="_ _f"></span>。因此需要由你<span class="_ _1"></span></span></div><div class="t m0 x5 h9 y2a49 ff1 fs3 fc0 sc0 ls13 wse5">自己来决定该怎样处理丢失消息的情况<span class="_ _1"></span>。这个已经不在本书讨论范围内了，不过通常<span class="_ _c"></span></div><div class="t m0 x5 h9 y2a4a ff1 fs3 fc0 sc0 ls1e ws111">来说<span class="_ _1"></span>，如果可靠性对于你程序很重要，你需要借助于序列号<span class="_ _c"></span>、重试、超时以及一些其<span class="_ _1"></span></div><div class="t m0 x5 h7 y1340 ff1 fs3 fc0 sc0 ls2c ws12f">他方法来保证。<span class="ff4 ls0 wseed">UDP </span>通常被用在那些对于可靠传输要求不是很高的场合。例如，在实</div><div class="t m0 x5 h9 y2a4b ff1 fs3 fc0 sc0 ls13 wse5">时应用如多媒体流以及游戏领域<span class="_ _1"></span>，无需返回恢复丢失的数据包（程序只需简单的忽略<span class="_ _c"></span></div><div class="t m0 x5 h9 y2a4c ff1 fs3 fc0 sc0 ls0 wsa0">它并继续向前运行）<span class="_ _f"></span>。</div><div class="t m0 x0 h9 y2a4d ff6 fs3 fc0 sc0 ls0 ws8d7">UDPServer <span class="ff1 ls16 wsf3">类是单线程的<span class="_ _c"></span>，也就是说一次只能为一个客户端连接服务<span class="_ _1"></span>。实际使用<span class="_ _c"></span></span></div><div class="t m0 x5 h7 y2a4e ff1 fs3 fc0 sc0 ls0 wseee">中，这个无<span class="_ _6"></span>论是对于 <span class="ff4 wseef">UDP </span><span class="wsef0">还<span class="_ _6"></span>是 <span class="ff4 wsef1">TCP </span><span class="wsa0">都不是什<span class="_ _6"></span>么大问题。<span class="_ _6"></span>如果你想<span class="_ _6"></span>要并发操<span class="_ _6"></span>作，可以</span></span></div><div class="t m0 x5 h9 y2a4f ff1 fs3 fc0 sc0 ls0 ws38">实例化一个 <span class="ff6 ws2fb">ForkingUDPServer </span><span class="ls4">或</span><span class="ff6 ws5a3">ThreadingUDPServer </span>对象：</div><div class="t m0 x5 hf y1fc7 ff7 fs5 fca sc0 ls0 ws15a">from <span class="fcc ws96c">socketserver </span><span class="ws146">import <span class="ff8 fc0">ThreadingUDPServer</span></span></div><div class="t m0 x3c hf y2a50 ff7 fs5 fca sc0 ls0 ws157">if <span class="ff8 fc0 ws16d">__name__ <span class="fc6 ws159">== <span class="ff9 fc9 ls34">&apos;</span><span class="fc9 ws13a">__main__<span class="ff9 ws13b">&apos;</span></span></span>:</span></div><div class="t m0 x15 hf y2a51 ff8 fs5 fc0 sc0 ls0 ws13c">serv <span class="fc6 ls32">=</span><span class="ws13a">ThreadingUDPServer((<span class="ff9 fc9 ws13b">&apos;&apos;</span><span class="ls34">,</span><span class="fc7">20000</span><span class="ws4">), TimeHandler)</span></span></div><div class="t m0 x15 hf y2a52 ff8 fs5 fc0 sc0 ls0 ws13a">serv<span class="fc6 ls34">.</span>serve_forever()</div><div class="t m0 x0 h7 y2a53 ff1 fs3 fc0 sc0 ls0 wsc">直接使用 <span class="ff6 ws25d">socket </span><span class="ws63">来是想一个 <span class="ff4 ws8a">UDP </span>服务器也不难，下面是一个例子：</span></div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 ws21d">13.3.<span class="_ _5"> </span>11.3 <span class="ff1 ws16b">创建 </span><span class="wseda">UDP <span class="ff1 wsedb">服务器 </span>406</span></div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
