<div id="pf12f" class="pf w0 h0" data-page-no="12f"><div class="pc pc12f w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg12f.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 hf y334 ff8 fs5 fc8 sc0 ls0">Data.__del__</div><div class="t m0 x5 hf y335 ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h9 y13a1 ff1 fs3 fc0 sc0 ls42 wsb74">如果循环引用的对象自己还定义了自己的 <span class="ff6 ls0 wsa3e">del<span class="_ _e"> </span>() </span><span class="ws186">方法，那么会让情况变得更糟<span class="_ _1"></span></span></div><div class="t m0 x5 h7 y13a2 ff1 fs3 fc0 sc0 ls0 ws38">糕。假设你像下面这样给 <span class="ff4 ws52">No<span class="_ _6"></span>de </span><span class="ws911">定义自己的 <span class="ff6 ws308">del<span class="_ _e"> </span>() </span>方法：</span></div><div class="t m0 x5 h11 y1fe4 ffa fs5 fcd sc0 ls0 ws4"># Node class involving a cycle</div><div class="t m0 x5 hf y1fe5 ff7 fs5 fca sc0 ls0 ws16a">class <span class="fcc ws156">Node<span class="ff8 fc0">:</span></span></div><div class="t m0 x15 hf y1fe6 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">__init__<span class="fc0">(<span class="fca">self</span>):</span></span></div><div class="t m0 x16 hf y1fe7 ff8 fs5 fca sc0 ls0 ws13a">self<span class="fc6">.<span class="fc0 ws13c">data </span><span class="ls33">=</span><span class="fc0">Data()</span></span></div><div class="t m0 x16 hf y1fe8 ff8 fs5 fca sc0 ls0 ws13a">self<span class="fc6">.<span class="fc0 ws19f">parent </span><span class="ls32">=</span></span>None</div><div class="t m0 x16 hf y1fe9 ff8 fs5 fca sc0 ls0 ws13a">self<span class="fc6">.<span class="fc0 ws16d">children </span><span class="ls32">=</span><span class="fc0">[]</span></span></div><div class="t m0 x15 hf ycfb ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">add_child<span class="fc0 ls34">(</span><span class="fca">self<span class="fc0 ws13b">, child):</span></span></span></div><div class="t m0 x16 hf y1fea ff8 fs5 fca sc0 ls0 ws13a">self<span class="fc6">.<span class="fc0">children</span><span class="ls34">.</span><span class="fc0">append(child)</span></span></div><div class="t m0 x16 hf y1feb ff8 fs5 fc0 sc0 ls0 ws13a">child<span class="fc6 ls34">.</span><span class="ws145">parent <span class="fc6 ls33">=</span><span class="fca">self</span></span></div><div class="t m0 x15 h11 y1fec ffa fs5 fcd sc0 ls0 ws4"># NEVER DEFINE LIKE THIS.</div><div class="t m0 x15 h11 y1fed ffa fs5 fcd sc0 ls0 ws4"># Only here to illustrate pathological behavior</div><div class="t m0 x15 hf y1fee ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">__del__<span class="fc0 ls34">(</span><span class="fca">self<span class="fc0">):</span></span></span></div><div class="t m0 x16 hf y1fef ff7 fs5 fca sc0 ls0 ws139">del <span class="ff8 ws13a">self<span class="fc6">.<span class="fc0">data</span></span></span></div><div class="t m0 x16 hf y1ff0 ff7 fs5 fca sc0 ls0 ws156">del<span class="ff8 fc6 ls34">.<span class="fc0 ls0">parent</span></span></div><div class="t m0 x16 hf y1ff1 ff7 fs5 fca sc0 ls0 ws156">del<span class="ff8 fc6 ls34">.<span class="fc0 ls0">children</span></span></div><div class="t m0 x0 h9 y1ff2 ff1 fs3 fc0 sc0 ls0 wsa0">这种情况下，垃圾回收<span class="_ _6"></span>永远都不会去回收这个对<span class="_ _6"></span>象的，还会导致内存泄露。<span class="_ _6"></span>如果你</div><div class="t m0 x5 h7 y7b7 ff1 fs3 fc0 sc0 ls0 wsa0">试着去运行它会发现，<span class="ff6 wsb75">Data. del<span class="_ _30"> </span></span>消息永远不会出现了<span class="ff4 ls83">,</span>甚至在你强制内存回收时：</div><div class="t m0 x5 hf y1ff3 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls32">a<span class="fc6 ls33">=</span><span class="ls0">Node()</span></span></div><div class="t m0 x5 hf y1ff4 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls34">a<span class="fc6 ls0 ws13a">.<span class="fc0">add_child(Node()</span></span></span></div><div class="t m0 x5 hf y1ff5 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="fca">del <span class="ff8 fc0 ls32">a</span><span class="ffa fcd ws4"># No message (not collected)</span></span></div><div class="t m0 x5 h10 y1ff6 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="fca ws146">import <span class="fcc">gc</span></span></div><div class="t m0 x5 hf y1ff7 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws13a">gc<span class="fc6 ls34">.</span><span class="ws16e">collect() <span class="ffa fcd ws4"># No message (not collected)</span></span></span></div><div class="t m0 x5 hf y1ff8 ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h9 y1ff9 ff1 fs3 fc0 sc0 ls0 wsa0">弱引用消除了引用循<span class="_ _6"></span>环的这个问题，本质来讲，弱<span class="_ _6"></span>引用就是一个对象指针，<span class="_ _6"></span>它不会</div><div class="t m0 x5 h9 y1ffa ff1 fs3 fc0 sc0 ls0 ws14">增加它的引用计数。你可以通过 <span class="ff6 ws23a">weakref </span>来创建弱引用。例如：</div><div class="t m0 x5 h10 y230 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="fca ws146">import <span class="fcc">weakref</span></span></div><div class="t m0 x5 hf y1ffb ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls32">a<span class="fc6 ls33">=</span><span class="ls0">Node()</span></span></div><div class="t m0 x5 hf y1ffc ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws15f">a_ref <span class="fc6 ls33">=</span><span class="ws13a">weakref<span class="fc6 ls34">.</span>ref(a)</span></span></div><div class="t m0 x5 hf y1ffd ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0">a_ref</span></div><div class="t m0 x5 hf y1ffe ff8 fs5 fc8 sc0 ls0 ws4">&lt;weakref at 0x100581f70; to <span class="ff9 ls34">&apos;</span><span class="ws13a">Node<span class="ff9 ls32">&apos;</span></span>at 0x1005c5410&gt;</div><div class="t m0 x5 hf y1fff ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h9 y2000 ff1 fs3 fc0 sc0 ls3a ws153">为了访问弱引用所引用的对象，你可以像函数一样去调用它即可。如果那个对象还</div><div class="t m0 x5 h7 yff4 ff1 fs3 fc0 sc0 ls2b wsb76">存在就会返回它，否则就返回一个 <span class="ff4 ls0 wsa5">None</span><span class="ws12e">。由于原始对象的引用计数没有增加<span class="_ _1"></span>，那么就</span></div><div class="t m0 x5 h7 y2001 ff1 fs3 fc0 sc0 ls0 wsa0">可以去删除它了。例如<span class="ff4">;</span></div><div class="t m0 x5 hf y10aa ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="fca ws156">print<span class="ff8 fc0">(a_ref())</span></span></div><div class="t m0 x5 hf y10ab ff8 fs5 fc8 sc0 ls0 ws4">&lt;__main__.Node object at 0x1005c5410&gt;</div><div class="t m0 x5 hf y10ac ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="fca">del <span class="ff8 fc0">a</span></span></div><div class="t m0 x5 hf y2002 ff8 fs5 fc8 sc0 ls0">Data.__del__</div><div class="t m0 x5 hf y2003 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="fca ws156">print<span class="ff8 fc0">(a_ref())</span></span></div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 wsae0">10.23.<span class="_ _5"> </span>8.23 <span class="ff1 wsb70">循环引用数据结构的内存管理 </span>294</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
