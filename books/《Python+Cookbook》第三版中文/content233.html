<div id="pfe9" class="pf w0 h0" data-page-no="e9"><div class="pc pce9 w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bge9.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 hf y1ab ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws155">handler <span class="fc6 ls32">=</span>make_handler()</span></div><div class="t m0 x5 hf y1ac ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fca ws13a">next<span class="fc0 ws16e">(handler) <span class="ffa fcd ws4"># Advance to the yield</span></span></span></div><div class="t m0 x5 hf y1ad ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws13b">apply_async(add, (<span class="fc7 ls34">2</span><span class="ls32">,<span class="fc7 ls34">3</span></span>), callback<span class="fc6 ls34">=</span><span class="ws13a">handler<span class="fc6">.</span>send)</span></span></div><div class="t m0 x5 hf y1ae ff8 fs5 fc8 sc0 ls0 ws4">[1] Got: 5</div><div class="t m0 x5 hf y1af ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws13b">apply_async(add, (<span class="ff9 fc9 ls34">&apos;</span><span class="fc9 ws13a">hello<span class="ff9 ls34">&apos;</span></span><span class="ls33">,</span><span class="ff9 fc9">&apos;<span class="ff8 ws13a">world</span><span class="ls34">&apos;</span></span>), callback<span class="fc6 ws13a">=<span class="fc0">handler</span><span class="ls34">.</span></span>send)</span></div><div class="t m0 x5 hf y1b0 ff8 fs5 fc8 sc0 ls0 ws4">[2] Got: helloworld</div><div class="t m0 x5 hf y355 ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x5 he y196a ff2 fs2 fc4 sc0 ls0 ws212">9.10.3 <span class="ff1">讨论</span></div><div class="t m0 x0 h9 y196b ff1 fs3 fc0 sc0 ls63 ws21f">基于回调函数的软件通常都有可能变得非常复杂<span class="_ _c"></span>。一部分原因是回调函数通常会<span class="_ _1"></span></div><div class="t m0 x5 h9 y196c ff1 fs3 fc0 sc0 ls18 ws110">跟请求执行代码断开。因此<span class="_ _1"></span>，请求执行和处理结果之间的执行环境实际上已经丢失了。</div><div class="t m0 x5 h9 y196d ff1 fs3 fc0 sc0 ls2d ws132">如果你想让回调函数连续执行多步操作，那你就必须去解决如何保存和恢复相关的状<span class="_ _1"></span></div><div class="t m0 x5 h9 y196e ff1 fs3 fc0 sc0 ls0">态信息了。</div><div class="t m0 x0 h7 y196f ff1 fs3 fc0 sc0 lse ws98c">至少有两种主要方式来捕获和保存状态信息，你可以在一个对象实例 <span class="ff4 ls1b">(</span><span class="wsd8">通过一个绑</span></div><div class="t m0 x5 h7 y1970 ff1 fs3 fc0 sc0 ls0 wsa0">定<span class="_ _6"></span>方<span class="_ _6"></span>法<span class="ff4 ls159">)</span><span class="ls36 ws14a">或者在一个闭包中保存它<span class="_ _1"></span>。两种方式相比<span class="_ _1"></span>，闭包或许是更加轻量级和自然一<span class="_ _1"></span></span></div><div class="t m0 x5 h9 y1971 ff1 fs3 fc0 sc0 ls18 ws110">点，因为它们可以很简单的通过函数来构造<span class="_ _1"></span>。它们还能自动捕获所有被使用到的变量。</div><div class="t m0 x5 h7 y1972 ff1 fs3 fc0 sc0 ls0 ws63">因此，你无需去担心如何去存储额外的状态信息 <span class="ff4 wsa5">(</span><span class="wsa0">代码中自动判定<span class="ff4 wsa5">)</span>。</span></div><div class="t m0 x0 h9 y1973 ff1 fs3 fc0 sc0 ls0 ws98d">如果使用闭包，<span class="_ _8"></span>你需要注意对那些可修改变量的操作。<span class="_ _8"></span>在上面的方案中， <span class="ff6">nonlocal</span></div><div class="t m0 x5 h9 y1974 ff1 fs3 fc0 sc0 ls13 wse5">声明语句用来指示接下来的变量会在回调函数中被修改<span class="_ _1"></span>。如果没有这个声明，代码会<span class="_ _c"></span></div><div class="t m0 x5 h9 y1975 ff1 fs3 fc0 sc0 ls0">报错。</div><div class="t m0 x0 h9 y1976 ff1 fs3 fc0 sc0 ls3a ws153">而使用一个协程来作为一个回调函数就更有趣了，它跟闭包方法密切相关。某种意</div><div class="t m0 x5 h9 y1977 ff1 fs3 fc0 sc0 ls1e ws111">义上来讲<span class="_ _1"></span>，它显得更加简洁，因为总共就一个函数而已<span class="_ _c"></span>。并且，你可以很自由的修改<span class="_ _1"></span></div><div class="t m0 x5 h7 y1978 ff1 fs3 fc0 sc0 ls0 ws98e">变量而无<span class="_ _6"></span>需去使用 <span class="ff6 ws98f">nonlocal </span><span class="ls51 ws990">声明。这种方式唯一缺点就是相对于其他 </span><span class="ff4 ws991">Python </span><span class="wsa0">技术而</span></div><div class="t m0 x5 h9 y1979 ff1 fs3 fc0 sc0 ls3d ws992">已或许比较难以理解。另外还有一些比较难懂的部分，比如使用之前需要调用 <span class="ff6 ls0">next()</span></div><div class="t m0 x5 h9 y197a ff1 fs3 fc0 sc0 ls1e ws111">，实际使用时这个步骤很容易被忘记<span class="_ _1"></span>。尽管如此<span class="_ _1"></span>，协程还有其他用处，比如作为<span class="_ _1"></span>一个</div><div class="t m0 x5 h7 y197b ff1 fs3 fc0 sc0 ls0 ws38">内联回调函数的定义 <span class="ff4 ls1b">(</span><span class="wsa0">下一节会讲到<span class="ff4 wsa5">)</span>。</span></div><div class="t m0 x0 h9 y197c ff1 fs3 fc0 sc0 ls14 ws28b">如果你仅仅只需要给回调函数传递额外的值的话<span class="_ _1"></span>，还有一种使用 <span class="ff6 ls0 ws28c">partial() <span class="ff1 wsa0">的<span class="_ _6"></span>方</span></span></div><div class="t m0 x5 h7 y197d ff1 fs3 fc0 sc0 ls0 ws993">式<span class="_ _6"></span>也<span class="_ _6"></span>很<span class="_ _6"></span>有<span class="_ _0"></span>用。<span class="_ _6"></span>在<span class="_ _6"></span>没<span class="_ _6"></span>有<span class="_ _6"></span>使<span class="_ _0"></span>用 <span class="ff6 ws994">partial() </span><span class="ws995">的时<span class="_ _0"></span>候，<span class="_ _6"></span>你<span class="_ _6"></span>可<span class="_ _6"></span>能<span class="_ _6"></span>经<span class="_ _0"></span>常看<span class="_ _0"></span>到<span class="_ _6"></span>下<span class="_ _6"></span>面<span class="_ _6"></span>这<span class="_ _6"></span>种<span class="_ _0"></span>使用 <span class="ff4 wsa5">lambda</span></span></div><div class="t m0 x5 h9 y197e ff1 fs3 fc0 sc0 ls0">表达式的复杂代码：</div><div class="t m0 x5 hf y197f ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws13b">apply_async(add, (<span class="fc7 ls34">2</span><span class="ls32">,<span class="fc7 ls34">3</span></span>), callback<span class="fc6 ls34">=</span></span><span class="fca ws146">lambda <span class="ff8 fc0 ws13b">r: handler(r, seq))</span></span></div><div class="t m0 x5 hf y1189 ff8 fs5 fc8 sc0 ls0 ws4">[1] Got: 5</div><div class="t m0 x5 hf y118a ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h7 y1980 ff1 fs3 fc0 sc0 ls0 wsfe">可以参考 <span class="ff4 ws996">7.8 </span><span class="ws997">小节的几个示例，教你如何使用 <span class="ff6 ws998">partial() </span>来更改参数签名来简化上</span></div><div class="t m0 x5 h9 y1981 ff1 fs3 fc0 sc0 ls0">述代码。</div><div class="t m0 x5 hd y1982 ff2 fs4 fc4 sc0 ls0 ws211">9.11<span class="_ _e"> </span>7.11 <span class="ff1">内联回调函数</span></div><div class="t m0 x5 he yec1 ff2 fs2 fc4 sc0 ls0 ws212">9.11.1 <span class="ff1">问题</span></div><div class="t m0 x0 h9 y6e ff1 fs3 fc0 sc0 ls3a ws153">当你编写使用回调函数的代码的时候，担心很多小函数的扩张可能会弄乱程序控制</div><div class="t m0 x5 h9 y674 ff1 fs3 fc0 sc0 ls0">流。你希望找到某个方法来让代码看上去更像是一个普通的执行序列。</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 ws21d">9.11.<span class="_ _5"> </span>7.11 <span class="ff1 ws999">内联回调函数 </span>224</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
