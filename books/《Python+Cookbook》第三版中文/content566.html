<div id="pf236" class="pf w0 h0" data-page-no="236"><div class="pc pc236 w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg236.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 h9 y2a ff1 fs3 fc0 sc0 ls13 wse5">作数组的代码<span class="_ _1"></span>，你可以编写很好的兼容这些应用程序的自定义代码，而不是只能兼容<span class="_ _c"></span></div><div class="t m0 x5 h9 y2b ff1 fs3 fc0 sc0 ls0">你自己的代码。</div><div class="t m0 x0 h7 y8dd ff1 fs3 fc0 sc0 lse7 ws13d6">代码的关键点在于 <span class="ff6 ls0 ws5ed">PyBuffer GetBuffer()<span class="_ _34"> </span><span class="ff1 ws13d7">函 数。 给 定 一 个 任 意 的<span class="_ _13"> </span><span class="ff4">Python</span></span></span></div><div class="t m0 x5 h7 y99 ff1 fs3 fc0 sc0 ls25d ws13d8">对象<span class="_ _f"></span>，它会试着去获取底层内存信息<span class="_ _2d"></span>，它简单的抛出一个异常并返回 <span class="ff4 ls0">-1.</span></div><div class="t m0 x5 h9 y9a ff1 fs3 fc0 sc0 ls0 ws13d9">传 给<span class="_ _13"> </span><span class="ff6 ws3a9">PyBuffer GetBuffer()<span class="_ _13"> </span></span>的 特 殊 标 志 给 出 了 所 需 的 内 存 缓 冲 类 型。<span class="_ _45"> </span>例 如，</div><div class="t m0 x5 h9 y9b ff6 fs3 fc0 sc0 ls0 ws17c">PyBUF<span class="_ _7"> </span>ANY<span class="_ _16"> </span>CONTIGUOUS <span class="ff1">表示是一个联系的内存区域。</span></div><div class="t m0 x0 h9 y31 ff1 fs3 fc0 sc0 ls0 ws13da">对于数组、字节字符串和其他类似对象而言，<span class="_ _1"></span>一个 <span class="ff6 ws13db">Py<span class="_ _7"> </span>buffer </span>结构体包含了所有底</div><div class="t m0 x5 h9 y32 ff1 fs3 fc0 sc0 ls18 ws110">层内存的信息。它包含一个指向内存地址、大小<span class="_ _1"></span>、元素大小、格式和其他细节的指针。</div><div class="t m0 x5 h9 y33 ff1 fs3 fc0 sc0 ls0">下面是这个结构体的定义：</div><div class="t m0 x5 hf y36ae ff8 fs5 fc0 sc0 ls0 ws4">typedef struct bufferinfo {</div><div class="t m0 x15 hf y36af ff8 fs5 fc0 sc0 ls0 ws4">void *buf;<span class="_ _46"> </span>/* Pointer to buffer memory */</div><div class="t m0 x15 hf y36b0 ff8 fs5 fc0 sc0 ls0 ws4">PyObject *obj;<span class="_ _3c"> </span>/* Python object that is the owner */</div><div class="t m0 x15 hf y36b1 ff8 fs5 fc0 sc0 ls0 ws4">Py_ssize_t len;<span class="_ _1b"> </span>/* Total size in bytes */</div><div class="t m0 x15 hf y36b2 ff8 fs5 fc0 sc0 ls0 ws4">Py_ssize_t itemsize;<span class="_ _22"> </span>/* Size in bytes of a single item */</div><div class="t m0 x15 hf y36b3 ff8 fs5 fc0 sc0 ls0 ws4">int readonly;<span class="_ _42"> </span>/* Read-only access flag */</div><div class="t m0 x15 hf y36b4 ff8 fs5 fc0 sc0 ls0 ws4">int ndim;<span class="_ _47"> </span>/* Number of dimensions */</div><div class="t m0 x15 hf y3490 ff8 fs5 fc0 sc0 ls0 ws4">char *format;<span class="_ _42"> </span>/* struct code of a single item */</div><div class="t m0 x15 hf y36b5 ff8 fs5 fc0 sc0 ls0 ws4">Py_ssize_t *shape;<span class="_ _44"> </span>/* Array containing dimensions */</div><div class="t m0 x15 hf y36b6 ff8 fs5 fc0 sc0 ls0 ws4">Py_ssize_t *strides;<span class="_ _22"> </span>/* Array containing strides */</div><div class="t m0 x15 hf y148c ff8 fs5 fc0 sc0 ls0 ws4">Py_ssize_t *suboffsets; /* Array containing suboffsets */</div><div class="t m0 x5 hf y148d ff8 fs5 fc0 sc0 ls0 ws4">} Py_buffer;</div><div class="t m0 x0 h9 y36b7 ff1 fs3 fc0 sc0 ls56 ws1fa">本节中<span class="_ _c"></span>，我们只关注接受一个双精度浮点数数组作为参数<span class="_ _1"></span>。要检查元素是否是一<span class="_ _1"></span></div><div class="t m0 x5 h7 y36b8 ff1 fs3 fc0 sc0 ls0 ws13dc">个双精度<span class="_ _6"></span>浮点数，只<span class="_ _6"></span>需验证 <span class="ff6 ws4cc">format </span><span class="wsa0">属性<span class="_ _6"></span>是不是字<span class="_ _6"></span>符串<span class="ff4 ws13dd">”d”<span class="_ _1d"></span>. <span class="ff1 ls51 ws13de">这个也是 </span><span class="ff6 ws4cc">struct <span class="ff1 wsa0">模<span class="_ _6"></span>块用来</span></span></span></span></div><div class="t m0 x5 h9 y36b9 ff1 fs3 fc0 sc0 ls0 wsa0">编码二进制数<span class="_ _6"></span>据的。通常来讲，<span class="ff6 ws61a">format </span><span class="ls35 ws13df">可以是任何兼容 </span><span class="ff6 wsac2">struct </span>模块<span class="_ _6"></span>的格式化字符串，</div><div class="t m0 x5 h7 y36ba ff1 fs3 fc0 sc0 lse ws14b">并且如果数组包含了 <span class="ff4 ls24b">C</span><span class="wsd8">结构的话它可以包含多个值。一旦我们已经确定了<span class="_ _1"></span>底层的缓存</span></div><div class="t m0 x5 h7 y1ad6 ff1 fs3 fc0 sc0 ls1f ws48d">区信息，那只需要简单的将它传给 <span class="ff4 ls25e">C</span><span class="ws13e0">函数，然后会被当做是一个普通的 <span class="ff4 ls25e">C</span><span class="ls0 wsa0">数组了。实</span></span></div><div class="t m0 x5 h9 y36bb ff1 fs3 fc0 sc0 ls13 wse5">际上<span class="_ _1"></span>，我们不必担心是怎样的数组类型或者它是被什么库创建出来的。这也是为什么<span class="_ _c"></span></div><div class="t m0 x5 h9 y36bc ff1 fs3 fc0 sc0 ls0 ws38">这个函数能兼容 <span class="ff6 ws19e">array </span><span class="wsc">模块也能兼容 <span class="ff6 ws19e">numpy </span>模块中的数组了。</span></div><div class="t m0 x0 h9 y36bd ff1 fs3 fc0 sc0 ls56 ws13e1">在返回最终结果之前<span class="_ _c"></span>，底层的缓冲区视图必须使用 <span class="ff6 ls0 ws3a9">PyBuffer Release()<span class="_ _18"> </span><span class="ff1 wsa0">释<span class="_ _6"></span>放<span class="_ _6"></span>掉。</span></span></div><div class="t m0 x5 h9 y36be ff1 fs3 fc0 sc0 ls0">之所以要这一步是为了能正确的管理对象的引用计数。</div><div class="t m0 x0 h9 y36bf ff1 fs3 fc0 sc0 ls3a ws153">同样，本节也仅仅只是演示了接受数组的一个小的代码片段。如果你真的要处理数</div><div class="t m0 x5 h9 y5ec ff1 fs3 fc0 sc0 ls1e ws111">组<span class="_ _1"></span>，你可能会碰到多维数据、大数据<span class="_ _c"></span>、不同的数据类型等等问题，那么就得去学更高<span class="_ _1"></span></div><div class="t m0 x5 h9 y2e1f ff1 fs3 fc0 sc0 ls0">级的东西了。你需要参考官方文档来获取更多详细的细节。</div><div class="t m0 x0 h7 y36c0 ff1 fs3 fc0 sc0 lsc8 ws13e2">如果你需要编写涉及到数组处理的多个扩展<span class="_ _c"></span>，那么通过 <span class="ff4 ls0 ws13e3">Cython </span><span class="wsa6f">来实现会更容易<span class="_ _c"></span></span></div><div class="t m0 x5 h7 y12e ff1 fs3 fc0 sc0 ls0 ws14">下。参考 <span class="ff4 ws2aa">15.11 </span>节。</div><div class="t m0 x5 hd y36c1 ff2 fs4 fc4 sc0 ls0 ws211">17.4<span class="_ _e"> </span>15.4 <span class="ff1 lsac">在</span><span class="ls23d">C</span><span class="ff1">扩展模块中操作隐形指针</span></div><div class="t m0 x5 he y36c2 ff2 fs2 fc4 sc0 ls0 ws212">17.4.1 <span class="ff1">问题</span></div><div class="t m0 x0 h7 y36c3 ff1 fs3 fc0 sc0 ls2d ws13e4">你有一个扩展模块需要处理 <span class="ff4 ls25f">C</span><span class="ws132">结构体中的指针<span class="_ _1"></span>，但是你又不想暴露结构体中任何</span></div><div class="t m0 x5 h7 y36c4 ff1 fs3 fc0 sc0 ls0 ws38">内部细节给 <span class="ff4 wsa5">Python</span>。</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 ws21d">17.4.<span class="_ _36"> </span>15.4 <span class="ff1 ls81">在</span><span class="ls260">C</span><span class="ff1 ws13e5">扩展模块中操作隐形指针 </span>557</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
