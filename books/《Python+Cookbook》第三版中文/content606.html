<div id="pf25e" class="pf w0 h0" data-page-no="25e"><div class="pc pc25e w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg25e.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 h7 y2a ff1 fs3 fc0 sc0 ls0 ws4f4">容转换为一个 <span class="ff4 wse61">Python </span><span class="wsa0">字符串。进一步假设你在后面还想通过一个扩展将那个字符串传</span></div><div class="t m0 x5 h9 y2b ff1 fs3 fc0 sc0 ls4">个<span class="ff6 ls0 ws23a">print<span class="_ _7"> </span>chars() <span class="ff1">函数。下面是一种用来保护原始数据的方法，就算它编码有问题。</span></span></div><div class="t m0 x5 hf y48d ff8 fs5 fc0 sc0 ls0 ws4">/* Return the C string back to Python */</div><div class="t m0 x5 hf y48e ff8 fs5 fc0 sc0 ls0 ws4">static PyObject *py_retstr(PyObject *self, PyObject *args) {</div><div class="t m0 x19 hf y48f ff8 fs5 fc0 sc0 ls0 ws4">if (!PyArg_ParseTuple(args, &quot;&quot;)) {</div><div class="t m0 x15 hf y490 ff8 fs5 fc0 sc0 ls0 ws13b">return NULL;</div><div class="t m0 x19 hf y7ab ff8 fs5 fc0 sc0 ls0">}</div><div class="t m0 x19 hf y1760 ff8 fs5 fc0 sc0 ls0 ws4">return PyUnicode_Decode(sdata, slen, &quot;utf-8&quot;, &quot;surrogateescape&quot;);</div><div class="t m0 x5 hf y1761 ff8 fs5 fc0 sc0 ls0">}</div><div class="t m0 x5 hf y1763 ff8 fs5 fc0 sc0 ls0 ws4">/* Wrapper for the print_chars() function */</div><div class="t m0 x5 hf y1764 ff8 fs5 fc0 sc0 ls0 ws4">static PyObject *py_print_chars(PyObject *self, PyObject *args) {</div><div class="t m0 x19 hf y359 ff8 fs5 fc0 sc0 ls0 ws4">PyObject *obj, *bytes;</div><div class="t m0 x19 hf y1765 ff8 fs5 fc0 sc0 ls0 ws4">char *s = 0;</div><div class="t m0 x19 hf y1766 ff8 fs5 fc0 sc0 ls0 ws1305">Py_ssize_t len;</div><div class="t m0 x19 hf ya5e ff8 fs5 fc0 sc0 ls0 ws4">if (!PyArg_ParseTuple(args, &quot;U&quot;, &amp;obj)) {</div><div class="t m0 x15 hf yb ff8 fs5 fc0 sc0 ls0 ws13b">return NULL;</div><div class="t m0 x19 hf ya5f ff8 fs5 fc0 sc0 ls0">}</div><div class="t m0 x19 hf y3a29 ff8 fs5 fc0 sc0 ls0 ws4">if ((bytes = PyUnicode_AsEncodedString(obj,&quot;utf-8&quot;,&quot;surrogateescape&quot;))</div><div class="t m0 x16 hf y3a2a ff8 fs5 fc0 sc0 ls0 ws13b">== NULL) {</div><div class="t m0 x15 hf y342c ff8 fs5 fc0 sc0 ls0 ws13b">return NULL;</div><div class="t m0 x19 hf y3a2b ff8 fs5 fc0 sc0 ls0">}</div><div class="t m0 x19 hf y3a2c ff8 fs5 fc0 sc0 ls0 ws4">PyBytes_AsStringAndSize(bytes, &amp;s, &amp;len);</div><div class="t m0 x19 hf y3a2d ff8 fs5 fc0 sc0 ls0 ws4">print_chars(s, len);</div><div class="t m0 x19 hf y3a2e ff8 fs5 fc0 sc0 ls0">Py_DECREF(bytes);</div><div class="t m0 x19 hf y3a2f ff8 fs5 fc0 sc0 ls0">Py_RETURN_NONE;</div><div class="t m0 x5 hf y3a30 ff8 fs5 fc0 sc0 ls0">}</div><div class="t m0 x0 h7 y222f ff1 fs3 fc0 sc0 ls0 wsc">如果你在 <span class="ff4 ws5c">Python </span>中尝试这些函数，下面是运行效果：</div><div class="t m0 x5 hf y22d2 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls32">s<span class="fc6 ls33">=</span><span class="ls0">retstr()</span></span></div><div class="t m0 x5 hf y22d3 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0">s</span></div><div class="t m0 x5 hf y22d4 ff9 fs5 fc8 sc0 ls34">&apos;<span class="ff8 ls0 ws13b">Spicy Jalapeño\udcae<span class="ff9">&apos;</span></span></div><div class="t m0 x5 hf y22d5 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0">print_chars(s)</span></div><div class="t m0 x5 hf y3a31 ff8 fs5 fc8 sc0 ls0 ws4">53 70 69 63 79 20 4a 61 6c 61 70 65 c3 b1 6f ae</div><div class="t m0 x5 hf y22d6 ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h7 yf28 ff1 fs3 fc0 sc0 ls18 ws1419">仔细观察结果你会发现，不合格字符串被编码到一个 <span class="ff4 ls0 ws453">Python </span><span class="ws110">字符串中，并且并没<span class="_ _1"></span></span></div><div class="t m0 x5 h7 y3a32 ff1 fs3 fc0 sc0 ls0 ws15bd">有<span class="_ _6"></span>产<span class="_ _6"></span>生<span class="_ _6"></span>错<span class="_ _6"></span>误，<span class="_ _6"></span>并<span class="_ _6"></span>且<span class="_ _6"></span>当<span class="_ _6"></span>它<span class="_ _6"></span>被<span class="_ _6"></span>回<span class="_ _6"></span>传<span class="_ _0"></span>给 <span class="ff4 ls2a7">C</span><span class="lsa5 ws15be">的时候<span class="_ _c"></span>，被转换为和之前原始 <span class="ff4 ls2a7">C</span><span class="ws3b5">字符串一样的字<span class="_ _1"></span></span></span></div><div class="t m0 x5 h9 y3a33 ff1 fs3 fc0 sc0 ls0">节。</div><div class="t m0 x5 he y3a34 ff2 fs2 fc4 sc0 ls0 wsadf">17.16.3 <span class="ff1">讨论</span></div><div class="t m0 x0 h9 y3a35 ff1 fs3 fc0 sc0 ls3a ws153">本节展示了在扩展模块中处理字符串时会配到的一个棘手又很恼火的问题。也就是</div><div class="t m0 x5 h7 y3a36 ff1 fs3 fc0 sc0 ls0 ws15bf">说，<span class="_ _6"></span>在<span class="_ _6"></span>扩<span class="_ _6"></span>展<span class="_ _6"></span>中<span class="_ _0"></span>的 <span class="ff4 ls2a8">C</span><span class="ls36 ws15c0">字符串可能不会严格遵循 </span><span class="ff4 ws15c1">Python </span><span class="ws15c2">所期<span class="_ _0"></span>望的 <span class="ff4 ws15c3">Unico<span class="_ _6"></span>de </span><span class="wsa0">编<span class="_ _6"></span>码<span class="ff4 wsa5">/</span><span class="ls36 ws14a">解码规</span></span></span></div><div class="t m0 x5 h7 y3a37 ff1 fs3 fc0 sc0 ls22 ws15c4">则。因此<span class="_ _c"></span>，很可能一些不合格 <span class="ff4 ls250">C</span><span class="ws15c5">数据传递到 <span class="ff4 ls0 wse67">Python </span><span class="ws119">中去。一个很好的例子就是涉及</span></span></div><div class="t m0 x5 h9 y3a38 ff1 fs3 fc0 sc0 ls13 wse5">到底层系统调用比如文件名这样的字符串<span class="_ _1"></span>。例如，如果一个系统调用返回给解释器一<span class="_ _c"></span></div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 wsd97">17.16.<span class="_ _36"> </span>15.16 <span class="ff1 ws16b">不确定编码格式的 </span><span class="ls246">C</span><span class="ff1 ws15bc">字符串 </span>597</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
