<div id="pf3c" class="pf w0 h0" data-page-no="3c"><div class="pc pc3c w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg3c.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 he y137 ff2 fs2 fc4 sc0 ls0 ws135">4.7.3 <span class="ff1">讨论</span></div><div class="t m0 x0 h7 y675 ff1 fs3 fc0 sc0 lse ws326">这一节展示了在写包含点 <span class="ff4 ls0 ws327">(.) <span class="ff1 wsa0">字符<span class="_ _6"></span>的正<span class="_ _6"></span>则表达<span class="_ _6"></span>式的<span class="_ _6"></span>时候<span class="_ _6"></span>遇到的<span class="_ _6"></span>一些<span class="_ _6"></span>常见<span class="_ _6"></span>问题。在<span class="_ _6"></span>一</span></span></div><div class="t m0 x5 h7 y676 ff1 fs3 fc0 sc0 lse ws14d">个模式字符串中，点 <span class="ff4 ls0 ws328">(.) </span><span class="ws329">匹配除了换行外的任何字符<span class="_ _1"></span>。然而，如果你将点 <span class="ff4 ls0 ws32a">(.) <span class="ff1 wsa0">号放在<span class="_ _6"></span>开</span></span></span></div><div class="t m0 x5 h7 y677 ff1 fs3 fc0 sc0 ls0 ws32b">始<span class="_ _6"></span>与<span class="_ _6"></span>结<span class="_ _6"></span>束<span class="_ _6"></span>符 <span class="ff4 wsa5">(</span><span class="wsa0">比如<span class="_ _6"></span>引<span class="_ _6"></span>号<span class="ff4 ls8a">)</span><span class="ls14 ws174">之间的时候，那么匹配操作会查找符合模式的最长可能匹配<span class="_ _c"></span>。</span></span></div><div class="t m0 x5 h9 y678 ff1 fs3 fc0 sc0 ls2d ws132">这样通常会导致很多中间的被开始与结束符包含的文本被忽略掉，并最终被包含在匹<span class="_ _1"></span></div><div class="t m0 x5 h9 y679 ff1 fs3 fc0 sc0 ls35 ws32c">配结果字符串中返回。通过在 <span class="ff6 ls8b">*</span><span class="ls0 ws32d">或者 <span class="ff6 ls8b">+</span></span><span class="ws32e">这样的操作符后面添加一个 <span class="ff6 ls8c">?</span><span class="ws144">可以强制匹配算</span></span></div><div class="t m0 x5 h9 y67a ff1 fs3 fc0 sc0 ls0">法改成寻找最短的可能匹配。</div><div class="t m0 x5 hd y67b ff2 fs4 fc4 sc0 ls0 ws134">4.8<span class="_ _e"> </span>2.8 <span class="ff1">多行匹配模式</span></div><div class="t m0 x5 he y67c ff2 fs2 fc4 sc0 ls0 ws135">4.8.1 <span class="ff1">问题</span></div><div class="t m0 x0 h9 y67d ff1 fs3 fc0 sc0 ls0">你正在试着使用正则表达式去匹配一大块的文本，而你需要跨越多行去匹配。</div><div class="t m0 x5 he y67e ff2 fs2 fc4 sc0 ls0 ws135">4.8.2 <span class="ff1">解决方案</span></div><div class="t m0 x0 h7 y67f ff1 fs3 fc0 sc0 ls10 ws32f">这个问题很典型的出现在当你用点 <span class="ff4 ls0 ws330">(.) </span><span class="ws331">去匹配任意字符的时候，忘记了点 <span class="ff4 ls0 ws330">(.) <span class="ff1 wsa0">不能</span></span></span></div><div class="t m0 x5 h7 y680 ff1 fs3 fc0 sc0 ls0 ws63">匹配换行符的事实。比如，假设你想试着去匹配 <span class="ff4 ls8">C</span>语言分割的注释：</div><div class="t m0 x5 hf y681 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws155">comment <span class="fc6 ls32">=</span><span class="ws13a">re<span class="fc6">.</span>compile(<span class="fc9 ls34">r<span class="ff9">&apos;</span><span class="ls0">/\*(.*?)\*/<span class="ff9 ws13b">&apos;</span></span></span>)</span></span></div><div class="t m0 x5 hf y682 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws15f">text1 <span class="fc6 ls33">=</span><span class="ff9 fc9 ws13b">&apos;<span class="ff8 ws4">/* this is a comment */</span>&apos;</span></span></div><div class="t m0 x5 hf y683 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws15f">text2 <span class="fc6 ls33">=</span><span class="ff9 fc9 ws13b">&apos;&apos;&apos;<span class="ff8 ws4">/* this is a</span></span></span></div><div class="t m0 x5 hf y684 ff7 fs5 fc5 sc0 ls0 ws139">... <span class="ff8 fc9 ws13b">multiline comment */</span></div><div class="t m0 x5 h10 y685 ff7 fs5 fc5 sc0 ls0 ws139">... <span class="ff9 fc9">&apos;&apos;&apos;</span></div><div class="t m0 x5 hf y686 ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x5 hf y687 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws13a">comment<span class="fc6 ls34">.</span>findall(text1)</span></div><div class="t m0 x5 hf y688 ff8 fs5 fc8 sc0 ls34">[<span class="ff9 ls32">&apos;</span><span class="ls0 ws4">this is a comment </span><span class="ff9">&apos;</span><span class="ls0">]</span></div><div class="t m0 x5 hf y689 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws13a">comment<span class="fc6 ls34">.</span>findall(text2)</span></div><div class="t m0 x5 hf y68a ff8 fs5 fc8 sc0 ls0">[]</div><div class="t m0 x5 hf y68b ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h9 y68c ff1 fs3 fc0 sc0 ls0">为了修正这个问题，你可以修改模式字符串，增加对换行的支持。比如：</div><div class="t m0 x5 hf y56e ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws155">comment <span class="fc6 ls32">=</span><span class="ws13a">re<span class="fc6">.</span>compile(<span class="fc9 ls34">r<span class="ff9">&apos;</span><span class="ls0">/\*((?:.<span class="ffd ws13b">|</span>\n)*?)\*/</span><span class="ff9">&apos;</span></span>)</span></span></div><div class="t m0 x5 hf y68d ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws13a">comment<span class="fc6 ls34">.</span>findall(text2)</span></div><div class="t m0 x5 hf y68e ff8 fs5 fc8 sc0 ls34">[<span class="ff9 ls32">&apos;</span><span class="ls0 ws4">this is a\n multiline comment </span><span class="ff9">&apos;</span><span class="ls0">]</span></div><div class="t m0 x5 hf y68f ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h13 y690 ff1 fs3 fc0 sc0 ls0 ws332">在<span class="_ _6"></span>这<span class="_ _6"></span>个<span class="_ _6"></span>模<span class="_ _6"></span>式<span class="_ _6"></span>中， <span class="ff6 ws303 v0">(?:.</span><span class="ffd ws305">|\<span class="ff6 ws333 v0">n) </span></span><span class="ws334">指<span class="_ _6"></span>定<span class="_ _6"></span>了<span class="_ _6"></span>一<span class="_ _6"></span>个<span class="_ _6"></span>非<span class="_ _6"></span>捕<span class="_ _6"></span>获组 <span class="ff4 ls1b v0">(</span><span class="wsa0">也<span class="_ _6"></span>就<span class="_ _6"></span>是<span class="_ _6"></span>它<span class="_ _6"></span>定<span class="_ _6"></span>义<span class="_ _6"></span>了<span class="_ _6"></span>一<span class="_ _6"></span>个<span class="_ _6"></span>仅<span class="_ _6"></span>仅<span class="_ _6"></span>用<span class="_ _6"></span>来<span class="_ _6"></span>做</span></span></div><div class="t m0 x5 h7 y691 ff1 fs3 fc0 sc0 ls0 wsa0">匹配，而不能通过单独捕获或者编号的组<span class="ff4 ls1b">)</span>。</div><div class="t m0 x5 he y692 ff2 fs2 fc4 sc0 ls0 ws135">4.8.3 <span class="ff1">讨论</span></div><div class="t m0 x0 h9 y693 ff6 fs3 fc0 sc0 ls0 ws335">re.compile() <span class="ff1 lse ws336">函数接受一个标志参数叫 </span><span class="ws337">re.DOTALL <span class="ff1 lse wsd8">，在这里非常有用。它可以让<span class="_ _1"></span></span></span></div><div class="t m0 x5 h7 y694 ff1 fs3 fc0 sc0 ls0 ws14">正则表达式中的点 <span class="ff4 ws338">(.) </span>匹配包括换行符在内的任意字符。比如：</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 ws13e">4.8.<span class="_ _5"> </span>2.8 <span class="ff1 ws325">多行匹配模式 </span>51</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
