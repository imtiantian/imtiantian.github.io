<div id="pf20a" class="pf w0 h0" data-page-no="20a"><div class="pc pc20a w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg20a.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x0 h9 y2a ff1 fs3 fc0 sc0 ls21f ws125e">在计时中要考虑一个底层的时间函数问题<span class="_ _1d"></span>。一般来说<span class="_ _1f"></span>，使用 <span class="ff6 ls0">time.time()</span></div><div class="t m0 x5 h9 y2b ff1 fs3 fc0 sc0 ls220">或<span class="ff6 ls0 ws125f">time.clock() </span><span class="ls221 ws1260">计算的时间精度因操作系统的不同会有所不同<span class="_ _f"></span>。而使用<span class="_ _f"></span></span></div><div class="t m0 x5 h9 y2c ff6 fs3 fc0 sc0 ls0 ws1d1">time.perf<span class="_ _7"> </span>counter() <span class="ff1">函数可以确保使用系统上面最精确的计时器。</span></div><div class="t m0 x0 h9 y99 ff1 fs3 fc0 sc0 ls0 ws1261">上<span class="_ _6"></span>述<span class="_ _6"></span>代<span class="_ _6"></span>码<span class="_ _6"></span>中<span class="_ _6"></span>由 <span class="ff6 ws1a5">Timer </span><span class="ls49 ws1a6">类记录的时间是钟表时间<span class="_ _1"></span>，并包含了所有休眠时间。如果你<span class="_ _c"></span></span></div><div class="t m0 x5 h7 y9a ff1 fs3 fc0 sc0 ls0 ws38">只想计算该进程所花费的 <span class="ff4 wsa8">CPU </span>时间，应该使用 <span class="ff6 ws25d">time.process<span class="_ _7"> </span>time() </span>来代替：</div><div class="t m0 x5 hf y396 ff8 fs5 fc0 sc0 ls32">t<span class="fc6 ls33">=</span><span class="ls0 ws13a">Timer(time<span class="fc6 ls34">.</span>process_time)</span></div><div class="t m0 x5 hf y397 ff7 fs5 fca sc0 ls0 ws15a">with <span class="ff8 fc0">t:</span></div><div class="t m0 x15 hf y23c0 ff8 fs5 fc0 sc0 ls0 ws13a">countdown(<span class="fc7">1000000</span>)</div><div class="t m0 x5 hf y23c1 ff7 fs5 fca sc0 ls0 ws156">print<span class="ff8 fc0 ws13a">(t<span class="fc6 ls34">.</span>elapsed)</span></div><div class="t m0 x0 h9 y23c2 ff6 fs3 fc0 sc0 ls0 ws1262">time.perf<span class="_ _7"> </span>counter() <span class="ff1 ls222">和</span><span class="ws1263">time.process<span class="_ _16"> </span>time() <span class="ff1 wsa0">都会返回小数形式的秒数时间。实</span></span></div><div class="t m0 x5 h9 y23c3 ff1 fs3 fc0 sc0 ls13 wse5">际的时间值没有任何意义<span class="_ _1"></span>，为了得到有意义的结果，你得执行两次函数然后计算它们<span class="_ _c"></span></div><div class="t m0 x5 h9 y23c4 ff1 fs3 fc0 sc0 ls0">的差值。</div><div class="t m0 x0 h7 y32e1 ff1 fs3 fc0 sc0 ls0 ws38">更多关于计时和性能分析的例子请参考 <span class="ff4 ws2aa">14.13 </span>小节。</div><div class="t m0 x5 hd y32e2 ff2 fs4 fc4 sc0 ls0 wsd91">15.14<span class="_ _e"> </span>13.14 <span class="ff1 ws7d2">限制内存和 </span><span class="ws1264">CPU <span class="ff1">的使用量</span></span></div><div class="t m0 x5 he y32e3 ff2 fs2 fc4 sc0 ls0 wsadf">15.14.1 <span class="ff1">问题</span></div><div class="t m0 x0 h7 y32e4 ff1 fs3 fc0 sc0 ls0 wsc">你想对在 <span class="ff4 ws30">Unix </span><span class="ws14">系统上面运行的程序设置内存或 <span class="ff4 wsa8">CPU </span>的使用限制。</span></div><div class="t m0 x5 he y32e5 ff2 fs2 fc4 sc0 ls0 wsadf">15.14.2 <span class="ff1">解决方案</span></div><div class="t m0 x0 h7 y32e6 ff6 fs3 fc0 sc0 ls0 wscd1">resource <span class="ff1 ws1265">模块能同时执行这两个任务。例如，<span class="_ _c"></span>要限制 <span class="ff4 ws1266">CPU </span><span class="wsa0">时间，可以像下面这样</span></span></div><div class="t m0 x5 h9 y32e7 ff1 fs3 fc0 sc0 ls0">做：</div><div class="t m0 x5 h10 y21ac ff7 fs5 fca sc0 ls0 ws146">import <span class="fcc">signal</span></div><div class="t m0 x5 h10 y32e8 ff7 fs5 fca sc0 ls0 ws146">import <span class="fcc">resource</span></div><div class="t m0 x5 h10 y32e9 ff7 fs5 fca sc0 ls0 ws146">import <span class="fcc">os</span></div><div class="t m0 x5 hf y32ea ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">time_exceeded<span class="fc0 ws4">(signo, frame):</span></span></div><div class="t m0 x15 hf y32eb ff7 fs5 fca sc0 ls0 ws156">print<span class="ff8 fc0 ws13a">(<span class="fc9">&quot;Time<span class="ff9 ls34">&apos;</span><span class="ws13b">s up!&quot;</span></span>)</span></div><div class="t m0 x15 hf y32ec ff7 fs5 fca sc0 ls0 ws16a">raise <span class="ff8 ws13a">SystemExit<span class="fc0">(<span class="fc7 ls34">1</span>)</span></span></div><div class="t m0 x5 hf y32ed ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">set_max_runtime<span class="fc0">(seconds):</span></span></div><div class="t m0 x15 h11 y32ee ffa fs5 fcd sc0 ls0 ws4"># Install the signal handler and set a resource limit</div><div class="t m0 x15 hf y32ef ff8 fs5 fc0 sc0 ls0 ws13b">soft, hard <span class="fc6 ls32">=</span><span class="ws13a">resource<span class="fc6 ls34">.</span>getrlimit(resource<span class="fc6 ls34">.</span>RLIMIT_CPU)</span></div><div class="t m0 x15 hf y32f0 ff8 fs5 fc0 sc0 ls0 ws13a">resource<span class="fc6">.</span>setrlimit(resource<span class="fc6">.</span><span class="ws4">RLIMIT_CPU, (seconds, hard))</span></div><div class="t m0 x15 hf y32f1 ff8 fs5 fc0 sc0 ls0 ws13a">signal<span class="fc6 ls34">.</span>signal(signal<span class="fc6 ls34">.</span><span class="ws4">SIGXCPU, time_exceeded)</span></div><div class="t m0 x5 hf y32f2 ff7 fs5 fca sc0 ls0 ws157">if <span class="ff8 fc0 ws16d">__name__ <span class="fc6 ws159">== <span class="ff9 fc9 ls34">&apos;</span><span class="fc9 ws13a">__main__<span class="ff9 ls34">&apos;</span></span></span>:</span></div><div class="t m0 x15 hf y32f3 ff8 fs5 fc0 sc0 ls0 ws13a">set_max_runtime(<span class="fc7">15</span>)</div><div class="t m0 x15 hf y32f4 ff7 fs5 fca sc0 ls0 ws16a">while <span class="ff8 ws13a">True<span class="fc0">:</span></span></div><div class="t m0 x16 h10 y32f5 ff7 fs5 fca sc0 ls0">pass</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 wsd97">15.14.<span class="_ _36"> </span>13.14 <span class="ff1 ws36c">限制内存和 </span><span class="ws1267">CPU <span class="ff1 ws1268">的使用量 </span>513</span></div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
