<div id="pf1b" class="pf w0 h0" data-page-no="1b"><div class="pc pc1b w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg1b.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 he y137 ff2 fs2 fc4 sc0 ls0 ws135">3.7.3 <span class="ff1">讨论</span></div><div class="t m0 x0 h9 y236 ff6 fs3 fc0 sc0 ls0 ws1e8">OrderedDict <span class="ff1 ls35 ws144">内部维护着一个根据键插入顺序排序的双向链表。每次当一个新的元</span></div><div class="t m0 x5 h9 y237 ff1 fs3 fc0 sc0 ls13 wse5">素插入进来的时候<span class="_ _1"></span>，它会被放到链表的尾部。对于一个已经存在的键的重复赋值不会<span class="_ _c"></span></div><div class="t m0 x5 h9 y238 ff1 fs3 fc0 sc0 ls0">改变键的顺序。</div><div class="t m0 x0 h9 y278 ff1 fs3 fc0 sc0 ls0 ws1e9">需<span class="_ _6"></span>要<span class="_ _6"></span>注<span class="_ _6"></span>意<span class="_ _6"></span>的<span class="_ _6"></span>是，<span class="_ _6"></span>一<span class="_ _6"></span>个 <span class="ff6 ws1ea">OrderedDict </span><span class="ls49 ws1a6">的大小是一个普通字典的两倍<span class="_ _1"></span>，因为它内部维<span class="_ _1"></span></span></div><div class="t m0 x5 h9 y279 ff1 fs3 fc0 sc0 ls17 ws1eb">护着另外一个链表。所以如果你要构建一个需要大量 <span class="ff6 ls0 ws1ec">OrderedDict <span class="ff1 wsa0">实例的数<span class="_ _6"></span>据<span class="_ _6"></span>结构<span class="_ _6"></span>的</span></span></div><div class="t m0 x5 h7 y27a ff1 fs3 fc0 sc0 ls0 ws1ed">时候 <span class="ff4 wsa5">(</span>比如读取 <span class="ff4 ws1ee">100,000 </span><span class="ls55">行</span><span class="ff4 ws1ef">CSV </span><span class="ws1f0">数据到一个 <span class="ff6 ws1f1">OrderedDict </span><span class="wsa0">列表中去<span class="ff4 wsa5">)</span>，那么你就得仔细</span></span></div><div class="t m0 x5 h9 y27b ff1 fs3 fc0 sc0 ls0 ws14">权衡一下是否使用 <span class="ff6 ws1e2">OrderedDict </span>带来的好处要大过额外内存消耗的影响。</div><div class="t m0 x5 hd y27c ff2 fs4 fc4 sc0 ls0 ws134">3.8<span class="_ _e"> </span>1.8 <span class="ff1">字典的运算</span></div><div class="t m0 x5 he y27d ff2 fs2 fc4 sc0 ls0 ws135">3.8.1 <span class="ff1">问题</span></div><div class="t m0 x0 h7 y27e ff1 fs3 fc0 sc0 ls0 ws14">怎样在数据字典中执行一些计算操作 <span class="ff4 wsa5">(</span><span class="wsa0">比如求最小值、最大值、排序等等<span class="ff4 wsa5">)</span>？</span></div><div class="t m0 x5 he y27f ff2 fs2 fc4 sc0 ls0 ws135">3.8.2 <span class="ff1">解决方案</span></div><div class="t m0 x0 h9 y280 ff1 fs3 fc0 sc0 ls0">考虑下面的股票名和价格映射字典：</div><div class="t m0 x5 hf y281 ff8 fs5 fc0 sc0 ls0 ws145">prices <span class="fc6 ls33">=</span>{</div><div class="t m0 x15 hf y282 ff9 fs5 fc9 sc0 ls34">&apos;<span class="ff8 ls0 ws13a">ACME</span><span class="ls0 ws13b">&apos;<span class="ff8 fc0 ls33">:<span class="fc7 ls0 ws13a">45.23<span class="fc0">,</span></span></span></span></div><div class="t m0 x15 hf y283 ff9 fs5 fc9 sc0 ls34">&apos;<span class="ff8 ls0 ws13a">AAPL</span><span class="ls0 ws13b">&apos;<span class="ff8 fc0 ls33">:<span class="fc7 ls0 ws13a">612.78<span class="fc0">,</span></span></span></span></div><div class="t m0 x15 hf y284 ff9 fs5 fc9 sc0 ls34">&apos;<span class="ff8 ls0 ws13a">IBM</span>&apos;<span class="ff8 fc0 ls32">:<span class="fc7 ls0 ws13a">205.55<span class="fc0">,</span></span></span></div><div class="t m0 x15 hf y285 ff9 fs5 fc9 sc0 ls34">&apos;<span class="ff8 ls0 ws13a">HPQ</span>&apos;<span class="ff8 fc0 ls32">:<span class="fc7 ls0 ws13a">37.20<span class="fc0">,</span></span></span></div><div class="t m0 x15 hf y286 ff9 fs5 fc9 sc0 ls34">&apos;<span class="ff8 ls0 ws13a">FB</span>&apos;<span class="ff8 fc0 ls32">:<span class="fc7 ls0">10.75</span></span></div><div class="t m0 x5 hf y287 ff8 fs5 fc0 sc0 ls0">}</div><div class="t m0 x0 h9 y288 ff1 fs3 fc0 sc0 ls49 ws1f2">为了对字典值执行计算操作<span class="_ _1"></span>，通常需要使用 <span class="ff6 ls0 ws1a5">zip() </span><span class="ws1a6">函数先将键和值反转过来。比<span class="_ _c"></span></span></div><div class="t m0 x5 h9 y289 ff1 fs3 fc0 sc0 ls0">如，下面是查找最小和最大股票价格和股票值的代码：</div><div class="t m0 x5 hf y28a ff8 fs5 fc0 sc0 ls0 ws16e">min_price <span class="fc6 ls33">=</span><span class="fca ws13a">min</span><span class="ls34">(</span><span class="fca ws13a">zip<span class="fc0">(prices<span class="fc6 ls34">.</span><span class="ws13b">values(), prices<span class="fc6 ls34">.</span>keys()))</span></span></span></div><div class="t m0 x5 h11 y28b ffa fs5 fcd sc0 ls0 ws4"># min_price is (10.75, <span class="ffb ws13b">&apos;</span><span class="ws13a">FB<span class="ffb ls34">&apos;</span>)</span></div><div class="t m0 x5 hf y28c ff8 fs5 fc0 sc0 ls0 ws16e">max_price <span class="fc6 ls33">=</span><span class="fca ws13a">max</span><span class="ls34">(</span><span class="fca ws13a">zip<span class="fc0">(prices<span class="fc6 ls34">.</span><span class="ws13b">values(), prices<span class="fc6 ls34">.</span>keys()))</span></span></span></div><div class="t m0 x5 h11 y28d ffa fs5 fcd sc0 ls0 ws4"># max_price is (612.78, <span class="ffb ls34">&apos;</span><span class="ws13a">AAPL<span class="ffb ls34">&apos;</span>)</span></div><div class="t m0 x0 h9 y28e ff1 fs3 fc0 sc0 ls0 wsc">类似的，可以使用 <span class="ff6 ws19e">zip() </span><span class="ls4">和</span><span class="ff6 ws1f3">sorted() </span>函数来排列字典数据：</div><div class="t m0 x5 hf y28f ff8 fs5 fc0 sc0 ls0 ws147">prices_sorted <span class="fc6 ls33">=</span><span class="fca ws13a">sorted</span><span class="ls34">(</span><span class="fca ws13a">zip<span class="fc0">(prices<span class="fc6 ls34">.</span><span class="ws13b">values(), prices<span class="fc6 ls34">.</span>keys()))</span></span></span></div><div class="t m0 x5 h11 y290 ffa fs5 fcd sc0 ls0 ws4"># prices_sorted is [(10.75, <span class="ffb ls34">&apos;</span><span class="ws13a">FB<span class="ffb ws13b">&apos;</span></span>), (37.2, <span class="ffb ws13b">&apos;</span><span class="ws13a">HPQ<span class="ffb ls34">&apos;</span>),</span></div><div class="t m0 x5 h11 y291 ffa fs5 fcd sc0 ls0 ws1f4">#<span class="_ _14"> </span>(45.23, <span class="ffb ls34">&apos;</span><span class="ws13a">ACME<span class="ffb ls34">&apos;</span><span class="ws13b">), (205.55, <span class="ffb ls34">&apos;</span></span>IBM<span class="ffb ls34">&apos;</span>),</span></div><div class="t m0 x5 h11 y292 ffa fs5 fcd sc0 ls0 ws1f5">#<span class="_ _14"> </span>(612.78, <span class="ffb ls34">&apos;</span><span class="ws13a">AAPL<span class="ffb ws13b">&apos;</span>)]</span></div><div class="t m0 x0 h9 y293 ff1 fs3 fc0 sc0 ls0 ws1f6">执<span class="_ _6"></span>行<span class="_ _6"></span>这<span class="_ _6"></span>些<span class="_ _6"></span>计<span class="_ _6"></span>算<span class="_ _6"></span>的<span class="_ _6"></span>时<span class="_ _6"></span>候，<span class="_ _6"></span>需要<span class="_ _6"></span>注<span class="_ _6"></span>意<span class="_ _6"></span>的<span class="_ _6"></span>是 <span class="ff6 ws177">zip() </span><span class="ls14 ws174">函数创建的是一个只<span class="_ _6"></span>能访问一次的迭<span class="_ _1"></span></span></div><div class="t m0 x5 h9 y294 ff1 fs3 fc0 sc0 ls0">代器。比如，下面的代码就会产生错误：</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 ws13e">3.8.<span class="_ _5"> </span>1.8 <span class="ff1 ws1f7">字典的运算 </span>18</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
