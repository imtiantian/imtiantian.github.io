<div id="pf251" class="pf w0 h0" data-page-no="251"><div class="pc pc251 w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg251.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 h9 y2a ff1 fs3 fc0 sc0 ls0 wsa0">数。<span class="_ _6"></span>它会<span class="_ _6"></span>将<span class="_ _6"></span>创<span class="_ _6"></span>建<span class="_ _6"></span>输<span class="_ _6"></span>出数<span class="_ _6"></span>组<span class="_ _6"></span>的<span class="_ _6"></span>责<span class="_ _6"></span>任<span class="_ _6"></span>给调<span class="_ _6"></span>用<span class="_ _6"></span>者，<span class="_ _6"></span>不<span class="_ _6"></span>需<span class="_ _6"></span>要<span class="_ _6"></span>知道<span class="_ _6"></span>你<span class="_ _6"></span>操<span class="_ _6"></span>作<span class="_ _6"></span>的<span class="_ _6"></span>数组<span class="_ _6"></span>的<span class="_ _6"></span>具<span class="_ _6"></span>体<span class="_ _6"></span>细<span class="_ _6"></span>节（它</div><div class="t m0 x5 h9 y2b ff1 fs3 fc0 sc0 lsfa ws60c">仅仅假设数组已经准备好了<span class="_ _c"></span>，只需要做一些小的检查比如确保数组大小是正确的<span class="_ _c"></span>）<span class="_ _2e"></span>。<span class="_ _c"></span></div><div class="t m0 x5 h7 y2c ff1 fs3 fc0 sc0 ls0 ws1520">在<span class="_ _6"></span>像 <span class="ff4 ws1521">NumPy </span><span class="ws1522">之<span class="_ _6"></span>类<span class="_ _6"></span>的<span class="_ _0"></span>库<span class="_ _6"></span>中，<span class="_ _6"></span>使<span class="_ _6"></span>用 <span class="ff6 ws1523">numpy.zeros() </span><span class="ls1e0">或</span><span class="ff6 ws78c">numpy.zeros like()<span class="_ _18"> </span></span><span class="ls63 ws21f">创建输出数<span class="_ _d"></span></span></span></div><div class="t m0 x5 h9 y2d ff1 fs3 fc0 sc0 lsb5 ws1524">组相对而言比较容易<span class="_ _d"></span>。<span class="_ _6"></span>另外<span class="_ _d"></span>，要创建未初始化数组<span class="_ _c"></span>，你可以使用 <span class="ff6 ls0 ws1525">numpy.empty() <span class="ff1">或</span></span></div><div class="t m0 x5 h7 y2e ff6 fs3 fc0 sc0 ls0 ws25d">numpy.empty<span class="_ _7"> </span>like() <span class="ff4 ls29">.</span><span class="ff1">如果你想覆盖数组内容作为结果的话选择这两个会比较快点。</span></div><div class="t m0 x0 h7 y9b ff1 fs3 fc0 sc0 ls0 ws1526">你你的函数实现中，<span class="_ _c"></span>你只需要简单的通过下标运算和数组查找<span class="_ _1"></span>（比如 <span class="ff4 ws1527">a[i],out[i] </span>等）</div><div class="t m0 x5 h7 y9c ff1 fs3 fc0 sc0 ls0 wsa0">来编写代码操作数组。<span class="ff4 wsba">Cython </span>会负责为你生成高效的代码。</div><div class="t m0 x0 h9 y32 ff6 fs3 fc0 sc0 ls0 ws1528">clip() <span class="ff1 ws1529">定<span class="_ _6"></span>义<span class="_ _0"></span>之<span class="_ _0"></span>前<span class="_ _6"></span>的<span class="_ _0"></span>两<span class="_ _6"></span>个<span class="_ _0"></span>装<span class="_ _6"></span>饰<span class="_ _0"></span>器<span class="_ _6"></span>可<span class="_ _0"></span>以<span class="_ _6"></span>优<span class="_ _0"></span>化<span class="_ _6"></span>下<span class="_ _0"></span>性<span class="_ _6"></span>能。 </span>@cython.boundscheck(False)</div><div class="t m0 x5 h9 y33 ff1 fs3 fc0 sc0 ls0 wsd44">省 去 了 所 有 的 数 组 越 界 检 查， 当 你 知 道 下 标 访 问 不 会 越 界 的 时 候 可 以 使 用 它。</div><div class="t m0 x5 h7 y34 ff6 fs3 fc0 sc0 ls0 ws152a">@cython.wraparound(False) <span class="ff1 ls98 ws152b">消除了相对数组尾部的负数下标的处理（<span class="_ _c"></span>类似 <span class="ff4 ls0">Python</span></span></div><div class="t m0 x5 h7 y35 ff1 fs3 fc0 sc0 ls19a ws152c">列表<span class="_ _c"></span>）<span class="_ _2e"></span>。引入这两个装饰器可以极大的提升性能（<span class="_ _c"></span>测试这个例子的时候大概快了 <span class="ff4 ls0">2.5</span></div><div class="t m0 x5 h9 y36 ff1 fs3 fc0 sc0 ls0 wsa0">倍）<span class="_ _f"></span>。</div><div class="t m0 x0 h9 y9f ff1 fs3 fc0 sc0 ls0 wsa0">任何时候处理数组时，<span class="_ _6"></span>研究并改善底层算法同样<span class="_ _6"></span>可以极大的提示性能。例<span class="_ _6"></span>如，考虑</div><div class="t m0 x5 h9 ya0 ff1 fs3 fc0 sc0 ls4">对<span class="ff6 ls0 ws25d">clip() <span class="ff1">函数的如下修正，使用条件表达式：</span></span></div><div class="t m0 x5 hf y3900 ff8 fs5 fc0 sc0 ls0">@cython.boundscheck(False)</div><div class="t m0 x5 hf y3901 ff8 fs5 fc0 sc0 ls0">@cython.wraparound(False)</div><div class="t m0 x5 hf y3902 ff8 fs5 fc0 sc0 ls0 ws4">cpdef clip(double[:] a, double min, double max, double[:] out):</div><div class="t m0 x15 hf y3903 ff8 fs5 fc0 sc0 ls0 ws4">if min &gt; max:</div><div class="t m0 x16 hf y3904 ff8 fs5 fc0 sc0 ls0 ws4">raise ValueError(&quot;min must be &lt;= max&quot;)</div><div class="t m0 x15 hf y3905 ff8 fs5 fc0 sc0 ls0 ws4">if a.shape[0] != out.shape[0]:</div><div class="t m0 x16 hf y3906 ff8 fs5 fc0 sc0 ls0 ws4">raise ValueError(&quot;input and output arrays must be the same size&quot;)</div><div class="t m0 x15 hf y3907 ff8 fs5 fc0 sc0 ls0 ws4">for i in range(a.shape[0]):</div><div class="t m0 x16 hf y3908 ff8 fs5 fc0 sc0 ls0 ws4">out[i] = (a[i] if a[i] &lt; max else max) if a[i] &gt; min else min</div><div class="t m0 x0 h7 y3909 ff1 fs3 fc0 sc0 ls22 ws152d">实际测试结果是<span class="_ _1"></span>，这个版本的代码运行速度要快 <span class="ff4 ls0 ws152e">50% <span class="ff1 wsa0">以<span class="_ _6"></span>上（</span><span class="ws99b">2.44 <span class="ff1 wsa0">秒<span class="_ _6"></span>对比<span class="_ _6"></span>之<span class="_ _6"></span>前使<span class="_ _6"></span>用</span></span></span></div><div class="t m0 x5 h7 y390a ff6 fs3 fc0 sc0 ls0 ws1f3">timeit() <span class="ff1 ws63">测试的 <span class="ff4 ws1d0">3.76 </span><span class="wsa0">秒）<span class="_ _f"></span>。</span></span></div><div class="t m0 x0 h7 y390b ff1 fs3 fc0 sc0 ls0 ws152f">到这<span class="_ _6"></span>里<span class="_ _6"></span>为<span class="_ _6"></span>止，你<span class="_ _6"></span>可<span class="_ _6"></span>能<span class="_ _6"></span>想知<span class="_ _6"></span>道<span class="_ _6"></span>这种<span class="_ _6"></span>代<span class="_ _6"></span>码<span class="_ _6"></span>怎么<span class="_ _6"></span>能<span class="_ _6"></span>跟<span class="_ _6"></span>手写 <span class="ff4 ls249">C</span><span class="wse6">语<span class="_ _6"></span>言 <span class="ff4 ws1530">PK </span><span class="wsa0">呢？<span class="_ _6"></span>例如，<span class="_ _6"></span>你<span class="_ _6"></span>可<span class="_ _6"></span>能</span></span></div><div class="t m0 x5 h7 y390c ff1 fs3 fc0 sc0 ls0 ws38">写了如下的 <span class="ff4 ls8">C</span>函数并使用前面几节的技术来手写扩展：</div><div class="t m0 x5 hf y390d ff8 fs5 fc0 sc0 ls0 ws4">void clip(double *a, int n, double min, double max, double *out) {</div><div class="t m0 x19 hf y390e ff8 fs5 fc0 sc0 ls0 ws4">double x;</div><div class="t m0 x19 hf y390f ff8 fs5 fc0 sc0 ls0 ws4">for (; n &gt;= 0; n--, a++, out++) {</div><div class="t m0 x15 hf y3910 ff8 fs5 fc0 sc0 ls0 ws13b">x = *a;</div><div class="t m0 x15 hf y3911 ff8 fs5 fc0 sc0 ls0 ws4">*out = x &gt; max ? max : (x &lt; min ? min : x);</div><div class="t m0 x19 hf y3912 ff8 fs5 fc0 sc0 ls0">}</div><div class="t m0 x5 hf y3913 ff8 fs5 fc0 sc0 ls0">}</div><div class="t m0 x0 h7 y3914 ff1 fs3 fc0 sc0 ls0 ws1531">我<span class="_ _6"></span>们没<span class="_ _6"></span>有<span class="_ _6"></span>展<span class="_ _6"></span>示<span class="_ _6"></span>这个<span class="_ _6"></span>的<span class="_ _6"></span>扩<span class="_ _6"></span>展代<span class="_ _6"></span>码，<span class="_ _6"></span>但<span class="_ _6"></span>是<span class="_ _6"></span>试<span class="_ _6"></span>验之<span class="_ _6"></span>后，<span class="_ _6"></span>我<span class="_ _6"></span>们<span class="_ _6"></span>发现<span class="_ _6"></span>一<span class="_ _6"></span>个<span class="_ _6"></span>手<span class="_ _6"></span>写 <span class="ff4 ls263">C</span><span class="wsa0">扩展<span class="_ _6"></span>要<span class="_ _6"></span>比<span class="_ _6"></span>使</span></div><div class="t m0 x5 h7 y3915 ff1 fs3 fc0 sc0 ls4">用<span class="ff4 ls0 wsba">Cython </span><span class="ls0 ws63">版本的慢了大概 <span class="ff4 wsa5">10%</span>。最底下的一行比你想象的运行的快很多。</span></div><div class="t m0 x0 h7 y3916 ff1 fs3 fc0 sc0 ls1f ws1532">你可以对实例代码构建多个扩展。对于某些数组操作，最好要释放 <span class="ff4 ls0 wsa5">GIL<span class="ff1 wsa0">，这样多个</span></span></div><div class="t m0 x5 h9 y3917 ff1 fs3 fc0 sc0 ls0 ws14">线程能并行运行。要这样做的话，需要修改代码，使用 <span class="ff6 ws1533">with<span class="_ _11"> </span>nogil: </span>语句：</div><div class="t m0 x5 hf y3918 ff8 fs5 fc0 sc0 ls0">@cython.boundscheck(False)</div><div class="t m0 x5 hf y3919 ff8 fs5 fc0 sc0 ls0">@cython.wraparound(False)</div><div class="t m0 x5 hf y391a ff8 fs5 fc0 sc0 ls0 ws4">cpdef clip(double[:] a, double min, double max, double[:] out):</div><div class="t m0 x15 hf y391b ff8 fs5 fc0 sc0 ls0 ws4">if min &gt; max:</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 wsd97">17.11.<span class="_ _36"> </span>15.11 <span class="ff1 ls7f">用</span><span class="ws747">Cython <span class="ff1 ws150a">写高性能的数组操作 </span>584</span></div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
