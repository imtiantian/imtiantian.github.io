<div id="pf1d1" class="pf w0 h0" data-page-no="1d1"><div class="pc pc1d1 w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg1d1.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 hd y112 ff2 fs4 fc4 sc0 ls0 ws211">14.5<span class="_ _e"> </span>12.5 <span class="ff1">防止死锁的加锁机制</span></div><div class="t m0 x5 he y113 ff2 fs2 fc4 sc0 ls0 ws212">14.5.1 <span class="ff1">问题</span></div><div class="t m0 x0 h9 y658 ff1 fs3 fc0 sc0 ls56 ws1fa">你正在写一个多线程程序<span class="_ _c"></span>，其中线程需要一次获取多个锁<span class="_ _1"></span>，此时如何避免死锁问<span class="_ _1"></span></div><div class="t m0 x5 h9 y659 ff1 fs3 fc0 sc0 ls0">题。</div><div class="t m0 x5 he y18fe ff2 fs2 fc4 sc0 ls0 ws212">14.5.2 <span class="ff1">解决方案</span></div><div class="t m0 x0 h9 y18bb ff1 fs3 fc0 sc0 ls3a ws153">在多线程程序中，死锁问题很大一部分是由于线程同时获取多个锁造成的。举个例</div><div class="t m0 x5 h9 y18bc ff1 fs3 fc0 sc0 ls1e ws111">子<span class="_ _1"></span>：一个线程获取了第一个锁，然后<span class="_ _1"></span>在获取第二个锁的时候发生阻塞，那么这个<span class="_ _1"></span>线程</div><div class="t m0 x5 h9 y18bd ff1 fs3 fc0 sc0 ls13 wse5">就可能阻塞其他线程的执行<span class="_ _1"></span>，从而导致整个程序假死。解决死锁问题的一种方案是为<span class="_ _c"></span></div><div class="t m0 x5 h7 y2ea3 ff1 fs3 fc0 sc0 ls6b ws10b6">程序中的每一个锁分配一个唯一的 <span class="ff4 ls0 wsa5">id</span><span class="ws28f">，然后只允许按照升序规则来使用多个锁，这个</span></div><div class="t m0 x5 h9 y2ea4 ff1 fs3 fc0 sc0 ls0">规则使用上下文管理器是非常容易实现的，示例如下：</div><div class="t m0 x5 h10 y2a41 ff7 fs5 fca sc0 ls0 ws146">import <span class="fcc">threading</span></div><div class="t m0 x5 hf y2ea5 ff7 fs5 fca sc0 ls0 ws15a">from <span class="fcc wscaf">contextlib </span><span class="ws146">import <span class="ff8 fc0">contextmanager</span></span></div><div class="t m0 x5 h11 y2ea6 ffa fs5 fcd sc0 ls0 ws4"># Thread-local state to stored information on locks already acquired</div><div class="t m0 x5 hf y2ea7 ff8 fs5 fc0 sc0 ls0 ws145">_local <span class="fc6 ls33">=</span><span class="ws13a">threading<span class="fc6 ls34">.</span>local()</span></div><div class="t m0 x5 h10 y2b04 ff7 fs5 fc12 sc0 ls0">@contextmanager</div><div class="t m0 x5 hf y2b05 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">acquire<span class="fc0 ls34">(</span><span class="fc6">*<span class="fc0">locks):</span></span></span></div><div class="t m0 x15 h11 y2ea8 ffa fs5 fcd sc0 ls0 ws4"># Sort locks by object identifier</div><div class="t m0 x15 hf y2b06 ff8 fs5 fc0 sc0 ls0 ws15f">locks <span class="fc6 ls33">=</span><span class="fca ws13a">sorted</span><span class="ws4">(locks, key<span class="fc6 ls34">=</span><span class="ff7 fca ws146">lambda </span><span class="ws159">x: <span class="fca ws13a">id</span>(x))</span></span></div><div class="t m0 x15 h11 y2b07 ffa fs5 fcd sc0 ls0 ws4"># Make sure lock order of previously acquired locks is not violated</div><div class="t m0 x15 hf y2ea9 ff8 fs5 fc0 sc0 ls0 ws1f5">acquired <span class="fc6 ls33">=</span><span class="fca ws13a">getattr<span class="fc0">(_local,<span class="ff9 fc9 ls34">&apos;</span><span class="fc9">acquired<span class="ff9 ls34">&apos;</span></span>,[])</span></span></div><div class="t m0 x15 hf y2b08 ff7 fs5 fca sc0 ls0 ws157">if <span class="ff8 fc0 ws16d">acquired </span><span class="ws139">and <span class="ff8 ws13a">max<span class="fc0">(</span>id<span class="fc0 ws145">(lock) </span></span>for <span class="ff8 fc0 ws13c">lock </span></span>in <span class="ff8 fc0 ws16e">acquired) <span class="fc6 ws23d">&gt;= <span class="fca ws13a">id<span class="fc0">(locks[<span class="fc7">0</span>]):</span></span></span></span></div><div class="t m0 x16 hf y2eaa ff7 fs5 fca sc0 ls0 ws16a">raise <span class="ff8 ws13a">RuntimeError<span class="fc0 ls34">(</span><span class="ff9 fc9 ws13b">&apos;<span class="ff8 ws4">Lock Order Violation</span><span class="ls34">&apos;</span></span><span class="fc0">)</span></span></div><div class="t m0 x15 h11 y2eab ffa fs5 fcd sc0 ls0 ws4"># Acquire all of the locks</div><div class="t m0 x15 hf y2eac ff8 fs5 fc0 sc0 ls0 ws13a">acquired<span class="fc6">.</span>extend(locks)</div><div class="t m0 x15 hf y2ead ff8 fs5 fc0 sc0 ls0 ws13a">_local<span class="fc6 ls34">.</span><span class="ws16d">acquired <span class="fc6 ls32">=</span>acquired</span></div><div class="t m0 x15 hf y2eae ff7 fs5 fca sc0 ls0 ws156">try<span class="ff8 fc0">:</span></div><div class="t m0 x16 hf y2eaf ff7 fs5 fca sc0 ls0 ws139">for <span class="ff8 fc0 ws161">lock </span><span class="ws160">in <span class="ff8 fc0">locks:</span></span></div><div class="t m0 x17 hf y2eb0 ff8 fs5 fc0 sc0 ls0 ws13a">lock<span class="fc6">.</span>acquire()</div><div class="t m0 x16 h10 y2eb1 ff7 fs5 fca sc0 ls0">yield</div><div class="t m0 x15 hf y2594 ff7 fs5 fca sc0 ls0 ws156">finally<span class="ff8 fc0">:</span></div><div class="t m0 x16 h11 y2eb2 ffa fs5 fcd sc0 ls0 ws4"># Release locks in reverse order of acquisition</div><div class="t m0 x16 hf y2eb3 ff7 fs5 fca sc0 ls0 ws139">for <span class="ff8 fc0 ws161">lock </span><span class="ws160">in <span class="ff8 ws13a">reversed<span class="fc0">(locks):</span></span></span></div><div class="t m0 x17 hf ya81 ff8 fs5 fc0 sc0 ls0 ws13a">lock<span class="fc6">.</span>release()</div><div class="t m0 x16 hf y2eb4 ff7 fs5 fca sc0 ls0 ws139">del <span class="ff8 fc0 ws13a">acquired[<span class="fc6 ls34">-</span><span class="fca">len</span>(locks):]</span></div><div class="t m0 x0 h9 y117a ff1 fs3 fc0 sc0 ls3a ws153">如何使用这个上下文管理器呢？你可以按照正常途径创建一个锁对象，但不论是单</div><div class="t m0 x5 h9 y2eb5 ff1 fs3 fc0 sc0 ls0 ws38">个锁还是多个锁中都使用 <span class="ff6 ws1d1">acquire() </span>函数来申请锁，示例如下：</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 ws21d">14.5.<span class="_ _36"> </span>12.5 <span class="ff1 ws544">防止死锁的加锁机制 </span>456</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
