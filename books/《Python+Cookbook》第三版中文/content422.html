<div id="pf1a6" class="pf w0 h0" data-page-no="1a6"><div class="pc pc1a6 w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg1a6.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 hf y432 ff7 fs5 fca sc0 ls0 ws16a">class <span class="fcc ws156">WSGIApplication<span class="ff8 fc0">:</span></span></div><div class="t m0 x15 hf y433 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">__init__<span class="fc0">(<span class="fca">self</span>):</span></span></div><div class="t m0 x16 hf y434 ff8 fs5 fc6 sc0 ls0 ws13a">...</div><div class="t m0 x15 hf yde6 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">__call__<span class="fc0">(<span class="fca">self</span><span class="ws4">, environ, start_response)</span></span></span></div><div class="t m0 x2c hf y1d08 ff8 fs5 fc6 sc0 ls34 ws76a">...</div><div class="t m0 x0 h9 y2af7 ff1 fs3 fc0 sc0 ls2c wsf33">我们已经在上面使用这种技术创建 <span class="ff6 ls0 wsf34">PathDispatcher </span><span class="ws12f">类。这个分发器仅仅只是管理<span class="_ _1"></span></span></div><div class="t m0 x5 h7 y2af8 ff1 fs3 fc0 sc0 ls0 wsf35">一<span class="_ _6"></span>个字<span class="_ _6"></span>典，<span class="_ _6"></span>将 <span class="ff4 ls1b">(</span><span class="wsa0">方<span class="_ _6"></span>法<span class="ff4 ls1e3">,</span>路<span class="_ _6"></span>径<span class="ff4 ls1e4">)</span><span class="ls13 wse5">对映射到处理器函数上面<span class="_ _1"></span>。当一个请求到来时，它的方法<span class="_ _c"></span></span></span></div><div class="t m0 x5 h9 y2af9 ff1 fs3 fc0 sc0 ls1e ws111">和路径被提取出来<span class="_ _1"></span>，然后被分发到对应的处理器上面去<span class="_ _1"></span>。另外，任何查询变量会<span class="_ _1"></span>被解</div><div class="t m0 x5 h9 y2afa ff1 fs3 fc0 sc0 ls42 wsf36">析后放到一个字典中，以 <span class="ff6 ls0 wsc02">environ[&apos;params&apos;] </span><span class="ws186">形式存储<span class="_ _1"></span>。后面这个步骤太常见，所以<span class="_ _1"></span></span></div><div class="t m0 x5 h9 y1ef ff1 fs3 fc0 sc0 ls0 wsa0">建<span class="_ _6"></span>议你<span class="_ _6"></span>在<span class="_ _6"></span>分<span class="_ _6"></span>发<span class="_ _6"></span>器<span class="_ _6"></span>里面<span class="_ _6"></span>完<span class="_ _6"></span>成，<span class="_ _6"></span>这<span class="_ _6"></span>样<span class="_ _6"></span>可以<span class="_ _6"></span>省<span class="_ _6"></span>掉<span class="_ _6"></span>很<span class="_ _6"></span>多<span class="_ _6"></span>重复<span class="_ _6"></span>代<span class="_ _6"></span>码。<span class="_ _6"></span>使<span class="_ _6"></span>用<span class="_ _6"></span>分<span class="_ _6"></span>发器<span class="_ _6"></span>的<span class="_ _6"></span>时<span class="_ _6"></span>候，<span class="_ _6"></span>你<span class="_ _6"></span>只需</div><div class="t m0 x5 h7 y2afb ff1 fs3 fc0 sc0 ls42 wsf37">简单的创建一个实例，然后通过它注册各种 <span class="ff4 ls0 wsf38">WSGI </span><span class="ws186">形式的函数<span class="_ _c"></span>。编写这些函数应该超</span></div><div class="t m0 x5 h9 y2afc ff1 fs3 fc0 sc0 ls0 wsc1a">级简单了，只要你遵循 <span class="ff6 ws17c">start<span class="_ _7"> </span>response() </span><span class="wsa0">函数的编写规则，并且最后返回字节字符串</span></div><div class="t m0 x5 h9 y2afd ff1 fs3 fc0 sc0 ls0">即可。</div><div class="t m0 x0 h9 y2afe ff1 fs3 fc0 sc0 ls3a ws153">当编写这种函数的时候还需注意的一点就是对于字符串模板的使用。没人愿意写那</div><div class="t m0 x5 h7 y2aff ff1 fs3 fc0 sc0 ls0 wsf39">种到处混合着 <span class="ff6 wsf3a">print() </span><span class="wsa0">函数、<span class="ff4 wsf3b">XML </span>和大量格式化操作的代码。<span class="_ _1"></span>我们上面使用了三引号</span></div><div class="t m0 x5 h9 y2b00 ff1 fs3 fc0 sc0 ls2d ws132">包含的预先定义好的字符串模板。这种方式的可以让我们很容易的在以后修改输出格<span class="_ _1"></span></div><div class="t m0 x5 h7 y2b01 ff1 fs3 fc0 sc0 ls4">式<span class="ff4 ls1b">(</span><span class="ls0 wsa0">只需要修改模板本身，而不用动任何使用它的地方<span class="ff4 ls1b">)</span>。</span></div><div class="t m0 x0 h7 y2b02 ff1 fs3 fc0 sc0 ls0 wsf3c">最后，<span class="_ _6"></span>使用 <span class="ff4 wsf3d">WSGI </span><span class="ls17 wsf3e">还有一个很重要的部分就是没有什么地方是针对特定 </span><span class="ff4 wsf3f">w<span class="_ _1"></span>eb <span class="ff1 wsa0">服务</span></span></div><div class="t m0 x5 h9 y2b03 ff1 fs3 fc0 sc0 ls13 wse5">器的<span class="_ _1"></span>。因为标准对于服务器和框架是中立的，你可以将你的程序放入任何类型服务器<span class="_ _c"></span></div><div class="t m0 x5 h9 y31a ff1 fs3 fc0 sc0 ls0">中。我们使用下面的代码测试测试本节代码：</div><div class="t m0 x5 hf y2b04 ff7 fs5 fca sc0 ls0 ws157">if <span class="ff8 fc0 ws16d">__name__ <span class="fc6 ws159">== <span class="ff9 fc9 ls34">&apos;</span><span class="fc9 ws13a">__main__<span class="ff9 ls34">&apos;</span></span></span>:</span></div><div class="t m0 x15 hf y2b05 ff7 fs5 fca sc0 ls0 ws15a">from <span class="fcc ws7d9">wsgiref.simple_server </span><span class="ws146">import <span class="ff8 fc0">make_server</span></span></div><div class="t m0 x15 h11 y2b06 ffa fs5 fcd sc0 ls0 ws4"># Create the dispatcher and register functions</div><div class="t m0 x15 hf y1185 ff8 fs5 fc0 sc0 ls0 ws2a3">dispatcher <span class="fc6 ls32">=</span>PathDispatcher()</div><div class="t m0 x15 h10 y2b07 ff7 fs5 fca sc0 ls0">pass</div><div class="t m0 x15 h11 y2b08 ffa fs5 fcd sc0 ls0 ws4"># Launch a basic server</div><div class="t m0 x15 hf y2b09 ff8 fs5 fc0 sc0 ls0 ws15f">httpd <span class="fc6 ls33">=</span><span class="ws13a">make_server(<span class="ff9 fc9 ls34">&apos;&apos;</span><span class="ls32">,</span><span class="fc7">8080</span><span class="ws4">, dispatcher)</span></span></div><div class="t m0 x15 hf y3c5 ff7 fs5 fca sc0 ls0 ws156">print<span class="ff8 fc0 ws13a">(<span class="ff9 fc9 ls34">&apos;</span><span class="fc9 ws4">Serving on port 8080...<span class="ff9 ws13b">&apos;</span></span>)</span></div><div class="t m0 x15 hf y2b0a ff8 fs5 fc0 sc0 ls0 ws13a">httpd<span class="fc6">.</span>serve_forever()</div><div class="t m0 x0 h9 y2b0b ff1 fs3 fc0 sc0 ls3a ws153">上面代码创建了一个简单的服务器，然后你就可以来测试下你的实现是否能正常工</div><div class="t m0 x5 h9 y2b0c ff1 fs3 fc0 sc0 ls1e ws111">作<span class="_ _1"></span>。最后，当你准备进一步扩展你的程序的时候<span class="_ _c"></span>，你可以修改这个<span class="_ _6"></span>代码<span class="_ _1"></span>，让它可以为</div><div class="t m0 x5 h9 y2b0d ff1 fs3 fc0 sc0 ls0">特定服务器工作。</div><div class="t m0 x0 h7 y2b0e ff4 fs3 fc0 sc0 ls0 wsf40">WSGI <span class="ff1 ls1e5 wsf41">本身是一个很小的标准<span class="_ _8"></span>。因此它并没有提供一些高级的特性比如认证<span class="_ _8"></span>、<span class="_ _8"></span></span></div><div class="t m0 x5 h7 y2b0f ff4 fs3 fc0 sc0 ls0 wsa5">co<span class="_ _6"></span>okies<span class="ff1 ls1e ws111">、重定向等<span class="_ _1"></span>。这些你自己实现起来也不难。不过如果你想要更多的支持<span class="_ _c"></span>，可以</span></div><div class="t m0 x5 h9 y2b10 ff1 fs3 fc0 sc0 ls0 ws38">考虑第三方库，比如 <span class="ff6 ws19e">WebOb </span><span class="wsc">或者 <span class="ff6">Paste</span></span></div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 ws21d">13.5.<span class="_ _5"> </span>11.5 <span class="ff1 ws36c">创建一个简单的 </span><span class="wsf07">REST <span class="ff1 wsf08">接口 </span>413</span></div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
