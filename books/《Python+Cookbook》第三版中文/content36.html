<div id="pf24" class="pf w0 h0" data-page-no="24"><div class="pc pc24 w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg24.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 h9 y2a ff1 fs3 fc0 sc0 ls68 ws256">值。如果你传入多个索引参数给 <span class="ff6 ls0 ws257">itemgetter() </span><span class="ws258">，它生成的 <span class="ff6 ls0 ws259">callable </span><span class="ws23f">对象会返回一个</span></span></div><div class="t m0 x5 h9 y2b ff1 fs3 fc0 sc0 ls0 ws25a">包含所有元素值的元组，并且 <span class="ff6 ws25b">sorted() </span><span class="wsa0">函数会根据这个元组中元素顺序去排序。但你</span></div><div class="t m0 x5 h7 y2c ff1 fs3 fc0 sc0 ls18 ws25c">想要同时在几个字段上面进行排序 <span class="ff4 ls1b">(</span><span class="ws110">比如通过姓和名来排序，也就是例子中的那样<span class="ff4 ls69">)</span><span class="ls0">的</span></span></div><div class="t m0 x5 h9 y2d ff1 fs3 fc0 sc0 ls0">时候这种方法是很有用的。</div><div class="t m0 x0 h9 y9a ff6 fs3 fc0 sc0 ls0 ws1dc">itemgetter() <span class="ff1 ws38">有时候也可以用 </span><span class="ws25d">lambda <span class="ff1">表达式代替，比如：</span></span></div><div class="t m0 x5 hf y396 ff8 fs5 fc0 sc0 ls0 ws147">rows_by_fname <span class="fc6 ls33">=</span><span class="fca ws13a">sorted</span><span class="ws4">(rows, key<span class="fc6 ls34">=</span><span class="ff7 fca ws146">lambda </span>r: r[<span class="ff9 fc9 ws13b">&apos;<span class="ff8 ws13a">fname</span><span class="ls34">&apos;</span></span>])</span></div><div class="t m0 x5 hf y397 ff8 fs5 fc0 sc0 ls0 ws169">rows_by_lfname <span class="fc6 ls32">=</span><span class="fca ws13a">sorted</span><span class="ws13b">(rows, key<span class="fc6 ls34">=</span><span class="ff7 fca ws146">lambda </span>r: (r[<span class="ff9 fc9 ls34">&apos;</span><span class="fc9 ws13a">lname<span class="ff9 ws13b">&apos;</span><span class="fc0">],r[</span><span class="ff9 ls34">&apos;</span>fname<span class="ff9 ws13b">&apos;</span></span>]))</span></div><div class="t m0 x0 h9 y398 ff1 fs3 fc0 sc0 ls0 ws25e">这种方<span class="_ _6"></span>案也不<span class="_ _6"></span>错。但是，<span class="_ _6"></span>使用 <span class="ff6 ws25f">itemgetter() </span><span class="wsa0">方<span class="_ _6"></span>式会运<span class="_ _6"></span>行的稍<span class="_ _6"></span>微快点。<span class="_ _6"></span>因此，如<span class="_ _6"></span>果</span></div><div class="t m0 x5 h9 y399 ff1 fs3 fc0 sc0 ls0 ws14">你对性能要求比较高的话就使用 <span class="ff6 ws1dc">itemgetter() </span>方式。</div><div class="t m0 x0 h9 y39a ff1 fs3 fc0 sc0 ls0 ws38">最后，不要忘了这节中展示的技术也同样适用于 <span class="ff6 ws17d">min() </span><span class="ls5">和</span><span class="ff6 ws17d">max() </span>等函数。比如：</div><div class="t m0 x5 hf y39b ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fca ws13a">min<span class="fc0 ws4">(rows, key<span class="fc6 ls34">=</span><span class="ws13a">itemgetter(<span class="ff9 fc9 ls34">&apos;</span><span class="fc9">uid<span class="ff9 ls34">&apos;</span></span>))</span></span></span></div><div class="t m0 x5 hf y39c ff8 fs5 fc8 sc0 ls34">{<span class="ff9 ls0 ws13b">&apos;</span><span class="ls0 ws13a">fname</span><span class="ff9">&apos;</span><span class="ls32">:</span><span class="ff9">&apos;</span><span class="ls0 ws13a">John</span><span class="ff9">&apos;</span><span class="ls32">,</span><span class="ff9">&apos;</span><span class="ls0 ws13a">lname</span><span class="ff9">&apos;</span><span class="ls33">:<span class="ff9 ls0 ws13b">&apos;</span><span class="ls0 ws13a">Cleese<span class="ff9 ws13b">&apos;</span></span>,</span><span class="ff9">&apos;</span><span class="ls0 ws13a">uid</span><span class="ff9">&apos;</span><span class="ls0 ws13b">: 1001}</span></div><div class="t m0 x5 hf y39d ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fca ws13a">max<span class="fc0 ws4">(rows, key<span class="fc6 ls34">=</span><span class="ws13a">itemgetter(<span class="ff9 fc9 ls34">&apos;</span><span class="fc9">uid<span class="ff9 ls34">&apos;</span></span>))</span></span></span></div><div class="t m0 x5 hf y39e ff8 fs5 fc8 sc0 ls34">{<span class="ff9 ls0 ws13b">&apos;</span><span class="ls0 ws13a">fname</span><span class="ff9">&apos;</span><span class="ls32">:</span><span class="ff9">&apos;</span><span class="ls0 ws13a">Big</span><span class="ff9">&apos;</span><span class="ls32">,</span><span class="ff9">&apos;</span><span class="ls0 ws13a">lname<span class="ff9 ws13b">&apos;</span><span class="ls33">:</span></span><span class="ff9">&apos;</span><span class="ls0 ws13a">Jones</span><span class="ff9">&apos;</span><span class="ls32">,</span><span class="ff9">&apos;</span><span class="ls0 ws13a">uid</span><span class="ff9">&apos;</span><span class="ls0 ws4">: 1004}</span></div><div class="t m0 x5 hf y39f ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x5 hd y3a0 ff2 fs4 fc4 sc0 ls0 ws211">3.14<span class="_ _e"> </span>1.14 <span class="ff1">排序不支持原生比较的对象</span></div><div class="t m0 x5 he y3a1 ff2 fs2 fc4 sc0 ls0 ws212">3.14.1 <span class="ff1">问题</span></div><div class="t m0 x0 h9 y3a2 ff1 fs3 fc0 sc0 ls0">你想排序类型相同的对象，但是他们不支持原生的比较操作。</div><div class="t m0 x5 he y3a3 ff2 fs2 fc4 sc0 ls0 ws212">3.14.2 <span class="ff1">解决方案</span></div><div class="t m0 x0 h9 y3a4 ff1 fs3 fc0 sc0 ls0 ws260">内置的 <span class="ff6 ws261">sorted() </span><span class="ws262">函数有一个关键字参数 <span class="ff6 ws263">key </span><span class="ws264">，可以传入一个 <span class="ff6 ws261">callable </span>对象给它，</span></span></div><div class="t m0 x5 h9 y3a5 ff1 fs3 fc0 sc0 ls0 ws265">这个 <span class="ff6 ws266">callable </span><span class="ls2b ws267">对象对每个传入的对象返回一个值，这个值会被 </span><span class="ff6 ws268">sorted </span><span class="wsa0">用来<span class="_ _6"></span>排序这些</span></div><div class="t m0 x5 h9 y3a6 ff1 fs3 fc0 sc0 lsf ws269">对象<span class="_ _c"></span>。比如，如果你在应用程序里面有一个 <span class="ff6 ls0 ws26a">User </span><span class="wsdb">实例序列<span class="_ _c"></span>，并且你希望通过他们的<span class="_ _1"></span></span></div><div class="t m0 x5 h9 y3a7 ff6 fs3 fc0 sc0 ls0 ws26b">user<span class="_ _7"> </span>id <span class="ff1 ls68 ws26c">属性进行排序，你可以提供一个以 </span><span class="ws26d">User <span class="ff1 ls68 ws26e">实例作为输入并输出对应 </span></span>user id <span class="ff1">值</span></div><div class="t m0 x5 h9 y3a8 ff1 fs3 fc0 sc0 ls4">的<span class="ff6 ls0 ws26f">callable <span class="ff1">对象。比如：</span></span></div><div class="t m0 x5 hf y3a9 ff7 fs5 fca sc0 ls0 ws16a">class <span class="fcc ws156">User<span class="ff8 fc0">:</span></span></div><div class="t m0 x15 hf y3aa ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">__init__<span class="fc0">(<span class="fca">self</span><span class="ws4">, user_id):</span></span></span></div><div class="t m0 x16 hf y3ab ff8 fs5 fca sc0 ls0 ws13a">self<span class="fc6">.<span class="fc0 ws155">user_id </span><span class="ls33">=</span><span class="fc0">user_id</span></span></div><div class="t m0 x15 hf y3ac ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">__repr__<span class="fc0">(<span class="fca">self</span>):</span></span></div><div class="t m0 x16 hf y3ad ff7 fs5 fca sc0 ls0 ws146">return <span class="ff9 fc9 ls34">&apos;<span class="ff8 ls0 ws13a">User({})</span>&apos;<span class="ff8 fc6">.<span class="fc0 ls0 ws13a">format(<span class="fca">self</span></span>.<span class="fc0 ls0">user_id)</span></span></span></div><div class="t m0 x5 hf y3ae ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">sort_notcompare<span class="fc0">():</span></span></div><div class="t m0 x15 hf y3af ff8 fs5 fc0 sc0 ls0 ws15f">users <span class="fc6 ls33">=</span><span class="ws13a">[User(<span class="fc7">23</span><span class="ws13b">), User(<span class="fc7 ls34">3</span><span class="ws4">), User(</span></span><span class="fc7">99</span>)]</span></div><div class="t m0 x15 hf y3b0 ff7 fs5 fca sc0 ls0 ws156">print<span class="ff8 fc0">(users)</span></div><div class="t m0 x15 hf y3b1 ff7 fs5 fca sc0 ls0 ws156">print<span class="ff8 fc0 ws13a">(<span class="fca">sorted</span><span class="ws13b">(users, key</span><span class="fc6">=</span></span><span class="ws146">lambda <span class="ff8 fc0 ws4">u: u<span class="fc6 ls34">.</span>user_id))</span></span></div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 ws21d">3.14.<span class="_ _5"> </span>1.14 <span class="ff1 ws23b">排序不支持原生比较的对象 </span>27</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
