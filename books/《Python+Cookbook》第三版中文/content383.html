<div id="pf17f" class="pf w0 h0" data-page-no="17f"><div class="pc pc17f w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg17f.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 hf y1ab ff8 fs5 fc0 sc0 ls0 ws13c">bash <span class="fc6 ls32">%</span><span class="ws4">python3 myapp<span class="fc6 ws13a">.</span>zip</span></div><div class="t m0 x5 hf y1ac ff8 fs5 fc6 sc0 ls0 ws1a1">... <span class="fc0 ws145">output <span class="ff7 fca ws15a">from <span class="fcc ws168">__main__.py ...</span></span></span></div><div class="t m0 x5 he y2777 ff2 fs2 fc4 sc0 ls0 ws212">12.7.3 <span class="ff1">讨论</span></div><div class="t m0 x0 h7 y2778 ff1 fs3 fc0 sc0 ls51 ws885">创建一个目录或 <span class="ff4 ls0 wsd59">zip <span class="ff1 wsd5a">文件并<span class="_ _6"></span>添加 </span><span class="wsd5b">main<span class="_ _e"> </span>.p<span class="_ _1"></span>y <span class="ff1 ls51 wsd5c">文件来将一个更大的 </span><span class="ws4ce">Python <span class="ff1 wsa0">应用打<span class="_ _6"></span>包</span></span></span></span></div><div class="t m0 x5 h7 y2779 ff1 fs3 fc0 sc0 ls0 wsd5d">是可行的。这和作为标准库被安装到 <span class="ff4 wsd5e">Python </span><span class="wsa0">库的代码包是有一点区别的。相反，<span class="_ _1"></span>这只</span></div><div class="t m0 x5 h9 y277a ff1 fs3 fc0 sc0 ls0">是让别人执行的代码包。</div><div class="t m0 x0 h7 y277b ff1 fs3 fc0 sc0 ls0 wsd5f">由<span class="_ _6"></span>于<span class="_ _6"></span>目<span class="_ _0"></span>录和 <span class="ff4 wsd60">zip </span><span class="ls24 wsd61">文件与正常文件有一点不同，你可能还需要增加一个 </span><span class="ff4 wsd62">shell </span><span class="wsa0">脚本，</span></div><div class="t m0 x5 h7 y277c ff1 fs3 fc0 sc0 ls24 wsd63">使执行更加容易<span class="_ _c"></span>。例如，如果代码文件名为 <span class="ff4 ls0 wsa5">m<span class="_ _c"></span>y<span class="_ _1"></span>app.zip<span class="ff1 ls24 ws11d">，你可以创建这样一个顶级脚<span class="_ _1"></span></span></span></div><div class="t m0 x5 h9 y277d ff1 fs3 fc0 sc0 ls0">本：</div><div class="t m0 x5 h11 y277e ffa fs5 fcd sc0 ls0 ws4">#!/usr/bin/env python3 /usr/local/bin/myapp.zip</div><div class="t m0 x5 hd y277f ff2 fs4 fc4 sc0 ls0 ws211">12.8<span class="_ _e"> </span>10.8 <span class="ff1">读取位于包中的数据文件</span></div><div class="t m0 x5 he y2780 ff2 fs2 fc4 sc0 ls0 ws212">12.8.1 <span class="ff1">问题</span></div><div class="t m0 x0 h9 y2781 ff1 fs3 fc0 sc0 ls3a ws153">你的包中包含代码需要去读取的数据文件。你需要尽可能地用最便捷的方式来做这</div><div class="t m0 x5 h9 ye5f ff1 fs3 fc0 sc0 ls0">件事。</div><div class="t m0 x5 he y2782 ff2 fs2 fc4 sc0 ls0 ws212">12.8.2 <span class="ff1">解决方案</span></div><div class="t m0 x0 h9 y2783 ff1 fs3 fc0 sc0 ls0">假设你的包中的文件组织成如下：</div><div class="t m0 x5 hf y1fc4 ff8 fs5 fc0 sc0 ls0 ws13a">mypackage<span class="fc6">/</span></div><div class="t m0 x15 hf y163e ff8 fs5 fc0 sc0 ls0 ws13a">__init__<span class="fc6">.</span>py</div><div class="t m0 x15 hf y2784 ff8 fs5 fc0 sc0 ls0 ws13a">somedata<span class="fc6">.</span>dat</div><div class="t m0 x15 hf y163f ff8 fs5 fc0 sc0 ls0 ws13a">spam<span class="fc6 ls34">.</span>py</div><div class="t m0 x0 h7 y2785 ff1 fs3 fc0 sc0 ls0 wsd64">现在<span class="_ _6"></span>假<span class="_ _6"></span>设 <span class="ff4 wsd65">spam.p<span class="_ _1"></span>y <span class="ff1 ws430">文<span class="_ _6"></span>件需<span class="_ _6"></span>要<span class="_ _6"></span>读取 </span><span class="wsd66">somedata.dat <span class="ff1 wsa0">文<span class="_ _6"></span>件<span class="_ _6"></span>中的<span class="_ _6"></span>内<span class="_ _6"></span>容。你<span class="_ _6"></span>可<span class="_ _6"></span>以<span class="_ _6"></span>用以<span class="_ _6"></span>下<span class="_ _6"></span>代码</span></span></span></div><div class="t m0 x5 h9 y2786 ff1 fs3 fc0 sc0 ls0">来完成：</div><div class="t m0 x5 h11 y1bd1 ffa fs5 fcd sc0 ls0 ws4"># spam.py</div><div class="t m0 x5 h10 y2787 ff7 fs5 fca sc0 ls0 ws146">import <span class="fcc">pkgutil</span></div><div class="t m0 x5 hf y2788 ff8 fs5 fc0 sc0 ls0 ws13c">data <span class="fc6 ls32">=</span><span class="ws13a">pkgutil<span class="fc6 ls34">.</span><span class="wsd67">get_data(__package__, <span class="ff9 fc9 ls34">&apos;</span></span><span class="fc9">somedata.dat<span class="ff9 ls34">&apos;</span></span>)</span></div><div class="t m0 x0 h9 y2789 ff1 fs3 fc0 sc0 ls0">由此产生的变量是包含该文件的原始内容的字节字符串。</div><div class="t m0 x5 he y278a ff2 fs2 fc4 sc0 ls0 ws212">12.8.3 <span class="ff1">讨论</span></div><div class="t m0 x0 h7 y1969 ff1 fs3 fc0 sc0 lsa5 wsd68">要读取数据文件<span class="_ _1"></span>，你可能会倾向于编写使用内置的 <span class="ff4 ls0 wsd69">I/ O <span class="ff1 wsd6a">功<span class="_ _6"></span>能<span class="_ _6"></span>的<span class="_ _6"></span>代<span class="_ _6"></span>码，<span class="_ _6"></span>如 </span><span class="wsa5">op<span class="_ _6"></span>en()<span class="ff1">。</span></span></span></div><div class="t m0 x5 h9 y278b ff1 fs3 fc0 sc0 ls0">但是这种方法也有一些问题。</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 ws21d">12.8.<span class="_ _5"> </span>10.8 <span class="ff1 ws512">读取位于包中的数据文件 </span>374</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
