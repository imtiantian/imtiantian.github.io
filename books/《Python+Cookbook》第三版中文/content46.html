<div id="pf2e" class="pf w0 h0" data-page-no="2e"><div class="pc pc2e w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg2e.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 hd y4d3 ff2 fs4 fc4 sc0 ls0 ws211">3.20<span class="_ _e"> </span>1.20 <span class="ff1">合并多个字典或映射</span></div><div class="t m0 x5 he y4d4 ff2 fs2 fc4 sc0 ls0 ws212">3.20.1 <span class="ff1">问题</span></div><div class="t m0 x0 h9 y4d5 ff1 fs3 fc0 sc0 ls3a ws153">现在有多个字典或者映射，你想将它们从逻辑上合并为一个单一的映射后执行某些</div><div class="t m0 x5 h9 y4d6 ff1 fs3 fc0 sc0 ls0">操作，比如查找值或者检查某些键是否存在。</div><div class="t m0 x5 he y4d7 ff2 fs2 fc4 sc0 ls0 ws212">3.20.2 <span class="ff1">解决方案</span></div><div class="t m0 x0 h7 y4d8 ff1 fs3 fc0 sc0 ls0 wsa0">假如你有如下两个字典<span class="ff4">:</span></div><div class="t m0 x5 hf y4d9 ff8 fs5 fc0 sc0 ls32">a<span class="fc6 ls33">=</span><span class="ls34">{<span class="ff9 fc9 ls0 ws13b">&apos;</span><span class="fc9">x<span class="ff9">&apos;</span></span></span>:<span class="fc7 ls34">1</span>,<span class="ff9 fc9 ls34">&apos;<span class="ff8">z</span>&apos;</span>:<span class="fc7 ls33">3</span><span class="ls0">}</span></div><div class="t m0 x5 hf y4da ff8 fs5 fc0 sc0 ls32">b<span class="fc6 ls33">=</span><span class="ls34">{<span class="ff9 fc9 ls0 ws13b">&apos;</span><span class="fc9">y<span class="ff9">&apos;</span></span></span>:<span class="fc7 ls34">2</span>,<span class="ff9 fc9 ls34">&apos;<span class="ff8">z</span>&apos;</span>:<span class="fc7 ls33">4</span><span class="ls0">}</span></div><div class="t m0 x0 h7 y4db ff1 fs3 fc0 sc0 ls3d ws2bc">现在假设你必须在两个字典中执行查找操作 <span class="ff4 ls0 wsa5">(</span><span class="ws2bd">比如先从 <span class="ff6 ls72">a</span><span class="ws2be">中找，如果找不到再在 <span class="ff6 ls0">b</span></span></span></div><div class="t m0 x5 h7 y4dc ff1 fs3 fc0 sc0 ls0 wsa0">中找<span class="ff4 ls1b">)</span><span class="ws16f">。<span class="_ _c"></span>一个非常简单的解决方案就是使用 <span class="ff6 ws2bf">collections </span><span class="ws2c0">模块中的 <span class="ff6 ws2c1">ChainMap </span><span class="wsa0">类。比如：</span></span></span></div><div class="t m0 x5 hf y4dd ff7 fs5 fca sc0 ls0 ws15a">from <span class="fcc ws168">collections </span><span class="ws146">import <span class="ff8 fc0">ChainMap</span></span></div><div class="t m0 x5 hf y4de ff8 fs5 fc0 sc0 ls32">c<span class="fc6 ls33">=</span><span class="ls0">ChainMap(a,b)</span></div><div class="t m0 x5 hf y4df ff7 fs5 fca sc0 ls0 ws156">print<span class="ff8 fc0 ws13a">(c[<span class="ff9 fc9 ls34">&apos;</span><span class="fc9">x<span class="ff9 ls34">&apos;</span></span><span class="ws159">]) <span class="ffa fcd ws4"># Outputs 1 (from a)</span></span></span></div><div class="t m0 x5 hf y4e0 ff7 fs5 fca sc0 ls0 ws156">print<span class="ff8 fc0 ws13a">(c[<span class="ff9 fc9 ls34">&apos;</span><span class="fc9">y<span class="ff9 ls34">&apos;</span></span><span class="ws159">]) <span class="ffa fcd ws4"># Outputs 2 (from b)</span></span></span></div><div class="t m0 x5 hf y4e1 ff7 fs5 fca sc0 ls0 ws156">print<span class="ff8 fc0 ws13a">(c[<span class="ff9 fc9 ls34">&apos;</span><span class="fc9">z<span class="ff9 ls34">&apos;</span></span><span class="ws159">]) <span class="ffa fcd ws4"># Outputs 3 (from a)</span></span></span></div><div class="t m0 x5 he y202 ff2 fs2 fc4 sc0 ls0 ws212">3.20.3 <span class="ff1">讨论</span></div><div class="t m0 x0 h9 y4e2 ff1 fs3 fc0 sc0 ls0 ws2c2">一个 <span class="ff6 ws2c3">ChainMap </span><span class="ls3d ws164">接受多个字典并将它们在逻辑上变为一个字典。然后，这些字典并</span></div><div class="t m0 x5 h9 y4e3 ff1 fs3 fc0 sc0 ls0 ws2c4">不是真的合并在一起了， <span class="ff6 ws2c5">ChainMap </span>类只是在内部创建了一个容纳这些字典的列表并重</div><div class="t m0 x5 h9 y4e4 ff1 fs3 fc0 sc0 ls2c ws12f">新定义了一些常见的字典操作来遍历这个列表。大部分字典操作都是可以正常使<span class="_ _1"></span>用的，</div><div class="t m0 x5 h9 y4e5 ff1 fs3 fc0 sc0 ls0">比如：</div><div class="t m0 x5 hf y4e6 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fca ws13a">len<span class="fc0">(c)</span></span></div><div class="t m0 x5 hf y4e7 ff8 fs5 fc8 sc0 ls0">3</div><div class="t m0 x5 hf y4e8 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fca ws13a">list<span class="fc0">(c<span class="fc6 ls34">.</span>keys())</span></span></div><div class="t m0 x5 hf y4e9 ff8 fs5 fc8 sc0 ls34">[<span class="ff9 ls0 ws13b">&apos;</span>x<span class="ff9">&apos;</span><span class="ls32">,</span><span class="ff9">&apos;</span>y<span class="ff9">&apos;</span><span class="ls32">,</span><span class="ff9">&apos;</span><span class="ls0 ws13a">z</span><span class="ff9">&apos;</span><span class="ls0">]</span></div><div class="t m0 x5 hf y4ea ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fca ws13a">list<span class="fc0">(c<span class="fc6 ls34">.</span>values())</span></span></div><div class="t m0 x5 hf y4eb ff8 fs5 fc8 sc0 ls0 ws4">[1, 2, 3]</div><div class="t m0 x5 hf y4ec ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h9 y4ed ff1 fs3 fc0 sc0 ls0 ws2c6">如果出现重复键，<span class="_ _8"></span>那么第一次出现的映射值会被返回。<span class="_ _d"></span>因此，<span class="_ _8"></span>例子程序中的 <span class="ff6">c[&apos;z&apos;]</span></div><div class="t m0 x5 h9 y4ee ff1 fs3 fc0 sc0 ls0 ws38">总是会返回字典 <span class="ff6 ls73">a</span>中对应的值，而不是 <span class="ff6 ls73">b</span>中对应的值。</div><div class="t m0 x0 h9 y4ef ff1 fs3 fc0 sc0 ls0">对于字典的更新或删除操作总是影响的是列表中第一个字典。比如：</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 ws21d">3.20.<span class="_ _5"> </span>1.20 <span class="ff1 ws2ad">合并多个字典或映射 </span>37</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
