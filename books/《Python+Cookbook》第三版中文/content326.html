<div id="pf146" class="pf w0 h0" data-page-no="146"><div class="pc pc146 w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg146.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 he y137 ff2 fs2 fc4 sc0 ls0 ws212">11.8.3 <span class="ff1">讨论</span></div><div class="t m0 x0 h9 y236 ff1 fs3 fc0 sc0 ls3a ws153">在类中定义装饰器初看上去好像很奇怪，但是在标准库中有很多这样的例子。特别</div><div class="t m0 x5 h9 y237 ff1 fs3 fc0 sc0 ls0 wsa0">的，<span class="_ _d"></span><span class="ff6 wsbe9">@property <span class="ff1 wsbea">装饰器实际上是一个类，<span class="_ _c"></span>它里面定义了三个方法 <span class="ff6 wsbeb">getter(), setter(),</span></span></span></div><div class="t m0 x5 h7 y238 ff6 fs3 fc0 sc0 ls0 ws1d1">deleter() <span class="ff4 ls83">,</span><span class="ff1">每一个方法都是一个装饰器。例如：</span></div><div class="t m0 x5 hf y2221 ff7 fs5 fca sc0 ls0 ws16a">class <span class="fcc ws156">Person<span class="ff8 fc0">:</span></span></div><div class="t m0 x15 h11 y1d54 ffa fs5 fcd sc0 ls0 ws4"># Create a property instance</div><div class="t m0 x15 hf y1d55 ff8 fs5 fc0 sc0 ls0 ws2a3">first_name <span class="fc6 ls32">=</span><span class="fca ws13a">property</span>()</div><div class="t m0 x15 h11 y2222 ffa fs5 fcd sc0 ls0 ws4"># Apply decorator methods</div><div class="t m0 x15 h10 y2223 ff7 fs5 fc12 sc0 ls0">@first_name.getter</div><div class="t m0 x15 hf y2224 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">first_name<span class="fc0 ls34">(</span><span class="fca">self<span class="fc0">):</span></span></span></div><div class="t m0 x16 hf y2225 ff7 fs5 fca sc0 ls0 ws146">return <span class="ff8 ws13a">self<span class="fc6 ls34">.</span><span class="fc0">_first_name</span></span></div><div class="t m0 x15 h10 y2226 ff7 fs5 fc12 sc0 ls0">@first_name.setter</div><div class="t m0 x15 hf y1d5a ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">first_name<span class="fc0 ls34">(</span><span class="fca">self<span class="fc0 ws13b">, value):</span></span></span></div><div class="t m0 x16 hf y1d5b ff7 fs5 fca sc0 ls0 ws157">if not <span class="ff8 ws13a">isinstance<span class="fc0 ws155">(value, </span>str<span class="fc0">):</span></span></div><div class="t m0 x17 hf y2227 ff7 fs5 fca sc0 ls0 ws16a">raise <span class="ff8 ws13a">TypeError<span class="fc0">(<span class="ff9 fc9 ls34">&apos;</span><span class="fc9 ws4">Expected a string<span class="ff9 ls34">&apos;</span></span>)</span></span></div><div class="t m0 x16 hf y1d5c ff8 fs5 fca sc0 ls0 ws13a">self<span class="fc6">.<span class="fc0 ws208">_first_name </span><span class="ls33">=</span><span class="fc0">value</span></span></div><div class="t m0 x0 h9 y2228 ff1 fs3 fc0 sc0 ls0 wsbec">它为什<span class="_ _6"></span>么要这<span class="_ _6"></span>么定<span class="_ _6"></span>义的主<span class="_ _6"></span>要原因<span class="_ _6"></span>是各种<span class="_ _6"></span>不同的<span class="_ _6"></span>装饰器<span class="_ _6"></span>方法<span class="_ _6"></span>会在关<span class="_ _6"></span>联的 <span class="ff6 ws492">property </span>实</div><div class="t m0 x5 h9 y2229 ff1 fs3 fc0 sc0 ls0 wsa0">例<span class="_ _6"></span>上操<span class="_ _6"></span>作<span class="_ _6"></span>它<span class="_ _6"></span>的<span class="_ _6"></span>状<span class="_ _6"></span>态。因<span class="_ _6"></span>此，<span class="_ _6"></span>任<span class="_ _6"></span>何<span class="_ _6"></span>时<span class="_ _6"></span>候只<span class="_ _6"></span>要<span class="_ _6"></span>你<span class="_ _6"></span>碰<span class="_ _6"></span>到<span class="_ _6"></span>需<span class="_ _6"></span>要在<span class="_ _6"></span>装<span class="_ _6"></span>饰<span class="_ _6"></span>器<span class="_ _6"></span>中<span class="_ _6"></span>记录<span class="_ _6"></span>或<span class="_ _6"></span>绑<span class="_ _6"></span>定<span class="_ _6"></span>信<span class="_ _6"></span>息，那</div><div class="t m0 x5 h9 y222a ff1 fs3 fc0 sc0 ls0">么这不失为一种可行方法。</div><div class="t m0 x0 h9 y222b ff1 fs3 fc0 sc0 ls2d wsbed">在类中定义装饰器有个难理解的地方就是对于额外参数 <span class="ff6 ls0 wsbee">self </span><span class="ls158">或<span class="ff6 ls0 wsbef">cls <span class="ff1 wsa0">的<span class="_ _6"></span>正<span class="_ _6"></span>确使<span class="_ _6"></span>用。</span></span></span></div><div class="t m0 x5 h9 y222c ff1 fs3 fc0 sc0 ls17 ws11b">尽管最外层的装饰器函数比如 <span class="ff6 ls0 wsbf0">decorator1() </span><span class="ls192">或<span class="ff6 ls0 wsbf1">decorator2() <span class="ff1 wsbf2">需要<span class="_ _6"></span>提供<span class="_ _6"></span>一个 </span><span class="ws5a8">self <span class="ff1">或</span></span></span></span></div><div class="t m0 x5 h9 y222d ff6 fs3 fc0 sc0 ls0 wsbf3">cls <span class="ff1 wsbf4">参数，但是在两个装饰器内部被创建的 </span><span class="wsbf5">wrapper() <span class="ff1 ws262">函数并不需要包含这个 </span><span class="wsbf6">self <span class="ff1">参</span></span></span></div><div class="t m0 x5 h9 y195a ff1 fs3 fc0 sc0 ls13 wse5">数<span class="_ _1"></span>。你唯一需要这个参数是在你确实要访问包装器中这个实例的某些部分的时候。其<span class="_ _c"></span></div><div class="t m0 x5 h9 y222e ff1 fs3 fc0 sc0 ls0">他情况下都不用去管它。</div><div class="t m0 x0 h9 y222f ff1 fs3 fc0 sc0 ls30 ws138">对于类里面定义的包装器还有一点比较难理解<span class="_ _1"></span>，就是在涉及到继承的时候。例如<span class="_ _c"></span>，</div><div class="t m0 x5 h7 y2230 ff1 fs3 fc0 sc0 ls0 ws14">假设你想让在 <span class="ff4 ls3">A</span>中定义的装饰器作用在子类 <span class="ff4 ls167">B</span>中。你需要像下面这样写：</div><div class="t m0 x5 hf y68a ff7 fs5 fca sc0 ls0 ws16a">class <span class="fcc ls34">B</span><span class="ff8 fc0">(A):</span></div><div class="t m0 x15 h10 y68b ff7 fs5 fc12 sc0 ls0">@A.decorator2</div><div class="t m0 x15 hf y2231 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">bar<span class="fc0 ls34">(</span><span class="fca">self<span class="fc0">):</span></span></span></div><div class="t m0 x16 h10 y2232 ff7 fs5 fca sc0 ls0">pass</div><div class="t m0 x0 h9 y2233 ff1 fs3 fc0 sc0 ls3a ws153">也就是说，装饰器要被定义成类方法并且你必须显式的使用父类名去调用它。你不</div><div class="t m0 x5 h7 y2234 ff1 fs3 fc0 sc0 ls0 ws38">能使用 <span class="ff6 ws317">@B.decorator2 </span>，因为在方法定义时，这个类 <span class="ff4 ls193">B</span>还没有被创建。</div><div class="t m0 x5 hd y2235 ff2 fs4 fc4 sc0 ls0 ws9c6">11.9<span class="_ _e"> </span>9.9 <span class="ff1">将装饰器定义为类</span></div><div class="t m0 x5 he y2236 ff2 fs2 fc4 sc0 ls0 ws212">11.9.1 <span class="ff1">问题</span></div><div class="t m0 x0 h9 y2237 ff1 fs3 fc0 sc0 ls3a ws153">你想使用一个装饰器去包装函数，但是希望返回一个可调用的实例。你需要让你的</div><div class="t m0 x5 h9 y2238 ff1 fs3 fc0 sc0 ls0">装饰器可以同时工作在类定义的内部和外部。</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 ws9da">11.9.<span class="_ _5"> </span>9.9 <span class="ff1 ws2a4">将装饰器定义为类 </span>317</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
