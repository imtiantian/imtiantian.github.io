<div id="pf1f3" class="pf w0 h0" data-page-no="1f3"><div class="pc pc1f3 w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg1f3.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 hf y1ab ff8 fs5 fc0 sc0 ls0 ws4">bash % daemon.py stop</div><div class="t m0 x5 hf y1ac ff8 fs5 fc0 sc0 ls0 ws4">bash %</div><div class="t m0 x5 he y3138 ff2 fs2 fc4 sc0 ls0 wsadf">14.14.3 <span class="ff1">讨论</span></div><div class="t m0 x0 h9 y3139 ff1 fs3 fc0 sc0 ls48 ws11bc">本节定义了一个函数 <span class="ff6 ls0 ws1050">daemonize() </span><span class="ws242">，在程序启动时被调用使得程序以一个守护进<span class="_ _1"></span></span></div><div class="t m0 x5 h9 y313a ff1 fs3 fc0 sc0 ls0 ws34e">程来<span class="_ _6"></span>运行。 <span class="ff6 ws1ec">daemonize() </span><span class="ls17 wsf6">函数只接受关键字参数，这样的话可选参数在被使用时就更<span class="_ _1"></span></span></div><div class="t m0 x5 h9 y313b ff1 fs3 fc0 sc0 ls0">清晰了。它会强制用户像下面这样使用它：</div><div class="t m0 x5 hf y313c ff8 fs5 fc0 sc0 ls0 ws13a">daemonize(<span class="ff9 ls34">&apos;</span>daemon.pid<span class="ff9 ls34">&apos;</span>,</div><div class="t m0 x48 hf y313d ff8 fs5 fc0 sc0 ls0 ws13a">stdin=<span class="ff9 ws13b">&apos;</span>/dev/null,</div><div class="t m0 x48 hf y313e ff8 fs5 fc0 sc0 ls0 ws13a">stdout=<span class="ff9 ls34">&apos;</span>/tmp/daemon.log<span class="ff9 ls34">&apos;</span>,</div><div class="t m0 x48 hf y313f ff8 fs5 fc0 sc0 ls0 ws13a">stderr=<span class="ff9 ls34">&apos;</span>/tmp/daemon.log<span class="ff9 ls34">&apos;</span>)</div><div class="t m0 x0 h9 y3140 ff1 fs3 fc0 sc0 ls0">而不是像下面这样含糊不清的调用：</div><div class="t m0 x5 h11 y3141 ffa fs5 fcd sc0 ls0 ws4"># Illegal. Must use keyword arguments</div><div class="t m0 x5 hf y3142 ff8 fs5 fc0 sc0 ls0 ws13a">daemonize(<span class="ff9 fc9 ls34">&apos;</span><span class="fc9">daemon.pid<span class="ff9 ls34">&apos;</span></span>,</div><div class="t m0 x48 hf y3143 ff9 fs5 fc9 sc0 ls34">&apos;<span class="ff8 ls0 ws13a">/dev/null</span><span class="ls0 ws13b">&apos;<span class="ff8 fc0 ls33">,</span>&apos;<span class="ff8 ws13a">/tmp/daemon.log</span></span>&apos;<span class="ff8 fc0">,</span>&apos;<span class="ff8 ls0 ws13a">/tmp/daemon.log</span>&apos;<span class="ff8 fc0 ls0">)</span></div><div class="t m0 x0 h9 y3144 ff1 fs3 fc0 sc0 ls0 wsa0">创建一个守护进程的<span class="_ _6"></span>步骤看上去不是很易懂，但<span class="_ _6"></span>是大体思想是这样的，首<span class="_ _6"></span>先，一个</div><div class="t m0 x5 h9 y3145 ff1 fs3 fc0 sc0 lsa8 ws11bd">守护进程必须要从父进程中脱离。这是<span class="_ _1"></span>由 <span class="ff6 ls0 ws8e5">os.fork() <span class="ff1 wsa0">操<span class="_ _6"></span>作来<span class="_ _6"></span>完成<span class="_ _6"></span>的，并<span class="_ _6"></span>立即<span class="_ _6"></span>被父<span class="_ _6"></span>进<span class="_ _6"></span>程</span></span></div><div class="t m0 x5 h9 y1822 ff1 fs3 fc0 sc0 ls0">终止。</div><div class="t m0 x0 h9 y3146 ff1 fs3 fc0 sc0 ls49 ws11be">在子进程变成孤儿后<span class="_ _1"></span>，调用 <span class="ff6 ls0 ws1ea">os.setsid() </span><span class="ws1a6">创建了一个全新的进程会话<span class="_ _1"></span>，并设置子<span class="_ _1"></span></span></div><div class="t m0 x5 h9 y3147 ff1 fs3 fc0 sc0 ls16 wsf3">进程为首领<span class="_ _c"></span>。它会设置这个子进程为新的进程组的首领<span class="_ _1"></span>，并确保不会再有控制终端<span class="_ _1"></span>。<span class="_ _c"></span></div><div class="t m0 x5 h9 y3148 ff1 fs3 fc0 sc0 ls2d ws132">如果这些听上去太魔幻，因为它需要将守护进程同终端分离开并确保信号机制对它不<span class="_ _1"></span></div><div class="t m0 x5 h9 y1baf ff1 fs3 fc0 sc0 ls0 ws11bf">起作用。调<span class="_ _6"></span>用 <span class="ff6 ws11c0">os.chdir() </span><span class="ls128">和</span><span class="ff6 ws11c1">os.umask(0) </span><span class="ls51 ws1c8">改变了当前工作目录并重置文件权限掩码。</span></div><div class="t m0 x5 h9 y3149 ff1 fs3 fc0 sc0 ls0">修改目录通常是个好主意，因为这样可以使得它不再工作在被启动时的目录。</div><div class="t m0 x0 h9 y314a ff1 fs3 fc0 sc0 ls0 ws11c2">另<span class="_ _6"></span>外<span class="_ _6"></span>一<span class="_ _6"></span>个<span class="_ _6"></span>调<span class="_ _6"></span>用 <span class="ff6 ws33a">os.fork() </span><span class="ls14 ws174">在这里更加神秘点<span class="_ _c"></span>。<span class="_ _6"></span>这一步使得守护进程失去了获取新<span class="_ _c"></span></span></div><div class="t m0 x5 h7 y314b ff1 fs3 fc0 sc0 ls18 ws11c3">的控制终端的能力并且让它更加独立（本质上，该 <span class="ff4 ls0 ws11c4">daemon </span><span class="ws110">放弃了它的会话首领低位<span class="_ _1"></span>，</span></div><div class="t m0 x5 h9 y314c ff1 fs3 fc0 sc0 ls0 wsa0">因<span class="_ _6"></span>此<span class="_ _6"></span>再<span class="_ _6"></span>也<span class="_ _6"></span>没<span class="_ _6"></span>有<span class="_ _6"></span>权<span class="_ _6"></span>限<span class="_ _6"></span>去<span class="_ _0"></span>打开<span class="_ _6"></span>控<span class="_ _6"></span>制<span class="_ _0"></span>终端<span class="_ _6"></span>了）<span class="_ _f"></span>。<span class="_ _6"></span>尽<span class="_ _0"></span>管你<span class="_ _6"></span>可<span class="_ _0"></span>以忽<span class="_ _6"></span>略<span class="_ _6"></span>这<span class="_ _0"></span>一步，<span class="_ _6"></span>但<span class="_ _0"></span>是最<span class="_ _6"></span>好<span class="_ _6"></span>不<span class="_ _0"></span>要这<span class="_ _6"></span>么</div><div class="t m0 x5 h9 yda5 ff1 fs3 fc0 sc0 ls0">做。</div><div class="t m0 x0 h7 y314d ff1 fs3 fc0 sc0 ls23 ws11c5">一旦守护进程被正确的分离<span class="_ _c"></span>，它会重新初始化标准 <span class="ff4 ls0 ws11c6">I/<span class="_ _0"></span>O </span><span class="ws11a">流指向用户指定的文件<span class="_ _d"></span>。</span></div><div class="t m0 x5 h7 y314e ff1 fs3 fc0 sc0 ls0 ws11c7">这一<span class="_ _6"></span>部分<span class="_ _6"></span>有点<span class="_ _6"></span>难懂。<span class="_ _6"></span>跟标<span class="_ _6"></span>准 <span class="ff4 ws11c8">I/O </span><span class="wsa0">流<span class="_ _6"></span>相关<span class="_ _6"></span>的文<span class="_ _6"></span>件对<span class="_ _6"></span>象的<span class="_ _6"></span>引用<span class="_ _6"></span>在解<span class="_ _6"></span>释器<span class="_ _6"></span>中多<span class="_ _6"></span>个地<span class="_ _6"></span>方被<span class="_ _6"></span>找到</span></div><div class="t m0 x38 h7 y314f ff1 fs3 fc0 sc0 lsb">（<span class="ff4 ls0 ws11c9">sys.stdout, sys.<span class="_ _e"> </span>stdout<span class="_ _e"> </span></span><span class="ls1d ws11ca">等<span class="_ _c"></span>）<span class="_ _2e"></span>。仅仅简单的关闭 <span class="ff6 ls0 ws11cb">sys.stdout </span><span class="ws1c3">并重新指定它是行不通<span class="_ _1"></span></span></span></div><div class="t m0 x5 h9 y221b ff1 fs3 fc0 sc0 ls0 ws11cc">的，因为没办法知道它是否全部都是用的是 <span class="ff6 ws53b">sys.stdout </span><span class="wsa0">。这里，<span class="_ _c"></span>我们打开了一个单独</span></div><div class="t m0 x5 h9 y3150 ff1 fs3 fc0 sc0 ls0 ws11cd">的<span class="_ _6"></span>文件<span class="_ _6"></span>对<span class="_ _6"></span>象，<span class="_ _6"></span>并<span class="_ _6"></span>调<span class="_ _6"></span>用 <span class="ff6 ws980">os.dup2() </span><span class="ls40 ws11ce">，用它来代替被 </span><span class="ff6 ws11cf">sys.stdout </span><span class="wsa0">使<span class="_ _6"></span>用<span class="_ _6"></span>的文<span class="_ _6"></span>件<span class="_ _6"></span>描<span class="_ _6"></span>述<span class="_ _6"></span>符。<span class="_ _6"></span>这</span></div><div class="t m0 x5 h9 y3151 ff1 fs3 fc0 sc0 ls0 wsa0">样，<span class="ff6 ws2e6">sys.stdout </span><span class="ls18 ws110">使用的原始文件会被关闭并由新的来替换。还要强调的是任何用于文</span></div><div class="t m0 x5 h7 y3152 ff1 fs3 fc0 sc0 ls0 ws38">件编码或文本处理的标准 <span class="ff4 ws59">I/O </span>流还会保留原状。</div><div class="t m0 x0 h7 y42b ff1 fs3 fc0 sc0 ls0 ws11d0">守<span class="_ _0"></span>护<span class="_ _6"></span>进<span class="_ _0"></span>程<span class="_ _6"></span>的<span class="_ _0"></span>一<span class="_ _0"></span>个<span class="_ _6"></span>通<span class="_ _0"></span>常<span class="_ _0"></span>实<span class="_ _6"></span>践<span class="_ _0"></span>是<span class="_ _0"></span>在<span class="_ _6"></span>一<span class="_ _0"></span>个<span class="_ _0"></span>文<span class="_ _6"></span>件<span class="_ _0"></span>中<span class="_ _6"></span>写<span class="_ _0"></span>入<span class="_ _0"></span>进<span class="_ _6"></span>程 <span class="ff4 wsa5">ID</span><span class="lsb5 ws942">，可以被其他程序后面使<span class="_ _c"></span></span></div><div class="t m0 x5 h9 y3153 ff1 fs3 fc0 sc0 ls0 ws11d1">用<span class="_ _0"></span>到。 <span class="ff6 ws11d2">daemonize() </span><span class="ls14f ws91d">函数的最后部分写了这个文件<span class="_ _d"></span>，但是在程序终止时删除了它<span class="_ _c"></span>。<span class="_ _d"></span></span></div><div class="t m0 x5 h7 y3154 ff6 fs3 fc0 sc0 ls0 ws11d3">atexit.register() <span class="ff1 ws11d4">函<span class="_ _0"></span>数<span class="_ _12"></span>注<span class="_ _0"></span>册<span class="_ _0"></span>了<span class="_ _12"></span>一<span class="_ _0"></span>个<span class="_ _0"></span>函<span class="_ _12"></span>数<span class="_ _0"></span>在 <span class="ff4 ws11d5">Python </span><span class="wsa0">解<span class="_ _0"></span>释<span class="_ _12"></span>器<span class="_ _0"></span>终<span class="_ _0"></span>止<span class="_ _12"></span>时<span class="_ _0"></span>执<span class="_ _0"></span>行。<span class="_ _12"></span>一<span class="_ _0"></span>个<span class="_ _12"></span>对<span class="_ _0"></span>于</span></span></div><div class="t m0 x5 h7 y3155 ff4 fs3 fc0 sc0 ls0 ws11d6">SIGTERM <span class="ff1 wsa0">的<span class="_ _0"></span>信<span class="_ _0"></span>号<span class="_ _6"></span>处<span class="_ _0"></span>理<span class="_ _0"></span>器<span class="_ _0"></span>的<span class="_ _0"></span>定<span class="_ _0"></span>义<span class="_ _6"></span>同<span class="_ _0"></span>样<span class="_ _0"></span>需<span class="_ _0"></span>要<span class="_ _0"></span>被<span class="_ _0"></span>优<span class="_ _6"></span>雅<span class="_ _0"></span>的<span class="_ _0"></span>关<span class="_ _0"></span>闭。<span class="_ _0"></span>信<span class="_ _0"></span>号<span class="_ _6"></span>处<span class="_ _0"></span>理<span class="_ _0"></span>器<span class="_ _0"></span>简<span class="_ _0"></span>单<span class="_ _0"></span>的<span class="_ _6"></span>抛<span class="_ _0"></span>出<span class="_ _0"></span>了</span></div><div class="t m0 x5 h9 y3156 ff6 fs3 fc0 sc0 ls0 ws1de">SystemExit() <span class="ff1 ls2c ws12f">异常。或许这一步看上去没必要，但是没有它，终止信号会使得不执行<span class="_ _1"></span></span></div><div class="t m0 x5 h9 y1fa6 ff6 fs3 fc0 sc0 ls0 ws11d7">atexit.register() <span class="ff1 ls40 ws180">注册的清理操作的时候就杀掉了解释器<span class="_ _1"></span>。一个杀掉进程的例子代</span></div><div class="t m0 x5 h9 y3157 ff1 fs3 fc0 sc0 ls0 ws38">码可以在程序最后的 <span class="ff6 ws27b">stop </span>命令的操作中看到。</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 wsd97">14.14.<span class="_ _36"> </span>12.14 <span class="ff1 ls7f">在</span><span class="ws11b9">Unix <span class="ff1 ws11ba">系统上面启动守护进程 </span>490</span></div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
