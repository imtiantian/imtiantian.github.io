<div id="pf24d" class="pf w0 h0" data-page-no="24d"><div class="pc pc24d w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg24d.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 hf y15f ff8 fs5 fc8 sc0 ls0">2.0</div><div class="t m0 x5 hf y160 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws13a">sample<span class="fc6 ls34">.</span>avg(b)</span></div><div class="t m0 x5 hf y956 ff8 fs5 fc8 sc0 ls0">2.0</div><div class="t m0 x5 hf y957 ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h9 y21d2 ff1 fs3 fc0 sc0 ls0 wsa0">在<span class="_ _12"></span>此<span class="_ _24"></span>包<span class="_ _12"></span>装<span class="_ _24"></span>器<span class="_ _12"></span>中，<span class="_ _24"></span><span class="ff6 ws14d8">a.size0 </span><span class="ls28a">和</span><span class="ff6 ws14d9">&amp;a[0] </span><span class="ls28b ws14da">分别引用数组元素个数和底层指针<span class="_ _19"></span>。语法<span class="_ _19"></span></span></div><div class="t m0 x5 h7 y38a1 ff10 fs3 fc0 sc0 ls0 ws305">&lt;<span class="ff6 ws14db">double *</span><span class="ls28c">&gt;</span><span class="ff6 ws14dc">&amp;a[0] <span class="ff1 ls18f ws14dd">教你怎样将指针转换为不同的类型<span class="_ _d"></span>。前提是 <span class="ff4 ls28d">C</span><span class="ls0 ws14de">中<span class="_ _0"></span>的 <span class="ff6 ws14df">avg() </span>接</span></span></span></div><div class="t m0 x5 h7 y38a2 ff1 fs3 fc0 sc0 ls0 ws14">受一个正确类型的指针。参考下一节关于 <span class="ff4 wsba">Cython </span>内存视图的更高级讲述。</div><div class="t m0 x0 h9 y38a3 ff1 fs3 fc0 sc0 ls0 wsa0">除了处理<span class="_ _6"></span>通常的数组<span class="_ _6"></span>外，<span class="ff6 ws9a1">avg() </span><span class="ls51 ws1c8">的这个例子还展示了如何处理全局解释器锁。语句</span></div><div class="t m0 x5 h7 y38a4 ff6 fs3 fc0 sc0 ls0 ws14e0">with<span class="_ _11"> </span>nogil: <span class="ff1 ws14e1">声明<span class="_ _6"></span>了一个<span class="_ _6"></span>不需要 <span class="ff4 ws1135">GIL </span><span class="ls2c ws12f">就能执行的代码块。在这个块中，不能有任何的<span class="_ _1"></span></span></span></div><div class="t m0 x5 h7 y38a5 ff1 fs3 fc0 sc0 ls0 ws1372">普通 <span class="ff4 ws10c">Python </span><span class="ls3d ws14e2">对象—<span class="_ _8"></span>—只能使用被声明为 <span class="ff6 ls0 ws179">cdef <span class="ff1 wsa0">的对<span class="_ _6"></span>象和<span class="_ _6"></span>函数。另<span class="_ _6"></span>外，外<span class="_ _6"></span>部函数<span class="_ _6"></span>必须现</span></span></span></div><div class="t m0 x5 h7 y38a6 ff1 fs3 fc0 sc0 ls10 ws14e3">实的声明它们能不依赖 <span class="ff4 ls0 ws1128">GIL <span class="ff1 ws14e4">就<span class="_ _6"></span>能执<span class="_ _6"></span>行。<span class="_ _6"></span>因<span class="_ _6"></span>此，在 </span><span class="ws14e5">csample.pxd <span class="ff1 wsa0">文件<span class="_ _6"></span>中，<span class="_ _6"></span><span class="ff6 ws149">avg() </span></span></span></span><span class="wsdf">被声明</span></div><div class="t m0 x5 h7 y38a7 ff1 fs3 fc0 sc0 ls4">为<span class="ff6 ls0 ws4">double avg(double *, int) nogil<span class="_ _16"> </span><span class="ff4">.</span></span></div><div class="t m0 x0 h7 y38a8 ff1 fs3 fc0 sc0 ls111">对<span class="ff4 ls0 ws14e6">P<span class="_ _1"></span>oin<span class="_ _1"></span>t <span class="ff1 ls68 ws14e7">结构体的处理是一个挑战。本节使用胶囊对象将 </span>Poin<span class="_ _c"></span>t <span class="ff1 wsa0">对象当<span class="_ _6"></span>做隐形指针</span></span></div><div class="t m0 x5 h7 y38a9 ff1 fs3 fc0 sc0 ls0 ws14e8">来<span class="_ _6"></span>处<span class="_ _6"></span>理，<span class="_ _0"></span>这<span class="_ _6"></span>个<span class="_ _6"></span>在 <span class="ff4 ws14e9">15.4 </span><span class="ws14ea">小<span class="_ _6"></span>节<span class="_ _6"></span>介<span class="_ _0"></span>绍<span class="_ _6"></span>过。<span class="_ _6"></span>要<span class="_ _6"></span>这<span class="_ _6"></span>样<span class="_ _0"></span>做<span class="_ _6"></span>的<span class="_ _6"></span>话，<span class="_ _6"></span>底<span class="_ _0"></span>层 <span class="ff4 ws14eb">Cython </span><span class="wsa0">代码<span class="_ _0"></span>稍<span class="_ _6"></span>微<span class="_ _6"></span>有<span class="_ _6"></span>点<span class="_ _6"></span>复<span class="_ _0"></span>杂。</span></span></div><div class="t m0 x5 h7 y38aa ff1 fs3 fc0 sc0 ls0 ws38">首先，下面的导入被用来引入 <span class="ff4 ls8">C</span><span class="ws14">函数库和 <span class="ff4 ws9c">Python C API </span>中定义的函数：</span></div><div class="t m0 x5 hf y1448 ff8 fs5 fc0 sc0 ls0 ws4">from cpython.pycapsule cimport *</div><div class="t m0 x5 hf y1c39 ff8 fs5 fc0 sc0 ls0 ws4">from libc.stdlib cimport malloc, free</div><div class="t m0 x0 h9 y5a1 ff1 fs3 fc0 sc0 ls0 ws14ec">函<span class="_ _0"></span>数 <span class="ff6 ws196">del Point()<span class="_ _18"> </span></span><span class="ls28e">和</span><span class="ff6 ws14ed">Point() </span><span class="ls20c ws1167">使用这个功能来创建一个胶囊对象<span class="_ _c"></span>，它会包装一<span class="_ _d"></span></span></div><div class="t m0 x5 h9 y38ab ff1 fs3 fc0 sc0 ls28f">个<span class="ff6 ls0 ws14ee">Point<span class="_ _40"> </span>* </span><span class="ls0 wsa0">指<span class="_ _12"></span>针。<span class="_ _0"></span><span class="ff6 ws14ef">cdef<span class="_ _e"> </span>del Point()<span class="_ _b"> </span></span></span>将<span class="ff6 ls0 ws5e3">del Point()<span class="_ _1e"> </span></span><span class="ls87 ws316">声明为一个函数<span class="_ _d"></span>，只能通过<span class="_ _d"></span></span></div><div class="t m0 x5 h7 y38ac ff4 fs3 fc0 sc0 ls0 ws14f0">Cython <span class="ff1 ws14f1">访<span class="_ _0"></span>问，<span class="_ _6"></span>而<span class="_ _0"></span>不<span class="_ _0"></span>能<span class="_ _0"></span>从 </span><span class="ws14f2">Python <span class="ff1 wsa0">中<span class="_ _6"></span>访<span class="_ _0"></span>问。<span class="_ _0"></span>因<span class="_ _0"></span>此，<span class="_ _0"></span>这<span class="_ _6"></span>个<span class="_ _0"></span>函<span class="_ _0"></span>数<span class="_ _0"></span>对<span class="_ _6"></span>外<span class="_ _0"></span>部<span class="_ _0"></span>是<span class="_ _0"></span>不<span class="_ _6"></span>可<span class="_ _0"></span>见<span class="_ _0"></span>的<span class="_ _6"></span>—<span class="_ _d"></span>—<span class="_ _0"></span>它</span></span></div><div class="t m0 x5 h9 y38ad ff1 fs3 fc0 sc0 ls1d ws14f3">被用来当做一个回调函数来清理胶囊分配的内存<span class="_ _c"></span>。函数调用比如 <span class="ff6 ls0 wsc64">PyCapsule New()<span class="_ _18"> </span><span class="ff1">、</span></span></div><div class="t m0 x5 h7 y38ae ff6 fs3 fc0 sc0 ls0 ws1dc">PyCapsule<span class="_ _7"> </span>GetPointer() <span class="ff1 wsc">直接来自 <span class="ff4 ws9c">Python C API </span>并且以同样的方式被使用。</span></div><div class="t m0 x0 h9 y38af ff6 fs3 fc0 sc0 ls0 wsfc3">distance <span class="ff1 ws65e">函数<span class="_ _6"></span>从 </span><span class="ws14f4">Point() <span class="ff1 ls42 ws186">创建的胶囊对象中提取指针。这里要注意的是你不需要<span class="_ _1"></span></span></span></div><div class="t m0 x5 h9 y38b0 ff1 fs3 fc0 sc0 ls3d ws164">担心异常处理。如果一个错误的对象被传进来<span class="_ _1"></span>，<span class="ff6 ls0 ws14f5">PyCapsule<span class="_ _7"> </span>GetPointer() </span>会抛出一个</div><div class="t m0 x5 h7 y38b1 ff1 fs3 fc0 sc0 ls0 ws38">异常，但是 <span class="ff4 wsba">Cython </span><span class="ws63">已经知道怎么查找到它，并将它从 <span class="ff6 ws17c">distance() </span>传递出去。</span></div><div class="t m0 x0 h7 y38b2 ff1 fs3 fc0 sc0 ls0 ws14f6">处理 <span class="ff4 ws14f7">P<span class="_ _1"></span>oin<span class="_ _1"></span>t <span class="ff1 ls82 ws2f9">结构体一个缺点是它的实现是不可见的。你不能访问任何属性来查看它</span></span></div><div class="t m0 x5 h9 y38b3 ff1 fs3 fc0 sc0 ls0">的内部。这里有另外一种方法去包装它，就是定义一个扩展类型，如下所示：</div><div class="t m0 x5 hf y38b4 ff8 fs5 fc0 sc0 ls0 ws4"># sample.pyx</div><div class="t m0 x5 hf y38b5 ff8 fs5 fc0 sc0 ls0 ws4">cimport csample</div><div class="t m0 x5 hf y38b6 ff8 fs5 fc0 sc0 ls0 ws4">from libc.stdlib cimport malloc, free</div><div class="t m0 x5 hf y38b7 ff8 fs5 fc0 sc0 ls0">...</div><div class="t m0 x5 hf y38b8 ff8 fs5 fc0 sc0 ls0 ws4">cdef class Point:</div><div class="t m0 x15 hf y38b9 ff8 fs5 fc0 sc0 ls0 ws13b">cdef csample.Point *_c_point</div><div class="t m0 x15 hf y38ba ff8 fs5 fc0 sc0 ls0 ws4">def __cinit__(self, double x, double y):</div><div class="t m0 x16 hf y38bb ff8 fs5 fc0 sc0 ls0 ws4">self._c_point = &lt;csample.Point *&gt; malloc(sizeof(csample.Point))</div><div class="t m0 x16 hf y38bc ff8 fs5 fc0 sc0 ls0 ws13b">self._c_point.x = x</div><div class="t m0 x16 hf y38bd ff8 fs5 fc0 sc0 ls0 ws13b">self._c_point.y = y</div><div class="t m0 x15 hf y38be ff8 fs5 fc0 sc0 ls0 ws13b">def __dealloc__(self):</div><div class="t m0 x16 hf y38bf ff8 fs5 fc0 sc0 ls0">free(self._c_point)</div><div class="t m0 x15 hf y38c0 ff8 fs5 fc0 sc0 ls0 ws13b">property x:</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 wsd97">17.10.<span class="_ _36"> </span>15.10 <span class="ff1 ls7f">用</span><span class="ws747">Cython <span class="ff1 ws16b">包装 </span><span class="ls246">C</span><span class="ff1 ws14a7">代码 </span>580</span></div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
