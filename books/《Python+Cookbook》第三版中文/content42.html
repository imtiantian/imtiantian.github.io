<div id="pf2a" class="pf w0 h0" data-page-no="2a"><div class="pc pc2a w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg2a.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 he y137 ff2 fs2 fc4 sc0 ls0 ws212">3.17.3 <span class="ff1">讨论</span></div><div class="t m0 x0 h9 y236 ff1 fs3 fc0 sc0 ls3d ws2a5">大多数情况下字典推导能做到的，通过创建一个元组序列然后把它传给 <span class="ff6 ls0 ws20b">dict() <span class="ff1">函</span></span></div><div class="t m0 x5 h9 y237 ff1 fs3 fc0 sc0 ls0">数也能实现。比如：</div><div class="t m0 x5 hf y374 ff8 fs5 fc0 sc0 ls0 ws159">p1 <span class="fc6 ls33">=</span><span class="fca ws13a">dict</span><span class="ws13b">((key, value) <span class="ff7 fca ws139">for </span>key, value <span class="ff7 fca ws157">in </span><span class="ws13a">prices<span class="fc6 ls34">.</span><span class="ws155">items() <span class="ff7 fca ws157">if </span><span class="ws15f">value <span class="fc6 ls33">&gt;</span></span></span><span class="fc7">200</span>)</span></span></div><div class="t m0 x0 h7 y450 ff1 fs3 fc0 sc0 ls6f ws2a6">但是<span class="_ _1"></span>，字典推导方式表意更清晰<span class="_ _1"></span>，并且实际上也会运行的更快些 <span class="ff4 ls0 wsa5">(</span><span class="ws2a7">在这个例子中，<span class="_ _c"></span></span></div><div class="t m0 x5 h7 y451 ff1 fs3 fc0 sc0 ls0 ws38">实际测试几乎比 <span class="ff6 ws25d">dcit() </span><span class="wsa0">函数方式快整整一倍<span class="ff4 wsa5">)</span>。</span></div><div class="t m0 x0 h9 y452 ff1 fs3 fc0 sc0 ls0">有时候完成同一件事会有多种方式。比如，第二个例子程序也可以像这样重写：</div><div class="t m0 x5 h11 y453 ffa fs5 fcd sc0 ls0 ws4"># Make a dictionary of tech stocks</div><div class="t m0 x5 hf y454 ff8 fs5 fc0 sc0 ls0 ws2a3">tech_names <span class="fc6 ls32">=</span><span class="ls33">{<span class="ff9 fc9 ls34">&apos;</span></span><span class="fc9 ws13a">AAPL<span class="ff9 ws13b">&apos;</span></span><span class="ls33">,</span><span class="ff9 fc9 ws13b">&apos;<span class="ff8 ws13a">IBM</span>&apos;</span><span class="ls33">,<span class="ff9 fc9 ls34">&apos;</span></span><span class="fc9 ws13a">HPQ<span class="ff9 ws13b">&apos;</span></span><span class="ls33">,<span class="ff9 fc9 ls34">&apos;</span></span><span class="fc9 ws13a">MSFT<span class="ff9 ls32">&apos;</span></span>}</div><div class="t m0 x5 hf y455 ff8 fs5 fc0 sc0 ls0 ws159">p2 <span class="fc6 ls33">=</span><span class="ws13b">{ key:prices[key] <span class="ff7 fca ws139">for </span><span class="ws158">key <span class="ff7 fca ws157">in </span><span class="ws13a">prices<span class="fc6 ls34">.</span><span class="ws145">keys() <span class="fc6 ls32">&amp;</span><span class="ws4">tech_names }</span></span></span></span></span></div><div class="t m0 x0 h7 y456 ff1 fs3 fc0 sc0 ls68 ws2a8">但是，运行时间测试结果显示这种方案大概比第一种方案慢 <span class="ff4 ls0 ws2a9">1.6 <span class="ff1 wsa0">倍。如果对<span class="_ _6"></span>程序运</span></span></div><div class="t m0 x5 h9 y457 ff1 fs3 fc0 sc0 ls0 wsa0">行<span class="_ _6"></span>性能<span class="_ _6"></span>要<span class="_ _6"></span>求<span class="_ _6"></span>比<span class="_ _6"></span>较<span class="_ _6"></span>高的<span class="_ _6"></span>话，<span class="_ _6"></span>需<span class="_ _6"></span>要<span class="_ _6"></span>花<span class="_ _6"></span>点时<span class="_ _6"></span>间<span class="_ _6"></span>去<span class="_ _6"></span>做<span class="_ _6"></span>计<span class="_ _6"></span>时测<span class="_ _6"></span>试。<span class="_ _6"></span>关<span class="_ _6"></span>于<span class="_ _6"></span>更<span class="_ _6"></span>多<span class="_ _6"></span>计时<span class="_ _6"></span>和<span class="_ _6"></span>性<span class="_ _6"></span>能<span class="_ _6"></span>测<span class="_ _6"></span>试，可</div><div class="t m0 x5 h7 y458 ff1 fs3 fc0 sc0 ls0 ws38">以参考 <span class="ff4 ws2aa">14.13 </span>小节</div><div class="t m0 x5 hd y459 ff2 fs4 fc4 sc0 ls0 ws211">3.18<span class="_ _e"> </span>1.18 <span class="ff1">映射名称到序列元素</span></div><div class="t m0 x5 he y45a ff2 fs2 fc4 sc0 ls0 ws212">3.18.1 <span class="ff1">问题</span></div><div class="t m0 x0 h9 y45b ff1 fs3 fc0 sc0 ls3a ws153">你有一段通过下标访问列表或者元组中元素的代码，但是这样有时候会使得你的代</div><div class="t m0 x5 h9 y45c ff1 fs3 fc0 sc0 ls0">码难以阅读，于是你想通过名称来访问元素。</div><div class="t m0 x5 he y45d ff2 fs2 fc4 sc0 ls0 ws212">3.18.2 <span class="ff1">解决方案</span></div><div class="t m0 x0 h9 y45e ff6 fs3 fc0 sc0 ls0 ws2ab">collections.namedtuple() <span class="ff1 ls6b ws28f">函数通过使用一个普通的元组对象来帮你解决这个问<span class="_ _1"></span></span></div><div class="t m0 x5 h7 y45f ff1 fs3 fc0 sc0 ls0 ws12a">题。这个函数实际上是一个返回 <span class="ff4 ws12b">Python </span><span class="wsa0">中标准元组类型子类的一个工厂方法。<span class="_ _1"></span>你需要</span></div><div class="t m0 x5 h9 y460 ff1 fs3 fc0 sc0 ls2c ws12f">传递一个类型名和你需要的字段给它，然后它就会返回一个类，你可以初<span class="_ _1"></span>始化这个类，</div><div class="t m0 x5 h9 y461 ff1 fs3 fc0 sc0 ls0">为你定义的字段传递值等。代码示例：</div><div class="t m0 x5 hf y462 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="fca ws15a">from <span class="fcc ws168">collections </span><span class="ws146">import <span class="ff8 fc0">namedtuple</span></span></span></div><div class="t m0 x5 hf y463 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws2a3">Subscriber <span class="fc6 ls32">=</span><span class="ws13a">namedtuple(<span class="ff9 fc9 ls34">&apos;</span><span class="fc9">Subscriber<span class="ff9 ls34">&apos;</span></span><span class="ws4">, [<span class="ff9 fc9 ls34">&apos;</span></span><span class="fc9">addr<span class="ff9 ls34">&apos;</span></span><span class="ls32">,<span class="ff9 fc9 ls34">&apos;</span></span><span class="fc9">joined<span class="ff9 ls34">&apos;</span></span>])</span></span></div><div class="t m0 x5 hf y464 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws158">sub <span class="fc6 ls32">=</span><span class="ws13a">Subscriber(<span class="ff9 fc9 ls34">&apos;</span><span class="fc9">jonesy@example.com<span class="ff9 ls34">&apos;</span></span><span class="ls32">,<span class="ff9 fc9 ls34">&apos;</span></span><span class="fc9">2012-10-19<span class="ff9 ls34">&apos;</span></span>)</span></span></div><div class="t m0 x5 hf y465 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0">sub</span></div><div class="t m0 x5 hf y466 ff8 fs5 fc8 sc0 ls0 ws13a">Subscriber(addr=<span class="ff9 ws13b">&apos;</span>jonesy@example.com<span class="ff9 ls34">&apos;</span><span class="ws4">, joined=<span class="ff9 ws13b">&apos;</span></span>2012-10-19<span class="ff9 ws13b">&apos;</span>)</div><div class="t m0 x5 hf y467 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws13a">sub<span class="fc6 ls34">.</span>addr</span></div><div class="t m0 x5 hf y468 ff9 fs5 fc8 sc0 ls34">&apos;<span class="ff8 ls0 ws13a">jonesy@example.com<span class="ff9">&apos;</span></span></div><div class="t m0 x5 hf y469 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws13a">sub<span class="fc6 ls34">.</span>joined</span></div><div class="t m0 x5 hf y46a ff9 fs5 fc8 sc0 ls34">&apos;<span class="ff8 ls0 ws13a">2012-10-19<span class="ff9">&apos;</span></span></div><div class="t m0 x5 hf y46b ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h9 y46c ff1 fs3 fc0 sc0 ls0 ws2ac">尽管 <span class="ff6 ws141">namedtuple </span><span class="ls18 ws110">的实例看起来像一个普通的类实例，但是它跟元组类型是可交换</span></div><div class="t m0 x5 h9 y46d ff1 fs3 fc0 sc0 ls0">的，支持所有的普通元组操作，比如索引和解压。比如：</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 ws21d">3.18.<span class="_ _5"> </span>1.18 <span class="ff1 ws2ad">映射名称到序列元素 </span>33</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
