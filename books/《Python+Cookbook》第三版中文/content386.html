<div id="pf182" class="pf w0 h0" data-page-no="182"><div class="pc pc182 w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg182.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 h10 y334 ff7 fs5 fca sc0 ls0 ws146">import <span class="fcc">importlib</span></div><div class="t m0 x5 h11 y335 ffa fs5 fcd sc0 ls0 ws4"># Same as <span class="ffb ls34">&apos;</span>from . import b<span class="ffb">&apos;</span></div><div class="t m0 x5 hf y336 ff8 fs5 fc0 sc0 ls32">b<span class="fc6 ls33">=</span><span class="ls0 ws13a">importlib<span class="fc6 ls34">.</span>import_module(<span class="ff9 fc9 ls34">&apos;</span><span class="fc9">.b<span class="ff9 ws13b">&apos;</span></span><span class="ws4">, __package__)</span></span></div><div class="t m0 x5 he y27bc ff2 fs2 fc4 sc0 ls0 wsadf">12.10.3 <span class="ff1">讨论</span></div><div class="t m0 x0 h7 y27bd ff1 fs3 fc0 sc0 ls0 ws2ac">使用 <span class="ff4 wsd99">imp<span class="_ _6"></span>ort<span class="_ _7"> </span>mo<span class="_ _6"></span>dule() </span><span class="ls18 ws110">手动导入模块的问题通常出现在以某种方式编写修改或覆盖</span></div><div class="t m0 x5 h9 y27be ff1 fs3 fc0 sc0 ls1e ws111">模块的代码时候<span class="_ _1"></span>。例如，也许你正在<span class="_ _1"></span>执行某种自定义导入机制，需要通过名称来<span class="_ _1"></span>加载</div><div class="t m0 x5 h9 y27bf ff1 fs3 fc0 sc0 ls0">一个模块，通过补丁加载代码。</div><div class="t m0 x0 h7 y27c0 ff1 fs3 fc0 sc0 ls0 wsd9a">在旧的代码，有时你会看到用于导入的内建函数 <span class="ff4 wsd9b">import ()</span><span class="wsa0">。尽管它能工作，但是</span></div><div class="t m0 x5 h7 y27c1 ff4 fs3 fc0 sc0 ls0 wsd9c">imp<span class="_ _6"></span>ortlib.imp<span class="_ _6"></span>ort<span class="_ _7"> </span>module() <span class="ff1">通常更容易使用。</span></div><div class="t m0 x0 h7 y27c2 ff1 fs3 fc0 sc0 ls0 ws38">自定义导入过程的高级实例见 <span class="ff4 ws2aa">10.11 </span>小节</div><div class="t m0 x5 hd y27c3 ff2 fs4 fc4 sc0 ls0 wsd91">12.11<span class="_ _e"> </span>10.11 <span class="ff1">通过钩子远程加载模块</span></div><div class="t m0 x5 he y27c4 ff2 fs2 fc4 sc0 ls0 wsadf">12.11.1 <span class="ff1">问题</span></div><div class="t m0 x0 h7 y27c5 ff1 fs3 fc0 sc0 ls0 ws38">你想自定义 <span class="ff4 ws5c">Python </span><span class="ls4">的</span><span class="ff4 wscf1">imp<span class="_ _6"></span>ort </span>语句，使得它能从远程机器上面透明的加载模块。</div><div class="t m0 x5 he y27c6 ff2 fs2 fc4 sc0 ls0 wsadf">12.11.2 <span class="ff1">解决方案</span></div><div class="t m0 x0 h9 y27c7 ff1 fs3 fc0 sc0 ls3a ws153">首先要提出来的是安全问题。本届讨论的思想如果没有一些额外的安全和认知机制</div><div class="t m0 x5 h7 y27c8 ff1 fs3 fc0 sc0 ls0 wsd9d">的<span class="_ _6"></span>话<span class="_ _6"></span>会<span class="_ _6"></span>很<span class="_ _6"></span>糟<span class="_ _6"></span>糕。<span class="_ _0"></span>也就<span class="_ _6"></span>是<span class="_ _0"></span>说，我<span class="_ _6"></span>们<span class="_ _0"></span>的主<span class="_ _0"></span>要目<span class="_ _6"></span>的<span class="_ _0"></span>是深<span class="_ _6"></span>入<span class="_ _0"></span>分析 <span class="ff4 wsd9e">Python </span><span class="ls9a">的</span><span class="ff4 wsd9f">imp<span class="_ _6"></span>ort </span><span class="wsa0">语<span class="_ _6"></span>句<span class="_ _0"></span>机制。</span></div><div class="t m0 x5 h7 y27c9 ff1 fs3 fc0 sc0 lsf wsda0">如果你理解了本节内部原理<span class="_ _1"></span>，你就能够为其他任何目的而自定义 <span class="ff4 ls0 wsa5">imp<span class="_ _6"></span>ort<span class="ff1 wsa0">。<span class="_ _6"></span>有<span class="_ _0"></span>了这<span class="_ _0"></span>些，</span></span></div><div class="t m0 x5 h9 y27ca ff1 fs3 fc0 sc0 ls0">让我们继续向前走。</div><div class="t m0 x0 h9 y27cb ff1 fs3 fc0 sc0 ls3a ws153">本节核心是设计导入语句的扩展功能。有很多种方法可以做这个，不过为了演示的</div><div class="t m0 x5 h7 y27cc ff1 fs3 fc0 sc0 ls0 ws14">方便，我们开始先构造下面这个 <span class="ff4 ws5c">Python </span>代码结构：</div><div class="t m0 x5 hf y27cd ff8 fs5 fc0 sc0 ls0">testcode/</div><div class="t m0 x15 hf y27ce ff8 fs5 fc0 sc0 ls0">spam.py</div><div class="t m0 x15 hf y27cf ff8 fs5 fc0 sc0 ls0">fib.py</div><div class="t m0 x15 hf y27d0 ff8 fs5 fc0 sc0 ls0">grok/</div><div class="t m0 x16 hf y27d1 ff8 fs5 fc0 sc0 ls0">__init__.py</div><div class="t m0 x16 hf y27d2 ff8 fs5 fc0 sc0 ls0">blah.py</div><div class="t m0 x0 h9 y27d3 ff1 fs3 fc0 sc0 ls22 ws119">这些文件的内容并不重要，不过我们在每个文件中放入了少量的简单语句和函数<span class="_ _1"></span>，</div><div class="t m0 x5 h9 y83c ff1 fs3 fc0 sc0 ls0">这样你可以测试它们并查看当它们被导入时的输出。例如：</div><div class="t m0 x5 h11 y27d4 ffa fs5 fcd sc0 ls0 ws4"># spam.py</div><div class="t m0 x5 hf y27d5 ff7 fs5 fca sc0 ls0 ws156">print<span class="ff8 fc0 ws13a">(<span class="fc9 ls34">&quot;I<span class="ff9">&apos;</span><span class="ls0 ws13b">m spam&quot;</span></span>)</span></div><div class="t m0 x5 hf y27d6 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">hello<span class="fc0">(name):</span></span></div><div class="t m0 x15 hf y27d7 ff7 fs5 fca sc0 ls0 ws156">print<span class="ff8 fc0 ws13a">(<span class="ff9 fc9 ls34">&apos;</span><span class="fc9 ws15f">Hello </span><span class="ffa fcf">%s<span class="ff9 fc9 ls32">&apos;</span></span><span class="fc6 ls33">%</span>name)</span></div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 wsd97">12.11.<span class="_ _5"> </span>10.11 <span class="ff1 wsd98">通过钩子远程加载模块 </span>377</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
