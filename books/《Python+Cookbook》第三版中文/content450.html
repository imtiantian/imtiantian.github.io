<div id="pf1c2" class="pf w0 h0" data-page-no="1c2"><div class="pc pc1c2 w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg1c2.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 hf yb1e ff8 fs5 fc6 sc0 ls0 ws1a1">&gt;&gt;&gt; <span class="ff7 fca ws146">import <span class="fcc">numpy</span></span></div><div class="t m0 x5 hf yb1f ff8 fs5 fc6 sc0 ls0 ws1a1">&gt;&gt;&gt; <span class="fc0 ls32">a</span><span class="ls33">=</span><span class="fc0 ws13a">numpy</span><span class="ls34">.</span><span class="fc0 ws13a">zeros(shape</span><span class="ls34">=</span><span class="fc7 ws13a">50000000<span class="fc0 ws13b">, dtype</span></span><span class="ls34">=</span><span class="fca ws13a">float<span class="fc0">)</span></span></div><div class="t m0 x5 hf yb20 ff8 fs5 fc6 sc0 ls0 ws1a1">&gt;&gt;&gt; <span class="fc0 ws13a">a[<span class="fc7 ls34">0<span class="fc0">:</span><span class="ls0">10</span></span>]</span></div><div class="t m0 x5 hf yb21 ff8 fs5 fc0 sc0 ls0 ws155">array([ <span class="fc7 ws13a">0.</span><span class="lscf">,</span><span class="fc7 ws13a">0.</span><span class="lscf">,</span><span class="fc7 ws13a">0.</span><span class="lscf">,</span><span class="fc7 ws13a">0.</span><span class="lscf">,</span><span class="fc7 ws13a">0.</span><span class="lscf">,</span><span class="fc7 ws13a">0.</span><span class="ls1f7">,</span><span class="fc7 ws13a">0.</span><span class="lscf">,</span><span class="fc7 ws13a">0.</span><span class="lscf">,</span><span class="fc7 ws13a">0.</span><span class="ls1f7">,</span><span class="fc7 ws13a">0.</span>])</div><div class="t m0 x5 hf yb22 ff8 fs5 fc6 sc0 ls0 ws1a1">&gt;&gt;&gt; <span class="fc0 ws13b">recv_into(a, c)</span></div><div class="t m0 x5 hf yb23 ff8 fs5 fc6 sc0 ls0 ws1a1">&gt;&gt;&gt; <span class="fc0 ws13a">a[<span class="fc7 ls34">0<span class="fc0">:</span><span class="ls0">10</span></span>]</span></div><div class="t m0 x5 hf yb24 ff8 fs5 fc0 sc0 ls0 ws155">array([ <span class="fc7 ws13a">0.</span><span class="lscf">,</span><span class="fc7 ws13a">1.</span><span class="lscf">,</span><span class="fc7 ws13a">2.</span><span class="lscf">,</span><span class="fc7 ws13a">3.</span><span class="lscf">,</span><span class="fc7 ws13a">4.</span><span class="lscf">,</span><span class="fc7 ws13a">5.</span><span class="ls1f7">,</span><span class="fc7 ws13a">6.</span><span class="lscf">,</span><span class="fc7 ws13a">7.</span><span class="lscf">,</span><span class="fc7 ws13a">8.</span><span class="ls1f7">,</span><span class="fc7 ws13a">9.</span>])</div><div class="t m0 x5 hf yb25 ff8 fs5 fc6 sc0 ls0 ws13a">&gt;&gt;&gt;</div><div class="t m0 x5 he y2d65 ff2 fs2 fc4 sc0 ls0 wsadf">13.13.3 <span class="ff1">讨论</span></div><div class="t m0 x0 h7 y2d66 ff1 fs3 fc0 sc0 ls22 ws119">在数据密集型分布式计算和平行计算程序中，自己写程序来实现发送<span class="_ _1"></span><span class="ff4 ls6">/<span class="ff1 ls22">接受大量数</span></span></div><div class="t m0 x5 h9 y5ba ff1 fs3 fc0 sc0 ls0 wsa0">据<span class="_ _6"></span>并<span class="_ _0"></span>不<span class="_ _6"></span>常<span class="_ _6"></span>见。<span class="_ _0"></span>不<span class="_ _6"></span>过，<span class="_ _6"></span>要<span class="_ _0"></span>是<span class="_ _6"></span>你<span class="_ _6"></span>确<span class="_ _0"></span>实<span class="_ _6"></span>想<span class="_ _6"></span>这<span class="_ _0"></span>样<span class="_ _6"></span>做，<span class="_ _6"></span>你<span class="_ _0"></span>可<span class="_ _6"></span>能<span class="_ _6"></span>需<span class="_ _0"></span>要<span class="_ _6"></span>将<span class="_ _0"></span>你<span class="_ _6"></span>的<span class="_ _6"></span>数<span class="_ _0"></span>据<span class="_ _6"></span>转<span class="_ _6"></span>换<span class="_ _0"></span>成<span class="_ _6"></span>原<span class="_ _6"></span>始<span class="_ _0"></span>字<span class="_ _6"></span>节，</div><div class="t m0 x5 h9 y2d67 ff1 fs3 fc0 sc0 ls13 wse5">以便给低层的网络函数使用<span class="_ _1"></span>。你可能还需要将数据切割成多个块，因为大部分和网络<span class="_ _c"></span></div><div class="t m0 x5 h9 y2d68 ff1 fs3 fc0 sc0 ls0">相关的函数并不能一次性发送或接受超大数据块。</div><div class="t m0 x0 h9 y2d69 ff1 fs3 fc0 sc0 ls0 wsa0">一<span class="_ _6"></span>种方<span class="_ _6"></span>法<span class="_ _6"></span>是<span class="_ _6"></span>使用<span class="_ _6"></span>某<span class="_ _6"></span>种<span class="_ _6"></span>机<span class="_ _6"></span>制序<span class="_ _6"></span>列<span class="_ _6"></span>化<span class="_ _6"></span>数<span class="_ _6"></span>据—<span class="_ _d"></span>—<span class="_ _6"></span>可能<span class="_ _6"></span>将<span class="_ _6"></span>其<span class="_ _6"></span>转<span class="_ _6"></span>换成<span class="_ _6"></span>一<span class="_ _6"></span>个<span class="_ _6"></span>字<span class="_ _6"></span>节字<span class="_ _6"></span>符<span class="_ _6"></span>串。<span class="_ _6"></span>不<span class="_ _6"></span>过，</div><div class="t m0 x5 h9 y2d6a ff1 fs3 fc0 sc0 ls13 wse5">这样最终会创建数据的一个复制<span class="_ _1"></span>。就算你只是零碎的做这些，你的代码最终还是会有<span class="_ _c"></span></div><div class="t m0 x5 h9 y2d6b ff1 fs3 fc0 sc0 ls0">大量的小型复制操作。</div><div class="t m0 x0 h9 y2d6c ff1 fs3 fc0 sc0 ls3a ws153">本节通过使用内存视图展示了一些魔法操作。本质上，一个内存视图就是一个已存</div><div class="t m0 x5 h9 y2d6d ff1 fs3 fc0 sc0 ls13 wse5">在数组的覆盖层<span class="_ _1"></span>。不仅仅是那样，内存视图还能以不同的方式转换成不同类型来表现<span class="_ _c"></span></div><div class="t m0 x5 h9 y2d6e ff1 fs3 fc0 sc0 ls0">数据。这个就是下面这个语句的目的：</div><div class="t m0 x5 hf y2d6f ff8 fs5 fc0 sc0 ls0 ws13c">view <span class="fc6 ls32">=</span><span class="ws13a">memoryview(arr)<span class="fc6 ls34">.</span>cast(<span class="ff9 fc9 ls34">&apos;<span class="ff8">B</span>&apos;</span>)</span></div><div class="t m0 x0 h7 y26de ff1 fs3 fc0 sc0 ls68 ws440">它接受一个数组 <span class="ff4 ls0 ws2a9">arr </span><span class="ws23f">并将其转换为一个无符号字节的内存视图。这个视图能被传递</span></div><div class="t m0 x5 h7 y2d70 ff1 fs3 fc0 sc0 ls125">给<span class="ff4 ls0 ws104d">so<span class="_ _6"></span>c<span class="_ _1"></span>k<span class="_ _1"></span>et <span class="ff1 ls22 ws104e">相关函数，比如 </span><span class="ff6 ws104f">socket.send() <span class="ff1 ls125">或</span><span class="ws3cf">send.recv into() <span class="ff1 wsa0">。在<span class="_ _6"></span>内部，<span class="_ _6"></span>这<span class="_ _6"></span>些方<span class="_ _6"></span>法</span></span></span></span></div><div class="t m0 x5 h9 y943 ff1 fs3 fc0 sc0 ls0 wsa0">能<span class="_ _6"></span>够<span class="_ _6"></span>直<span class="_ _6"></span>接操<span class="_ _6"></span>作<span class="_ _6"></span>这<span class="_ _6"></span>个<span class="_ _6"></span>内<span class="_ _6"></span>存<span class="_ _6"></span>区<span class="_ _6"></span>域。<span class="_ _6"></span>例<span class="_ _6"></span>如，<span class="_ _6"></span><span class="ff6 ws1050">sock.send() </span><span class="ls48 ws242">直接从内存中发生数据而不需要复</span></div><div class="t m0 x5 h9 y1c3a ff1 fs3 fc0 sc0 ls0 ws14">制。 <span class="ff6 ws25d">send.recv<span class="_ _7"> </span>into() </span>使用这个内存区域作为接受操作的输入缓冲区。</div><div class="t m0 x0 h7 y2cf2 ff1 fs3 fc0 sc0 ls14 ws1051">剩下的一个难点就是 <span class="ff4 ls0 ws1052">so<span class="_ _6"></span>c<span class="_ _1"></span>k<span class="_ _1"></span>et <span class="ff1 ls14 ws174">函数可能只操作部分数据<span class="_ _1"></span>。通常来讲，我们得使用很<span class="_ _c"></span></span></span></div><div class="t m0 x5 h9 y2d71 ff1 fs3 fc0 sc0 ls0 wse52">多不同的 <span class="ff6 ws1053">send() </span><span class="ls1f8">和</span><span class="ff6 ws1053">recv<span class="_ _7"> </span>into() </span><span class="wsa0">来传输整个数组。<span class="_ _1"></span>不用担心，每次操作后，<span class="_ _c"></span>视图会通</span></div><div class="t m0 x5 h9 y2d72 ff1 fs3 fc0 sc0 ls0 wsa0">过<span class="_ _6"></span>发送<span class="_ _6"></span>或<span class="_ _6"></span>接<span class="_ _6"></span>受<span class="_ _6"></span>字<span class="_ _6"></span>节数<span class="_ _6"></span>量<span class="_ _6"></span>被<span class="_ _6"></span>切<span class="_ _6"></span>割<span class="_ _6"></span>成新<span class="_ _6"></span>的<span class="_ _6"></span>视<span class="_ _6"></span>图。<span class="_ _6"></span>新<span class="_ _6"></span>的视<span class="_ _6"></span>图<span class="_ _6"></span>同<span class="_ _6"></span>样<span class="_ _6"></span>也<span class="_ _6"></span>是内<span class="_ _6"></span>存<span class="_ _6"></span>覆<span class="_ _6"></span>盖<span class="_ _6"></span>层。<span class="_ _6"></span>因<span class="_ _6"></span>此，还</div><div class="t m0 x5 h9 y2d73 ff1 fs3 fc0 sc0 ls0">是没有任何的复制操作。</div><div class="t m0 x0 h9 y56d ff1 fs3 fc0 sc0 ls63 ws21f">这里有个问题就是接受者必须事先知道有多少数据要被发送<span class="_ _c"></span>，以便它能预分配一<span class="_ _1"></span></div><div class="t m0 x5 h9 y2d74 ff1 fs3 fc0 sc0 ls2c ws12f">个数组或者确保它能将接受的数据放入一个已经存在的数组中。如果没办法知道<span class="_ _1"></span>的话，</div><div class="t m0 x5 h9 y2d75 ff1 fs3 fc0 sc0 ls0">发送者就得先将数据大小发送过来，然后再发送实际的数组数据。</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 wsd97">13.13.<span class="_ _36"> </span>11.13 <span class="ff1 ws104c">发送与接收大型数组 </span>441</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
