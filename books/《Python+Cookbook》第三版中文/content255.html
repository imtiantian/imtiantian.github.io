<div id="pfff" class="pf w0 h0" data-page-no="ff"><div class="pc pcff w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bgff.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x0 h7 y2a ff1 fs3 fc0 sc0 ls0 wsa8d">当你<span class="_ _6"></span>使用 <span class="ff6 ws474">super() </span><span class="wsa0">函<span class="_ _6"></span>数时，<span class="ff4 ws4b8">Python </span><span class="ws6d9">会<span class="_ _6"></span>在 <span class="ff4 wsa8e">MR<span class="_ _1"></span>O <span class="ff1 ls19 ws22a">列表上继续搜索下一个类。只要每</span></span></span></span></div><div class="t m0 x5 h9 y2b ff1 fs3 fc0 sc0 lsfa wsa8f">个重定义的方法统一使用 <span class="ff6 ls0 wsa90">super() </span><span class="ws60c">并只调用它一次<span class="_ _c"></span>，那么控制流最终会遍历完整个<span class="_ _c"></span></span></div><div class="t m0 x5 h7 y2c ff4 fs3 fc0 sc0 ls0 wsa91">MR<span class="_ _1"></span>O <span class="ff1 ls3a ws153">列表，每个方法也只会被调用一次。这也是为什么在第二个例子中你不会调用两</span></div><div class="t m0 x5 h9 y2d ff1 fs3 fc0 sc0 ls4">次<span class="ff6 ls0 ws308">Base.<span class="_ _e"> </span>init<span class="_ _e"> </span>() <span class="ff1">的原因。</span></span></div><div class="t m0 x0 h7 y9a ff6 fs3 fc0 sc0 ls0 ws830">super() <span class="ff1 wsa92">有个令人吃<span class="_ _6"></span>惊的地方是它<span class="_ _6"></span>并不一定去查<span class="_ _6"></span>找某个类在 <span class="ff4 wsa93">MRO </span><span class="ls82 ws2f9">中下一个直接父</span></span></div><div class="t m0 x5 h9 y9b ff1 fs3 fc0 sc0 ls0">类，你甚至可以在一个没有直接父类的类中使用它。例如，考虑如下这个类：</div><div class="t m0 x5 hf y1ba0 ff7 fs5 fca sc0 ls0 ws16a">class <span class="fcc ls34">A</span><span class="ff8 fc0">:</span></div><div class="t m0 x15 hf y1ba1 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">spam<span class="fc0">(<span class="fca">self</span>):</span></span></div><div class="t m0 x16 hf y1ba2 ff7 fs5 fca sc0 ls0 ws156">print<span class="ff8 fc0 ls34">(<span class="ff9 fc9">&apos;<span class="ff8 ls0 ws13a">A.spam</span>&apos;</span><span class="ls0">)</span></span></div><div class="t m0 x16 hf y1ba3 ff8 fs5 fca sc0 ls0 ws13a">super<span class="fc0">()<span class="fc6 ls34">.</span>spam()</span></div><div class="t m0 x0 h9 y1ba4 ff1 fs3 fc0 sc0 ls0">如果你试着直接使用这个类就会出错：</div><div class="t m0 x5 hf y13c4 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls32">a<span class="fc6 ls33">=</span><span class="ls0">A()</span></span></div><div class="t m0 x5 hf y1ba5 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls34">a<span class="fc6 ls0 ws13a">.<span class="fc0">spam()</span></span></span></div><div class="t m0 x5 hf y1ba6 ff8 fs5 fc8 sc0 ls0">A.spam</div><div class="t m0 x5 hf y4d9 ff8 fs5 fce sc0 ls0 ws4">Traceback (most recent call last):</div><div class="t m0 x15 hf y4da ff8 fs5 fc0 sc0 ls0 ws13c">File <span class="fc9 ws13a">&quot;&lt;stdin&gt;&quot;</span><span class="ws145">, line <span class="fc7 ls34">1</span><span class="ls32">,</span><span class="ff7 fca ws160">in </span><span class="fc6 ws13a">&lt;<span class="fc0">module</span>&gt;</span></span></div><div class="t m0 x15 hf y1ba7 ff8 fs5 fc0 sc0 ls0 ws13c">File <span class="fc9 ws13a">&quot;&lt;stdin&gt;&quot;</span><span class="ws145">, line <span class="fc7 ls34">4</span><span class="ls32">,</span><span class="ff7 fca ws160">in </span>spam</span></div><div class="t m0 x5 hf y1ba8 ff8 fs5 fc2 sc0 ls0 ws13a">AttributeError<span class="fc0 ls33">:<span class="ff9 ls0 ws13b">&apos;</span><span class="ls0">super<span class="ff9 ls32">&apos;</span><span class="ws4">object has no attribute <span class="ff9 ls34">&apos;</span></span>spam<span class="ff9">&apos;</span></span></span></div><div class="t m0 x5 hf y1ba9 ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h9 y1baa ff1 fs3 fc0 sc0 ls0">但是，如果你使用多继承的话看看会发生什么：</div><div class="t m0 x5 hf y1bab ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="fca ws16a">class <span class="fcc ls34">B</span><span class="ff8 fc0">:</span></span></div><div class="t m0 x5 hf y1bac ff7 fs5 fc5 sc0 ls0 ws1a2">... <span class="fca ws139">def <span class="ff8 fcb ws13a">spam<span class="fc0">(<span class="fca">self</span>):</span></span></span></div><div class="t m0 x5 hf y1bad ff7 fs5 fc5 sc0 ls0 ws1a3">... <span class="fca ws156">print<span class="ff8 fc0 ls34">(<span class="ff9 fc9">&apos;<span class="ff8 ls0 ws13a">B.spam</span>&apos;</span><span class="ls0">)</span></span></span></div><div class="t m0 x5 h10 y1bae ff7 fs5 fc5 sc0 ls0">...</div><div class="t m0 x5 hf y1baf ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="fca ws16a">class <span class="fcc ls34">C</span><span class="ff8 fc0">(A,B):</span></span></div><div class="t m0 x5 h10 y1bb0 ff7 fs5 fc5 sc0 ls0 ws1a2">... <span class="fca">pass</span></div><div class="t m0 x5 h10 y9b3 ff7 fs5 fc5 sc0 ls0">...</div><div class="t m0 x5 hf y1bb1 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls32">c<span class="fc6 ls33">=</span><span class="ls0">C()</span></span></div><div class="t m0 x5 hf y1bb2 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls34">c<span class="fc6 ls0 ws13a">.<span class="fc0">spam()</span></span></span></div><div class="t m0 x5 hf y1bb3 ff8 fs5 fc8 sc0 ls0">A.spam</div><div class="t m0 x5 hf ya7b ff8 fs5 fc8 sc0 ls0">B.spam</div><div class="t m0 x5 hf ya7c ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h7 y1bb4 ff1 fs3 fc0 sc0 ls0 wsa94">你可<span class="_ _6"></span>以看<span class="_ _6"></span>到在<span class="_ _6"></span>类 <span class="ff4 ls16f">A</span><span class="ls17 wsa95">中使用 </span><span class="ff6 wsa96">super().spam() </span><span class="ls17 ws7f7">实际上调用的是跟类 <span class="ff4 ls170">A</span><span class="wsf6">毫无关系的类</span></span></div><div class="t m0 x5 h7 y1bb5 ff4 fs3 fc0 sc0 ls167">B<span class="ff1 ls0 ws14">中的 <span class="ff6 ws25d">spam() </span><span class="ws38">方法。这个用类 </span></span><span class="ls8">C<span class="ff1 ls4">的</span><span class="ls0 wsa97">MR<span class="_ _1"></span>O <span class="ff1">列表就可以完全解释清楚了：</span></span></span></div><div class="t m0 x5 hf y1bb6 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls34">C<span class="fc6 ls0 ws13a">.<span class="fc0">__mro__</span></span></span></div><div class="t m0 x5 hf y1bb7 ff8 fs5 fc8 sc0 ls0 ws155">(&lt;class <span class="ff9 ls34">&apos;</span><span class="ws13a">__main__.C<span class="ff9 ls34">&apos;</span><span class="ws13b">&gt;, &lt;class <span class="ff9 ls34">&apos;</span></span>__main__.A<span class="ff9 ls34">&apos;</span><span class="ws13b">&gt;, &lt;class <span class="ff9 ls34">&apos;</span></span>__main__.B<span class="ff9 ls34">&apos;</span>&gt;,</span></div><div class="t m0 x5 hf y1bb8 ff8 fs5 fc8 sc0 ls0 ws145">&lt;class <span class="ff9 ls34">&apos;</span><span class="ws13a">object<span class="ff9 ls34">&apos;</span>&gt;)</span></div><div class="t m0 x5 hf y1bb9 ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h7 yf48 ff1 fs3 fc0 sc0 ls0 ws38">在定义混入类的时候这样使用 <span class="ff6 ws23a">super() </span><span class="wsc">是很普遍的。可以参考 <span class="ff4 wsca">8.13 </span><span class="ls4">和</span><span class="ff4 ws1d0">8.18 </span>小节。</span></div><div class="t m0 x0 h9 y1bba ff1 fs3 fc0 sc0 ls0 wsa98">然而，<span class="_ _c"></span>由于 <span class="ff6 ws483">super() </span><span class="wsa0">可能会调用不是你想要的方法，你应该遵循一些通用原则。<span class="_ _c"></span>首</span></div><div class="t m0 x5 h7 y6c ff1 fs3 fc0 sc0 ls1f wsa99">先，确保在继承体系中所有相同名字的方法拥有可兼容的参数签名 <span class="ff4 ls1b">(</span><span class="ws113">比如相同的参数个</span></div><div class="t m0 x5 h7 yf8f ff1 fs3 fc0 sc0 ls10 wsdf">数和参数名称<span class="ff4 ls0 wsa5">)</span><span class="ws136">。这样可以确保 <span class="ff6 ls0 ws470">super() </span></span>调用一个非直接父类方法时不会出错<span class="_ _c"></span>。其次，<span class="_ _1"></span></div><div class="t m0 x5 h7 y6e ff1 fs3 fc0 sc0 ls13 wsa9a">最好确保最顶层的类提供了这个方法的实现<span class="_ _1"></span>，这样的话在 <span class="ff4 ls0 wsa9b">MR<span class="_ _1"></span>O <span class="ff1 wsa0">上<span class="_ _6"></span>面的<span class="_ _6"></span>查<span class="_ _6"></span>找<span class="_ _6"></span>链<span class="_ _6"></span>肯定<span class="_ _6"></span>可</span></span></div><div class="t m0 x5 h9 y674 ff1 fs3 fc0 sc0 ls0">以找到某个确定的方法。</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 ws9da">10.7.<span class="_ _5"> </span>8.7 <span class="ff1 ws292">调用父类方法 </span>246</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
