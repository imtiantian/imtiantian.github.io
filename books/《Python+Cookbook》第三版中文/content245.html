<div id="pff5" class="pf w0 h0" data-page-no="f5"><div class="pc pcf5 w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bgf5.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 hf y181 ff7 fs5 fca sc0 ls0 ws15a">from <span class="fcc ws285">functools </span><span class="ws146">import <span class="ff8 fc0">partial</span></span></div><div class="t m0 x5 hf y183 ff8 fs5 fc0 sc0 ls0 ws13c">conn <span class="fc6 ls32">=</span><span class="ws13a">LazyConnection((<span class="ff9 fc9 ws13b">&apos;</span><span class="fc9">www.python.org<span class="ff9 ws13b">&apos;</span></span><span class="ls33">,</span><span class="fc7">80</span>))</span></div><div class="t m0 x5 hf y184 ff7 fs5 fca sc0 ls0 ws15a">with <span class="ff8 fc0 ws161">conn </span><span class="ws157">as <span class="ff8 fc0">s1:</span></span></div><div class="t m0 x15 h10 y185 ff7 fs5 fca sc0 ls0">pass</div><div class="t m0 x15 hf y186 ff7 fs5 fca sc0 ls0 ws15a">with <span class="ff8 fc0 ws161">conn </span><span class="ws157">as <span class="ff8 fc0">s2:</span></span></div><div class="t m0 x16 h10 y187 ff7 fs5 fca sc0 ls0">pass</div><div class="t m0 x16 h11 y188 ffa fs5 fcd sc0 ls0 ws4"># s1 and s2 are independent sockets</div><div class="t m0 x0 h9 y1a7d ff1 fs3 fc0 sc0 ls0 wsa0">在第<span class="_ _6"></span>二<span class="_ _6"></span>个<span class="_ _6"></span>版<span class="_ _6"></span>本中，<span class="_ _6"></span><span class="ff6 ws9f7">LazyConnection </span><span class="ls2d ws132">类可以被看做是某个连接工厂。在内部<span class="_ _1"></span>，一个</span></div><div class="t m0 x5 h9 y1a7e ff1 fs3 fc0 sc0 ls0 ws9f8">列表被用来构造一个栈。每次 <span class="ff6 ws9f9">enter<span class="_ _e"> </span>() </span><span class="ls3a ws153">方法执行的时候，它复制创建一个新的连接</span></div><div class="t m0 x5 h9 y1a7f ff1 fs3 fc0 sc0 ls0 ws9fa">并将<span class="_ _6"></span>其<span class="_ _6"></span>加入<span class="_ _6"></span>到<span class="_ _6"></span>栈里<span class="_ _6"></span>面。 <span class="ff6 ws597">exit<span class="_ _e"> </span>() </span><span class="ls6b ws28f">方法简单的从栈中弹出最后一个连接并关闭它。这<span class="_ _1"></span></span></div><div class="t m0 x5 h9 y1a80 ff1 fs3 fc0 sc0 ls1f ws9fb">里稍微有点难理解，不过它能允许嵌套使用 <span class="ff6 ls0 ws9f6">with </span><span class="ws113">语句创建多个连接，就如上面演示的</span></div><div class="t m0 x5 h9 y1a81 ff1 fs3 fc0 sc0 ls0">那样。</div><div class="t m0 x0 h9 y1a82 ff1 fs3 fc0 sc0 ls3a ws153">在需要管理一些资源比如文件、网络连接和锁的编程环境中，使用上下文管理器是</div><div class="t m0 x5 h9 y1a83 ff1 fs3 fc0 sc0 ls2d ws132">很普遍的<span class="_ _1"></span>。这些资源的一个主要特征是它们必须被手动的关闭或释放来确保程序<span class="_ _6"></span>的正<span class="_ _1"></span></div><div class="t m0 x5 h9 y1a84 ff1 fs3 fc0 sc0 ls1e ws111">确运行<span class="_ _1"></span>。例如，如果你请求了一个锁<span class="_ _c"></span>，那么你必须确保之后释放了<span class="_ _6"></span>它<span class="_ _1"></span>，否则就可能产</div><div class="t m0 x5 h9 y1a85 ff1 fs3 fc0 sc0 ls0 ws9fc">生死锁。通<span class="_ _6"></span>过实现 <span class="ff6 ws30b">enter<span class="_ _e"> </span>() </span><span class="ls162">和</span><span class="ff6 ws30b">exit<span class="_ _e"> </span>() </span><span class="ls68 ws9fd">方法并使用 </span><span class="ff6 ws9fe">with </span><span class="ls68 ws23f">语句可以很容易的避免</span></div><div class="t m0 x5 h9 y1a86 ff1 fs3 fc0 sc0 ls0 ws911">这些问题，因为 <span class="ff6 ws308">exit<span class="_ _e"> </span>() </span>方法可以让你无需担心这些了。</div><div class="t m0 x0 h7 y1a87 ff1 fs3 fc0 sc0 ls57">在<span class="ff6 ls0 ws9ff">contextmanager </span><span class="ls0 wsa00">模块<span class="_ _6"></span>中有<span class="_ _6"></span>一个<span class="_ _6"></span>标准<span class="_ _6"></span>的上<span class="_ _6"></span>下文<span class="_ _6"></span>管理<span class="_ _6"></span>方案<span class="_ _6"></span>模板，<span class="_ _6"></span>可参<span class="_ _6"></span>考 <span class="ff4 wsa01">9.22 </span><span class="wsa0">小节。</span></span></div><div class="t m0 x5 h7 y799 ff1 fs3 fc0 sc0 ls0 ws38">同时在 <span class="ff4 wsca">12.6 </span>小节中还有一个对本节示例程序的线程安全的修改版。</div><div class="t m0 x5 hd y1a88 ff2 fs4 fc4 sc0 ls0 ws9c6">10.4<span class="_ _e"> </span>8.4 <span class="ff1">创建大量对象时节省内存方法</span></div><div class="t m0 x5 he y1a89 ff2 fs2 fc4 sc0 ls0 ws212">10.4.1 <span class="ff1">问题</span></div><div class="t m0 x0 h7 y1a8a ff1 fs3 fc0 sc0 ls0 ws38">你的程序要创建大量 <span class="ff4 wsa5">(</span><span class="wsa0">可能上百万<span class="ff4 ls6a">)</span>的对象，导致占用很大的内存。</span></div><div class="t m0 x5 he y1a8b ff2 fs2 fc4 sc0 ls0 ws212">10.4.2 <span class="ff1">解决方案</span></div><div class="t m0 x0 h9 y1a8c ff1 fs3 fc0 sc0 ls42 wsa02">对于主要是用来当成简单的数据结构的类而言，你可以通过给类添加 <span class="ff6 ls0 wsa03">slots <span class="ff1">属</span></span></div><div class="t m0 x5 h9 y1a8d ff1 fs3 fc0 sc0 ls0">性来极大的减少实例所占的内存。比如：</div><div class="t m0 x5 hf y1a8e ff7 fs5 fca sc0 ls0 ws16a">class <span class="fcc ws156">Date<span class="ff8 fc0">:</span></span></div><div class="t m0 x15 hf y1a8f ff8 fs5 fc0 sc0 ls0 ws16e">__slots__ <span class="fc6 ls33">=</span><span class="ws13a">[<span class="ff9 fc9 ls34">&apos;</span><span class="fc9">year<span class="ff9 ls34">&apos;</span></span><span class="ls32">,<span class="ff9 fc9 ls34">&apos;</span></span><span class="fc9">month<span class="ff9 ws13b">&apos;</span></span><span class="ls33">,</span><span class="ff9 fc9 ws13b">&apos;</span><span class="fc9">day<span class="ff9 ws13b">&apos;</span></span>]</span></div><div class="t m0 x15 hf y1a90 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">__init__<span class="fc0">(<span class="fca">self</span><span class="ws4">, year, month, day):</span></span></span></div><div class="t m0 x16 hf y1a91 ff8 fs5 fca sc0 ls0 ws13a">self<span class="fc6">.<span class="fc0 ws13c">year </span><span class="ls33">=</span><span class="fc0">year</span></span></div><div class="t m0 x16 hf y1a92 ff8 fs5 fca sc0 ls0 ws13a">self<span class="fc6">.<span class="fc0 ws458">month </span><span class="ls32">=</span><span class="fc0">month</span></span></div><div class="t m0 x16 hf y1a93 ff8 fs5 fca sc0 ls0 ws13a">self<span class="fc6">.<span class="fc0 ws158">day </span><span class="ls33">=</span><span class="fc0">day</span></span></div><div class="t m0 x0 h7 y1a94 ff1 fs3 fc0 sc0 ls0 wsa04">当你定义 <span class="ff6 wsa05">slots </span><span class="wsa0">后，<span class="ff4 wsa06">Python </span>就会为实例使用一种更加紧凑的内部表示。实例通</span></div><div class="t m0 x5 h9 y1a95 ff1 fs3 fc0 sc0 ls13 wse5">过一个很小的固定大小的数组来构建<span class="_ _1"></span>，而不是为每个实例定义一个字典，这跟元组或<span class="_ _c"></span></div><div class="t m0 x5 h9 y17f ff1 fs3 fc0 sc0 ls0 wsa07">列表很类似。在 <span class="ff6 ws2b3">slots </span><span class="wsa0">中列出的<span class="_ _6"></span>属性名在内部被映射到这<span class="_ _6"></span>个数组的指定小标上。使</span></div><div class="t m0 x5 h7 yca1 ff1 fs3 fc0 sc0 ls163">用<span class="ff4 ls0 wsa08">slots </span><span class="ls0 wsa09">一个不好的地方就是我们不能再给实例添加新的属性了，<span class="_ _c"></span>只能使用在 <span class="ff6">slots</span></span></div><div class="t m0 x5 h9 y1a96 ff1 fs3 fc0 sc0 ls0">中定义的那些属性名。</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 ws9da">10.4.<span class="_ _5"> </span>8.4 <span class="ff1 ws21e">创建大量对象时节省内存方法 </span>236</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
