<div id="pf17a" class="pf w0 h0" data-page-no="17a"><div class="pc pc17a w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg17a.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 he y137 ff2 fs2 fc4 sc0 ls0 ws212">12.4.3 <span class="ff1">讨论</span></div><div class="t m0 x0 h9 y675 ff1 fs3 fc0 sc0 ls3a ws153">在这个章节中的主要问题是一个设计问题，不管你是否希望用户使用很多小模块或</div><div class="t m0 x5 h9 y676 ff1 fs3 fc0 sc0 ls0 wsa0">只<span class="_ _6"></span>是一<span class="_ _6"></span>个<span class="_ _6"></span>模<span class="_ _6"></span>块。<span class="_ _6"></span>举<span class="_ _6"></span>个例<span class="_ _6"></span>子，<span class="_ _6"></span>在<span class="_ _6"></span>一<span class="_ _6"></span>个<span class="_ _6"></span>大型<span class="_ _6"></span>的<span class="_ _6"></span>代<span class="_ _6"></span>码<span class="_ _6"></span>库<span class="_ _6"></span>中，<span class="_ _6"></span>你可<span class="_ _6"></span>以<span class="_ _6"></span>将<span class="_ _6"></span>这<span class="_ _6"></span>一<span class="_ _6"></span>切都<span class="_ _6"></span>分<span class="_ _6"></span>割<span class="_ _6"></span>成<span class="_ _6"></span>独<span class="_ _6"></span>立的</div><div class="t m0 x5 h7 y677 ff1 fs3 fc0 sc0 ls0 ws38">文件，让用户使用大量的 <span class="ff4 wscf1">imp<span class="_ _6"></span>ort </span>语句，就像这样：</div><div class="t m0 x5 hf y26ed ff7 fs5 fca sc0 ls0 ws15a">from <span class="fcc wscaf">mymodule.a </span><span class="ws146">import <span class="ff8 fc0">A</span></span></div><div class="t m0 x5 hf y26ee ff7 fs5 fca sc0 ls0 ws15a">from <span class="fcc wscaf">mymodule.b </span><span class="ws146">import <span class="ff8 fc0">B</span></span></div><div class="t m0 x5 hf y26ef ff8 fs5 fc6 sc0 ls0 ws13a">...</div><div class="t m0 x0 h9 y26f0 ff1 fs3 fc0 sc0 ls0 wsa0">这样能工作，但这让用<span class="_ _6"></span>户承受更多的负担，用户要<span class="_ _6"></span>知道不同的部分位于何<span class="_ _6"></span>处。通常</div><div class="t m0 x5 h7 y26f1 ff1 fs3 fc0 sc0 ls0 ws14">情况下，将这些统一起来，使用一条 <span class="ff4 wscf1">imp<span class="_ _6"></span>ort </span>将更加容易，就像这样：</div><div class="t m0 x5 hf y26f2 ff7 fs5 fca sc0 ls0 ws15a">from <span class="fcc ws248">mymodule </span><span class="ws146">import <span class="ff8 fc0 ws4">A, B</span></span></div><div class="t m0 x0 h7 y26f3 ff1 fs3 fc0 sc0 ls0 wsab6">对后者而言，让 <span class="ff4 wsd2e">m<span class="_ _1"></span>ymo<span class="_ _6"></span>dule <span class="ff1 wsa0">成为一个大的源文件是最常见的。但是，这一章节展示</span></span></div><div class="t m0 x5 h9 y26f4 ff1 fs3 fc0 sc0 ls2d ws132">了如何合并多个文件合并成一个单一的逻辑命名空间。这样做的关键是创建一个包目<span class="_ _1"></span></div><div class="t m0 x5 h7 y26f5 ff1 fs3 fc0 sc0 ls0 ws592">录，使用 <span class="ff4 wsa47">init<span class="_ _e"> </span>.p<span class="_ _1"></span>y <span class="ff1">文件来将每部分粘合在一起。</span></span></div><div class="t m0 x0 h9 y26f6 ff1 fs3 fc0 sc0 ls24 ws11d">当一个模块被分割<span class="_ _c"></span>，你需要特别注意交叉引用的文件名<span class="_ _1"></span>。举个例子<span class="_ _1"></span>，在这一章节<span class="_ _c"></span></div><div class="t m0 x5 h7 y26f7 ff1 fs3 fc0 sc0 ls0 wsa0">中，<span class="ff4 ls167">B</span><span class="ws63">类需要访问 <span class="ff4 ls3">A</span><span class="ws38">类作为基类。用包的相对导入 <span class="ff4 ws9c">from .a imp<span class="_ _6"></span>ort A </span>来获取。</span></span></div><div class="t m0 x0 h9 y26f8 ff1 fs3 fc0 sc0 ls3a ws153">整个章节都使用包的相对导入来避免将顶层模块名硬编码到源代码中。这使得重命</div><div class="t m0 x5 h7 y26f9 ff1 fs3 fc0 sc0 ls0 wsd2f">名模块或者将它移动到别的位置更容易。<span class="_ _3"></span>（见 <span class="ff4 wsca">10.3 </span>小节）</div><div class="t m0 x0 h7 y26fa ff1 fs3 fc0 sc0 ls30 wsd30">作为这一章节的延伸<span class="_ _1"></span>，将介绍延迟导入。如图所示<span class="_ _c"></span>， <span class="ff4 ls0 wsd31">init<span class="_ _e"> </span>.py <span class="ff1 wsa0">文件<span class="_ _6"></span>一<span class="_ _6"></span>次导<span class="_ _6"></span>入<span class="_ _6"></span>所有</span></span></div><div class="t m0 x5 h9 y26fb ff1 fs3 fc0 sc0 ls0 wsa0">必<span class="_ _6"></span>需的<span class="_ _6"></span>组<span class="_ _6"></span>件<span class="_ _6"></span>的。<span class="_ _6"></span>但<span class="_ _6"></span>是对<span class="_ _6"></span>于<span class="_ _6"></span>一<span class="_ _6"></span>个<span class="_ _6"></span>很<span class="_ _6"></span>大的<span class="_ _6"></span>模<span class="_ _6"></span>块，<span class="_ _6"></span>可<span class="_ _6"></span>能<span class="_ _6"></span>你<span class="_ _6"></span>只想<span class="_ _6"></span>组<span class="_ _6"></span>件<span class="_ _6"></span>在<span class="_ _6"></span>需<span class="_ _6"></span>要时<span class="_ _6"></span>被<span class="_ _6"></span>加<span class="_ _6"></span>载。<span class="_ _6"></span>要<span class="_ _6"></span>做到</div><div class="t m0 x5 h7 y26fc ff1 fs3 fc0 sc0 ls0 wsd32">这一点， <span class="ff4 wsa47">init<span class="_ _e"> </span>.p<span class="_ _1"></span>y <span class="ff1">有细微的变化：</span></span></div><div class="t m0 x5 h11 y26fd ffa fs5 fcd sc0 ls0 ws4"># __init__.py</div><div class="t m0 x5 hf y26fe ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ls34">A<span class="fc0 ls0">():</span></span></div><div class="t m0 x15 hf y26ff ff7 fs5 fca sc0 ls0 ws15a">from <span class="fcc ws157">.a </span><span class="ws146">import <span class="ff8 fc0">A</span></span></div><div class="t m0 x15 hf y2700 ff7 fs5 fca sc0 ls0 ws146">return <span class="ff8 fc0">A()</span></div><div class="t m0 x5 hf y2701 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ls34">B<span class="fc0 ls0">():</span></span></div><div class="t m0 x15 hf y2702 ff7 fs5 fca sc0 ls0 ws15a">from <span class="fcc ws157">.b </span><span class="ws146">import <span class="ff8 fc0">B</span></span></div><div class="t m0 x15 hf y11e9 ff7 fs5 fca sc0 ls0 ws146">return <span class="ff8 fc0">B()</span></div><div class="t m0 x0 h7 y2703 ff1 fs3 fc0 sc0 ls0 wsd33">在这个<span class="_ _6"></span>版本<span class="_ _6"></span>中，类 <span class="ff4 ls1b7">A</span><span class="ws2c2">和类 <span class="ff4 ls1b8">B</span><span class="ls3d ws164">被替换为在第一次访问时加载所需的类的函数。对于</span></span></div><div class="t m0 x5 h9 y2704 ff1 fs3 fc0 sc0 ls0">用户，这看起来不会有太大的不同。例如：</div><div class="t m0 x5 h10 y2705 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="fca ws146">import <span class="fcc">mymodule</span></span></div><div class="t m0 x5 hf y2706 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls32">a<span class="fc6 ls33">=</span><span class="ls0 ws13a">mymodule<span class="fc6">.</span>A()</span></span></div><div class="t m0 x5 hf y2707 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls34">a<span class="fc6 ls0 ws13a">.<span class="fc0">spam()</span></span></span></div><div class="t m0 x5 hf y2708 ff8 fs5 fc8 sc0 ls0">A.spam</div><div class="t m0 x5 hf y2709 ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h9 y270a ff1 fs3 fc0 sc0 ls22 ws119">延迟加载的主要缺点是继承和类型检查可能会中断。你可能会稍微改变你的代码<span class="_ _1"></span>，</div><div class="t m0 x5 h7 y270b ff1 fs3 fc0 sc0 ls0 wsa0">例如<span class="ff4">:</span></div><div class="t m0 x5 hf y270c ff7 fs5 fca sc0 ls0 ws157">if <span class="ff8 ws13a">isinstance<span class="fc0 ws4">(x, mymodule<span class="fc6 ls34">.</span><span class="ws158">A): <span class="ffa fcd ws13b"># Error</span></span></span></span></div><div class="t m0 x5 hf y270d ff8 fs5 fc6 sc0 ls0 ws13a">...</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 ws21d">12.4.<span class="_ _5"> </span>10.4 <span class="ff1 ws509">将模块分割成多个文件 </span>369</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
