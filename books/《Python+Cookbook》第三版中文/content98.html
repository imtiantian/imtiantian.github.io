<div id="pf62" class="pf w0 h0" data-page-no="62"><div class="pc pc62 w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg62.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 hf y334 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0">data</span></div><div class="t m0 x5 hf y335 ff8 fs5 fc8 sc0 ls34">b<span class="ff9 ls0 ws13b">&apos;</span><span class="ls0 ws13a">\x00\x124V\x00x\x90\xab\x00\xcd\xef\x01\x00#\x004<span class="ff9">&apos;</span></span></div><div class="t m0 x5 h10 y336 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="fca ws146">import <span class="fcc">struct</span></span></div><div class="t m0 x5 hf y337 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws13b">hi, lo <span class="fc6 ls32">=</span><span class="ws13a">struct<span class="fc6 ls34">.</span>unpack(</span><span class="ff9 fc9">&apos;<span class="ff8 ws13a">&gt;QQ</span>&apos;</span><span class="ws4">, data)</span></span></div><div class="t m0 x5 hf yadd ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws158">(hi <span class="fc6 ws159">&lt;&lt; <span class="fc7 ws13a">64</span></span><span class="ls33">)<span class="fc6 ls32">+</span></span>lo</span></div><div class="t m0 x5 hf yade ff8 fs5 fc8 sc0 ls0">94522842520747284487117727783387188</div><div class="t m0 x5 hf yadf ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h7 yae0 ff1 fs3 fc0 sc0 lsd3 ws4af">字节顺序规则 <span class="ff4 ls0 ws4b0">(little </span><span class="lsd4">或<span class="ff4 ls0 ws4b1">big) </span></span><span class="ws4b2">仅仅指定了构建整数时的字节的低位高位排列方式<span class="_ _c"></span>。<span class="_ _1"></span></span></div><div class="t m0 x5 h7 yae1 ff1 fs3 fc0 sc0 ls0 ws14">我们从下面精心构造的 <span class="ff4 wsd2">16 </span>进制数的表示中可以很容易的看出来：</div><div class="t m0 x5 hf yae2 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls32">x<span class="fc6 ls33">=<span class="fc7 ls0">0x01020304</span></span></span></div><div class="t m0 x5 hf yae3 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls34">x<span class="fc6 ls0 ws13a">.<span class="fc0">to_bytes(</span></span><span class="fc7">4</span><span class="ls32">,</span><span class="ff9 fc9">&apos;<span class="ff8 ls0 ws13a">big</span>&apos;</span><span class="ls0">)</span></span></div><div class="t m0 x5 hf yae4 ff8 fs5 fc8 sc0 ls34">b<span class="ff9 ls0 ws13b">&apos;</span><span class="ls0 ws13a">\x01\x02\x03\x04<span class="ff9">&apos;</span></span></div><div class="t m0 x5 hf y698 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls34">x<span class="fc6 ls0 ws13a">.<span class="fc0">to_bytes(</span></span><span class="fc7">4</span><span class="ls32">,</span><span class="ff9 fc9">&apos;<span class="ff8 ls0 ws13a">little</span>&apos;</span><span class="ls0">)</span></span></div><div class="t m0 x5 hf yae5 ff8 fs5 fc8 sc0 ls34">b<span class="ff9 ls0 ws13b">&apos;</span><span class="ls0 ws13a">\x04\x03\x02\x01<span class="ff9">&apos;</span></span></div><div class="t m0 x5 hf yae6 ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h9 yae7 ff1 fs3 fc0 sc0 ls56 ws1fa">如果你试着将一个整数打包为字节字符串<span class="_ _c"></span>，那么它就不合适了<span class="_ _1"></span>，你会得到一个错<span class="_ _1"></span></div><div class="t m0 x5 h9 yae8 ff1 fs3 fc0 sc0 ls0 ws4b3">误。如果需要的话，你可以使用 <span class="ff6 ws26f">int.bit<span class="_ _7"> </span>length() </span><span class="wsa0">方法来决定需要多少字节位来存储</span></div><div class="t m0 x5 h9 yae9 ff1 fs3 fc0 sc0 ls0">这个值。</div><div class="t m0 x5 hf yaea ff8 fs5 fc0 sc0 ls0 ws4">&gt;&gt;&gt; x = 523 ** 23</div><div class="t m0 x5 hf yaeb ff8 fs5 fc0 sc0 ls0 ws4">&gt;&gt;&gt; x</div><div class="t m0 x5 hf yaec ff8 fs5 fc0 sc0 ls0">335381300113661875107536852714019056160355655333978849017944067</div><div class="t m0 x5 hf yaed ff8 fs5 fc0 sc0 ls0 ws4">&gt;&gt;&gt; x.to_bytes(16, <span class="ff9 ls34">&apos;</span><span class="ws13a">little<span class="ff9 ls34">&apos;</span>)</span></div><div class="t m0 x5 hf yaee ff8 fs5 fc0 sc0 ls0 ws4">Traceback (most recent call last):</div><div class="t m0 x5 hf yaef ff8 fs5 fc0 sc0 ls0 ws4">File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="t m0 x5 hf yaf0 ff8 fs5 fc0 sc0 ls0 ws4">OverflowError: int too big to convert</div><div class="t m0 x5 hf yaf1 ff8 fs5 fc0 sc0 ls0 ws4">&gt;&gt;&gt; x.bit_length()</div><div class="t m0 x5 hf yaf2 ff8 fs5 fc0 sc0 ls0">208</div><div class="t m0 x5 hf yaf3 ff8 fs5 fc0 sc0 ls0 ws4">&gt;&gt;&gt; nbytes, rem = divmod(x.bit_length(), 8)</div><div class="t m0 x5 hf yaf4 ff8 fs5 fc0 sc0 ls0 ws4">&gt;&gt;&gt; if rem:</div><div class="t m0 x5 hf yaf5 ff8 fs5 fc0 sc0 ls0 ws4">... nbytes += 1</div><div class="t m0 x5 hf yaf6 ff8 fs5 fc0 sc0 ls0">...</div><div class="t m0 x5 hf yaf7 ff8 fs5 fc0 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x5 hf yaf8 ff8 fs5 fc0 sc0 ls0 ws4">&gt;&gt;&gt; x.to_bytes(nbytes, <span class="ff9 ws13b">&apos;</span><span class="ws13a">little<span class="ff9 ls34">&apos;</span>)</span></div><div class="t m0 x5 hf yaf9 ff8 fs5 fc0 sc0 ls34">b<span class="ff9 ls0 ws13b">&apos;</span><span class="ls0 ws13a">\x03X\xf1\x82iT\x96\xac\xc7c\x16\xf3\xb9\xcf...\xd0<span class="ff9">&apos;</span></span></div><div class="t m0 x5 hf yafa ff8 fs5 fc0 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x5 hd yafb ff2 fs4 fc4 sc0 ls0 ws134">5.6<span class="_ _e"> </span>3.6 <span class="ff1">复数的数学运算</span></div><div class="t m0 x5 he yafc ff2 fs2 fc4 sc0 ls0 ws135">5.6.1 <span class="ff1">问题</span></div><div class="t m0 x0 h9 yafd ff1 fs3 fc0 sc0 ls3a ws153">你写的最新的网络认证方案代码遇到了一个难题，并且你唯一的解决办法就是使用</div><div class="t m0 x5 h9 yafe ff1 fs3 fc0 sc0 ls0">复数空间。再或者是你仅仅需要使用复数来执行一些计算操作。</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 ws13e">5.6.<span class="_ _5"> </span>3.6 <span class="ff1 ws4b4">复数的数学运算 </span>89</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
