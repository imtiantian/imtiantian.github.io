<div id="pf12c" class="pf w0 h0" data-page-no="12c"><div class="pc pc12c w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg12c.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 hf y1ab ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls34">e<span class="fc6 ls0 ws13a">.<span class="fc0">visit(a)</span></span></span></div><div class="t m0 x5 hf y1ac ff8 fs5 fc8 sc0 ls0">4999950000</div><div class="t m0 x5 hf y1ad ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h9 y2f1 ff1 fs3 fc0 sc0 ls0">如果你还想添加其他自定义逻辑也没问题：</div><div class="t m0 x5 hf yc28 ff7 fs5 fca sc0 ls0 ws16a">class <span class="fcc ws156">Evaluator<span class="ff8 fc0">(NodeVisitor):</span></span></div><div class="t m0 x15 hf yc29 ff8 fs5 fc6 sc0 ls0 ws13a">...</div><div class="t m0 x15 hf yc2a ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">visit_Add<span class="fc0 ls34">(</span><span class="fca">self<span class="fc0 ws13b">, node):</span></span></span></div><div class="t m0 x16 hf yc2b ff7 fs5 fca sc0 ls0 ws156">print<span class="ff8 fc0 ls34">(<span class="ff9 fc9">&apos;<span class="ff8 ls0 ws13a">Add:</span>&apos;</span><span class="ls0 ws13b">, node)</span></span></div><div class="t m0 x16 hf y357 ff8 fs5 fc0 sc0 ls0 ws158">lhs <span class="fc6 ls32">=</span><span class="ff7 fca ws83b">yield </span><span class="ws13a">node<span class="fc6 ls34">.</span>left</span></div><div class="t m0 x16 hf y358 ff7 fs5 fca sc0 ls0 ws156">print<span class="ff8 fc0 ls34">(<span class="ff9 fc9">&apos;<span class="ff8 ls0 ws13a">left=<span class="ff9 ws13b">&apos;</span><span class="fc0 ws4">, lhs)</span></span></span></span></div><div class="t m0 x16 hf yca3 ff8 fs5 fc0 sc0 ls0 ws158">rhs <span class="fc6 ls32">=</span><span class="ff7 fca ws83b">yield </span><span class="ws13a">node<span class="fc6 ls34">.</span>right</span></div><div class="t m0 x16 hf y1fa8 ff7 fs5 fca sc0 ls0 ws156">print<span class="ff8 fc0 ls34">(<span class="ff9 fc9">&apos;<span class="ff8 ls0 ws13a">right=</span>&apos;</span><span class="ls0 ws13b">, rhs)</span></span></div><div class="t m0 x16 hf y1fa9 ff7 fs5 fca sc0 ls0 ws16a">yield <span class="ff8 fc0 ws158">lhs <span class="fc6 ls33">+</span>rhs</span></div><div class="t m0 x15 hf y1faa ff8 fs5 fc6 sc0 ls0 ws13a">...</div><div class="t m0 x0 h9 ya5e ff1 fs3 fc0 sc0 ls0">下面是简单的测试：</div><div class="t m0 x5 hf yc30 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls32">e<span class="fc6 ls33">=</span><span class="ls0">Evaluator()</span></span></div><div class="t m0 x5 hf yc31 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls34">e<span class="fc6 ls0 ws13a">.<span class="fc0">visit(t4)</span></span></span></div><div class="t m0 x5 hf yc32 ff8 fs5 fc8 sc0 ls0 ws4">Add: &lt;__main__.Add object at 0x1006a8d90&gt;</div><div class="t m0 x5 hf yc33 ff8 fs5 fc8 sc0 ls0 ws4">left= 1</div><div class="t m0 x5 hf yc34 ff8 fs5 fc8 sc0 ls0 ws4">right= -0.4</div><div class="t m0 x5 hf yc35 ff8 fs5 fc8 sc0 ls0">0.6</div><div class="t m0 x5 hf yc36 ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x5 he yf9e ff2 fs2 fc4 sc0 ls0 wsadf">10.22.3 <span class="ff1">讨论</span></div><div class="t m0 x0 h9 y1fab ff1 fs3 fc0 sc0 ls3a ws153">这一小节我们演示了生成器和协程在程序控制流方面的强大功能。避免递归的一个</div><div class="t m0 x5 h9 y1fac ff1 fs3 fc0 sc0 ls0 wsa0">通<span class="_ _6"></span>常方<span class="_ _6"></span>法<span class="_ _6"></span>是<span class="_ _6"></span>使<span class="_ _6"></span>用<span class="_ _6"></span>一个<span class="_ _6"></span>栈<span class="_ _6"></span>或<span class="_ _6"></span>队<span class="_ _6"></span>列<span class="_ _6"></span>的数<span class="_ _6"></span>据<span class="_ _6"></span>结<span class="_ _6"></span>构。<span class="_ _6"></span>例<span class="_ _6"></span>如，<span class="_ _6"></span>深度<span class="_ _6"></span>优<span class="_ _6"></span>先<span class="_ _6"></span>的<span class="_ _6"></span>遍<span class="_ _6"></span>历算<span class="_ _6"></span>法，<span class="_ _6"></span>第<span class="_ _6"></span>一<span class="_ _6"></span>次<span class="_ _6"></span>碰到</div><div class="t m0 x5 h9 y1fad ff1 fs3 fc0 sc0 ls0 wsa0">一个节点时将其压入栈中，处理完后弹出栈。<span class="ff6 ws23a">visit() </span>方法的核心思路就是这样。</div><div class="t m0 x0 h7 y1fae ff1 fs3 fc0 sc0 ls13 wsb62">另外一个需要理解的就是生成器中 <span class="ff4 ls0 wsb63">yield </span><span class="wsb64">语句<span class="_ _1"></span>。当碰到 <span class="ff4 ls0 wsb65">yield <span class="ff1 wsa0">语<span class="_ _6"></span>句<span class="_ _6"></span>时，生<span class="_ _6"></span>成<span class="_ _6"></span>器<span class="_ _6"></span>会<span class="_ _6"></span>返</span></span></span></div><div class="t m0 x5 h9 y1faf ff1 fs3 fc0 sc0 ls0 wsa0">回<span class="_ _6"></span>一个<span class="_ _6"></span>数<span class="_ _6"></span>据<span class="_ _6"></span>并<span class="_ _6"></span>暂<span class="_ _6"></span>时挂<span class="_ _6"></span>起。<span class="_ _6"></span>上<span class="_ _6"></span>面<span class="_ _6"></span>的<span class="_ _6"></span>例子<span class="_ _6"></span>使<span class="_ _6"></span>用<span class="_ _6"></span>这<span class="_ _6"></span>个<span class="_ _6"></span>技术<span class="_ _6"></span>来<span class="_ _6"></span>代<span class="_ _6"></span>替<span class="_ _6"></span>了<span class="_ _6"></span>递归。<span class="_ _6"></span>例<span class="_ _6"></span>如，<span class="_ _6"></span>之<span class="_ _6"></span>前<span class="_ _6"></span>我<span class="_ _6"></span>们是</div><div class="t m0 x5 h9 y1fb0 ff1 fs3 fc0 sc0 ls0">这样写递归：</div><div class="t m0 x5 hf y1fb1 ff8 fs5 fc0 sc0 ls0 ws15f">value <span class="fc6 ls33">=</span><span class="fca ws13a">self<span class="fc6">.<span class="fc0">visit(node</span>.</span></span>left)</div><div class="t m0 x0 h7 y1fb2 ff1 fs3 fc0 sc0 ls0 wsc">现在换成 <span class="ff4 ws3ca">yield </span>语句：</div><div class="t m0 x5 hf y1fb3 ff8 fs5 fc0 sc0 ls0 ws15f">value <span class="fc6 ls33">=</span><span class="ff7 fca ws16a">yield </span><span class="ws13a">node<span class="fc6 ls34">.</span>left</span></div><div class="t m0 x0 h9 ye1 ff1 fs3 fc0 sc0 ls0 wsb66">它会将 <span class="ff6 ws1b6">node.left </span><span class="ls3d wsb67">返回给 </span><span class="ff6 ws47b">visit() </span><span class="wsb68">方<span class="_ _6"></span>法，然<span class="_ _6"></span>后 <span class="ff6 ws14e">visit() </span><span class="ls3d ws164">方法调用那个节点相应的</span></span></div><div class="t m0 x5 h7 y1fb4 ff6 fs3 fc0 sc0 ls0 wsb69">visit<span class="_ _7"> </span>Name() <span class="ff1 wsa0">方法。<span class="ff4 wsb6a">yield </span><span class="ls1f ws113">暂时将程序控制器让出给调用者，当执行完后，结果会赋值</span></span></div><div class="t m0 x5 h7 y1fb5 ff1 fs3 fc0 sc0 ls4">给<span class="ff4 ls0 wsa5">v<span class="_ _d"></span>alue<span class="ff1">，</span></span></div><div class="t m0 x0 h7 y1fb6 ff1 fs3 fc0 sc0 ls0 wsb58">看完这一小节，<span class="_ _1"></span>你也许想去寻找其它没有 <span class="ff4 wsb6b">yield </span><span class="wsa0">语句的方案。但是这么做没有必要，</span></div><div class="t m0 x5 h9 y1fb7 ff1 fs3 fc0 sc0 ls1e ws111">你必须处理很多棘手的问题<span class="_ _1"></span>。例如，为了消除递归<span class="_ _c"></span>，你必须要维护<span class="_ _6"></span>一个栈结构<span class="_ _1"></span>，如果</div><div class="t m0 x5 h9 y1fb8 ff1 fs3 fc0 sc0 ls40 ws180">不使用生成器<span class="_ _1"></span>，代码会变得很臃肿，到处都是栈操作语句<span class="_ _c"></span>、回调函数等。实际上<span class="_ _c"></span>，使</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 wsae0">10.22.<span class="_ _5"> </span>8.22 <span class="ff1 wsb03">不用递归实现访问者模式 </span>291</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
