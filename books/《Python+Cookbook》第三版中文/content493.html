<div id="pf1ed" class="pf w0 h0" data-page-no="1ed"><div class="pc pc1ed w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg1ed.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 he y137 ff2 fs2 fc4 sc0 ls0 wsadf">14.12.3 <span class="ff1">讨论</span></div><div class="t m0 x0 h7 y236 ff1 fs3 fc0 sc0 ls0 ws14">在构建基于生成器的并发框架时，通常会使用更常见的 <span class="ff4 wscb7">yield </span>形式：</div><div class="t m0 x5 hf y26ba ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">some_generator<span class="fc0">():</span></span></div><div class="t m0 x15 hf y26bb ff8 fs5 fc6 sc0 ls0 ws13a">...</div><div class="t m0 x15 hf y26bc ff8 fs5 fc0 sc0 ls0 ws145">result <span class="fc6 ls32">=</span><span class="ff7 fca ws83b">yield </span>data</div><div class="t m0 x15 hf y26bd ff8 fs5 fc6 sc0 ls0 ws13a">...</div><div class="t m0 x0 h7 y30b0 ff1 fs3 fc0 sc0 ls0 ws118f">使用<span class="_ _6"></span>这种<span class="_ _6"></span>形式<span class="_ _6"></span>的 <span class="ff4 ws1190">yield </span><span class="wsa0">语句<span class="_ _6"></span>的<span class="_ _6"></span>函数<span class="_ _6"></span>通常<span class="_ _6"></span>被称<span class="_ _6"></span>为“协<span class="_ _6"></span>程”<span class="_ _31"></span>。<span class="_ _6"></span>通过<span class="_ _6"></span>调度<span class="_ _6"></span>器，<span class="_ _6"></span><span class="ff4 ws1190">yield </span>语句<span class="_ _6"></span>在</span></div><div class="t m0 x5 h9 y30b1 ff1 fs3 fc0 sc0 ls0">一个循环中被处理，如下：</div><div class="t m0 x5 hf y30b2 ff8 fs5 fc0 sc0 ls32">f<span class="fc6 ls33">=</span><span class="ls0">some_generator()</span></div><div class="t m0 x5 h11 y30b3 ffa fs5 fcd sc0 ls0 ws4"># Initial result. Is None to start since nothing has been computed</div><div class="t m0 x5 hf y30b4 ff8 fs5 fc0 sc0 ls0 ws145">result <span class="fc6 ls33">=</span><span class="fca">None</span></div><div class="t m0 x5 hf y30b5 ff7 fs5 fca sc0 ls0 ws16a">while <span class="ff8 ws13a">True<span class="fc0">:</span></span></div><div class="t m0 x15 hf y30b6 ff7 fs5 fca sc0 ls0 ws156">try<span class="ff8 fc0">:</span></div><div class="t m0 x16 hf y30b7 ff8 fs5 fc0 sc0 ls0 ws161">data <span class="fc6 ls33">=</span><span class="ls34">f</span><span class="fc6 ws13a">.</span>send(result)</div><div class="t m0 x16 hf y30b8 ff8 fs5 fc0 sc0 ls0 ws145">result <span class="fc6 ws23d">= ... </span><span class="ws4">do some calculation <span class="fc6 ws13a">...</span></span></div><div class="t m0 x15 hf y30b9 ff7 fs5 fca sc0 ls0 ws146">except <span class="ff8 ws13a">StopIteration<span class="fc0">:</span></span></div><div class="t m0 x16 h10 y30ba ff7 fs5 fca sc0 ls0">break</div><div class="t m0 x0 h7 y30bb ff1 fs3 fc0 sc0 ls2d ws1191">这里的逻辑稍微有点复杂<span class="_ _1"></span>。不过，被传给 <span class="ff6 ls0 ws68f">send() </span><span class="ws1192">的值定义了在 <span class="ff4 ls0 ws1193">yield </span><span class="ws132">语句醒来时<span class="_ _c"></span></span></span></div><div class="t m0 x5 h7 ye0e ff1 fs3 fc0 sc0 lse ws1194">的返回值。因此<span class="_ _1"></span>，如果一个 <span class="ff4 ls0 ws1195">yield </span><span class="ws1196">准备在对之前 <span class="ff4 ls0 ws1195">yield </span><span class="wsd8">数据的回应中返回结果时，会在</span></span></div><div class="t m0 x5 h7 y6fb ff1 fs3 fc0 sc0 ls0 ws1197">下一次 <span class="ff6 ws3bf">send() </span><span class="ws1198">操作返<span class="_ _6"></span>回。如果一个生<span class="_ _6"></span>成器函数刚开<span class="_ _6"></span>始运行，发送一<span class="_ _6"></span>个 <span class="ff4 ws1199">None </span><span class="wsa0">值会让它</span></span></div><div class="t m0 x5 h7 y30bc ff1 fs3 fc0 sc0 ls0 ws38">排在第一个 <span class="ff4 ws3ca">yield </span>语句前面。</div><div class="t m0 x0 h9 y30bd ff1 fs3 fc0 sc0 ls49 ws461">除了发送值外<span class="_ _1"></span>，还可以在一个生成器上面执行一个 <span class="ff6 ls0 ws6b1">close() </span><span class="ws1a6">方法<span class="_ _1"></span>。它会导致在执</span></div><div class="t m0 x5 h7 y26df ff1 fs3 fc0 sc0 ls211">行<span class="ff4 ls0 ws119a">yield </span><span class="ls48 ws119b">语句时抛出一个 </span><span class="ff6 ls0 ws31e">GeneratorExit </span><span class="ls0 wsa0">异<span class="_ _6"></span>常，<span class="_ _6"></span>从<span class="_ _6"></span>而<span class="_ _6"></span>终<span class="_ _6"></span>止执<span class="_ _6"></span>行。<span class="_ _6"></span>如<span class="_ _6"></span>果<span class="_ _6"></span>进<span class="_ _6"></span>一<span class="_ _6"></span>步<span class="_ _6"></span>设<span class="_ _6"></span>计，<span class="_ _6"></span>一</span></div><div class="t m0 x5 h9 y30be ff1 fs3 fc0 sc0 lsa8 ws9b1">个生成器可以捕获这个异常并执行清理操作<span class="_ _1"></span>。同样还可以使用生成器的 <span class="ff6 ls0 ws411">throw() <span class="ff1 wsa0">方法</span></span></div><div class="t m0 x5 h7 y944 ff1 fs3 fc0 sc0 ls10e">在<span class="ff4 ls0 ws627">yield </span><span class="ls3a ws153">语句执行时生成一个任意的执行指令。一个任务调度器可利用它来在运行的生</span></div><div class="t m0 x5 h9 y30bf ff1 fs3 fc0 sc0 ls0">成器中处理错误。</div><div class="t m0 x0 h9 y2751 ff1 fs3 fc0 sc0 ls2c ws18f">最后一个例子中使用的 <span class="ff6 ls0 ws119c">yield<span class="_ _11"> </span>from </span><span class="ws12f">语句被用来实现协程，可以被其它生成器作为</span></div><div class="t m0 x5 h9 y30c0 ff1 fs3 fc0 sc0 ls13 wse5">子程序或过程来调用<span class="_ _1"></span>。本质上就是将控制权透明的传输给新的函数。不像普通的生成<span class="_ _c"></span></div><div class="t m0 x5 h9 y30c1 ff1 fs3 fc0 sc0 ls0 ws119d">器，<span class="_ _c"></span>一个使用 <span class="ff6 ws119e">yield<span class="_ _1e"> </span>from </span><span class="ws771">被调用的函数可以返回一个作为 <span class="ff6 ws119e">yield<span class="_ _1e"> </span>from </span>语句结果的值。</span></div><div class="t m0 x5 h7 y30c2 ff1 fs3 fc0 sc0 ls0 ws14">关于 <span class="ff6 ws5b8">yield<span class="_ _11"> </span>from </span>的更多信息可以在 <span class="ff4 fc3 ws9c">PEP 380 </span>中找到。</div><div class="t m0 x0 h9 y28ec ff1 fs3 fc0 sc0 ls0 wsa0">最后，如果使用生成器<span class="_ _6"></span>编程，要提醒你的是它还<span class="_ _6"></span>是有很多缺点的。特别是，<span class="_ _6"></span>你得不</div><div class="t m0 x5 h7 y30c3 ff1 fs3 fc0 sc0 ls0 ws119f">到<span class="_ _6"></span>任何<span class="_ _6"></span>线<span class="_ _6"></span>程<span class="_ _6"></span>可<span class="_ _6"></span>以提<span class="_ _6"></span>供<span class="_ _6"></span>的<span class="_ _6"></span>好<span class="_ _6"></span>处。例<span class="_ _6"></span>如，<span class="_ _6"></span>如<span class="_ _6"></span>果<span class="_ _6"></span>你执<span class="_ _6"></span>行 <span class="ff4 ws11a0">CPU </span><span class="ws11a1">依<span class="_ _6"></span>赖<span class="_ _6"></span>或 <span class="ff4 ws11a2">I/<span class="_ _6"></span>O </span><span class="wsa0">阻塞<span class="_ _6"></span>程<span class="_ _6"></span>序，<span class="_ _6"></span>它<span class="_ _6"></span>会将</span></span></div><div class="t m0 x5 h9 y30c4 ff1 fs3 fc0 sc0 ls13 wse5">整个任务挂起知道操作完成<span class="_ _1"></span>。为了解决这个问题，你只能选择将操作委派给另外一个<span class="_ _c"></span></div><div class="t m0 x5 h7 y30c5 ff1 fs3 fc0 sc0 ls0 ws528">可以独立运行的线程或进程。另外一个限制是大部分 <span class="ff4 wse61">Python </span>库并不能很好的兼容基于</div><div class="t m0 x5 h9 y30c6 ff1 fs3 fc0 sc0 ls0 wsa0">生<span class="_ _6"></span>成器<span class="_ _6"></span>的<span class="_ _6"></span>线<span class="_ _6"></span>程。<span class="_ _6"></span>如<span class="_ _6"></span>果你<span class="_ _6"></span>选<span class="_ _6"></span>择<span class="_ _6"></span>这<span class="_ _6"></span>个<span class="_ _6"></span>方案，<span class="_ _6"></span>你<span class="_ _6"></span>会<span class="_ _6"></span>发<span class="_ _6"></span>现<span class="_ _6"></span>你<span class="_ _6"></span>需要<span class="_ _6"></span>自<span class="_ _6"></span>己<span class="_ _6"></span>改<span class="_ _6"></span>写<span class="_ _6"></span>很多<span class="_ _6"></span>标<span class="_ _6"></span>准<span class="_ _6"></span>库<span class="_ _6"></span>函<span class="_ _6"></span>数。作</div><div class="t m0 x5 h7 y30c7 ff1 fs3 fc0 sc0 ls0 ws11a3">为本节提到的协程和相关技术的一个基础背景，可以查看 <span class="ff4 fc3 ws11a4">PEP 342 </span><span class="ls16b">和</span><span class="fc3">“协程和并发的</span></div><div class="t m0 x5 h9 y30c8 ff1 fs3 fc3 sc0 ls0">一门有趣课程”</div><div class="t m0 x0 h7 y30c9 ff4 fs3 fc0 sc0 ls0 ws11a5">PEP 3156 <span class="ff1 ws11a6">同样有一<span class="_ _6"></span>个关于使<span class="_ _6"></span>用协程的<span class="_ _6"></span>异步 </span><span class="ws118d">I/O <span class="ff1 wsa0">模型。<span class="_ _6"></span>特别的，你<span class="_ _6"></span>不可能自<span class="_ _6"></span>己去实</span></span></div><div class="t m0 x5 h7 y30ca ff1 fs3 fc0 sc0 ls42 ws11a7">现一个底层的协程调度器。不过<span class="_ _c"></span>，关于协程的思想是很多流行库的基础，包括 <span class="ff4 fc3 ls0 wsa5">gev<span class="_ _1"></span>en<span class="_ _1"></span>t<span class="fc0">,</span></span></div><div class="t m0 x5 h7 y2b3d ff4 fs3 fc3 sc0 ls0 wsa5">greenlet<span class="fc0 ls83">,</span><span class="wsd0">Stac<span class="_ _1"></span>kless Python <span class="ff1 fc0">以及其他类似工程。</span></span></div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 wsd97">14.12.<span class="_ _36"> </span>12.12 <span class="ff1 ws104c">使用生成器代替线程 </span>484</div><a class="l" href="http://www.python.org/dev/peps/pep-0380"><div class="d m1" style="border-style:none;position:absolute;left:397.219500px;bottom:394.606500px;width:45.358000px;height:16.821000px;background-color:rgba(255,255,255,0.000001);"></div></a><a class="l" href="http://www.python.org/dev/peps/pep-0342"><div class="d m1" style="border-style:none;position:absolute;left:562.020000px;bottom:253.759500px;width:45.307000px;height:16.821000px;background-color:rgba(255,255,255,0.000001);"></div></a><a class="l" href="http://www.dabeaz.com/coroutines"><div class="d m1" style="border-style:none;position:absolute;left:659.383500px;bottom:254.551500px;width:83.687000px;height:14.016000px;background-color:rgba(255,255,255,0.000001);"></div></a><a class="l" href="http://www.dabeaz.com/coroutines"><div class="d m1" style="border-style:none;position:absolute;left:108.000000px;bottom:232.882500px;width:83.686000px;height:14.016000px;background-color:rgba(255,255,255,0.000001);"></div></a><a class="l" href="http://www.gevent.org/"><div class="d m1" style="border-style:none;position:absolute;left:730.756500px;bottom:177.919500px;width:32.853000px;height:16.821000px;background-color:rgba(255,255,255,0.000001);"></div></a><a class="l" href="http://pypi.python.org/pypi/greenlet"><div class="d m1" style="border-style:none;position:absolute;left:108.000000px;bottom:156.250500px;width:40.325000px;height:16.821000px;background-color:rgba(255,255,255,0.000001);"></div></a><a class="l" href="http://www.stackless.com/"><div class="d m1" style="border-style:none;position:absolute;left:179.211000px;bottom:156.250500px;width:87.117000px;height:16.821000px;background-color:rgba(255,255,255,0.000001);"></div></a></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
