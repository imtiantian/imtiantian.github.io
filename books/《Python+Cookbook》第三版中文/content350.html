<div id="pf15e" class="pf w0 h0" data-page-no="15e"><div class="pc pc15e w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg15e.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 h9 y2a ff1 fs3 fc0 sc0 ls5">如<span class="ff6 ls0 ws25d">pickle </span><span class="ls0 wsa0">。因此，为了让你创建的类是“正确”的，你需要确保这个属性也设置正确</span></div><div class="t m0 x5 h9 y2b ff1 fs3 fc0 sc0 ls0">了。</div><div class="t m0 x0 h9 y8dd ff1 fs3 fc0 sc0 ls0 wsc6a">如<span class="_ _6"></span>果<span class="_ _6"></span>你<span class="_ _6"></span>想<span class="_ _6"></span>创<span class="_ _0"></span>建的<span class="_ _6"></span>类<span class="_ _0"></span>需要<span class="_ _0"></span>一个<span class="_ _0"></span>不同<span class="_ _0"></span>的元<span class="_ _6"></span>类，<span class="_ _0"></span>可以<span class="_ _0"></span>通过 <span class="ff6 wsc6b">types.new class()<span class="_ _18"> </span></span><span class="wsa0">第三<span class="_ _0"></span>个参</span></div><div class="t m0 x5 h9 y99 ff1 fs3 fc0 sc0 ls0">数传递给它。例如：</div><div class="t m0 x5 h10 y249e ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="fca ws146">import <span class="fcc">abc</span></span></div><div class="t m0 x5 hf y249f ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws15f">Stock <span class="fc6 ls33">=</span><span class="ws13a">types<span class="fc6 ls34">.</span>new_class(<span class="ff9 fc9 ls34">&apos;</span><span class="fc9">Stock<span class="ff9 ws13b">&apos;</span></span><span class="ws4">, (), {<span class="ff9 fc9 ws13b">&apos;</span></span><span class="fc9">metaclass<span class="ff9 ls34">&apos;</span></span><span class="ws13b">: abc<span class="fc6 ls34">.</span>ABCMeta},</span></span></span></div><div class="t m0 x5 hf y24a0 ff7 fs5 fc5 sc0 ls0 ws38e">... <span class="fca ws146">lambda <span class="ff8 fc0 ws4">ns: ns<span class="fc6 ls34">.</span>update(cls_dict))</span></span></div><div class="t m0 x5 h10 y24a1 ff7 fs5 fc5 sc0 ls0">...</div><div class="t m0 x5 hf y24a2 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws13a">Stock<span class="fc6">.</span><span class="ws2a3">__module__ <span class="fc6 ls33">=</span>__name__</span></span></div><div class="t m0 x5 hf y24a3 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0">Stock</span></div><div class="t m0 x5 hf y24a4 ff8 fs5 fc8 sc0 ls0 ws145">&lt;class <span class="ff9 ls34">&apos;</span><span class="ws13a">__main__.Stock<span class="ff9 ls34">&apos;</span>&gt;</span></div><div class="t m0 x5 hf y24a5 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fca ws13a">type<span class="fc0">(Stock)</span></span></div><div class="t m0 x5 hf y24a6 ff8 fs5 fc8 sc0 ls0 ws145">&lt;class <span class="ff9 ls34">&apos;</span><span class="ws13a">abc.ABCMeta<span class="ff9 ls34">&apos;</span>&gt;</span></div><div class="t m0 x5 hf y24a7 ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h9 y24a8 ff1 fs3 fc0 sc0 ls0">第三个参数还可以包含其他的关键字参数。比如，一个类的定义如下：</div><div class="t m0 x5 hf y24a9 ff7 fs5 fca sc0 ls0 ws16a">class <span class="fcc ws156">Spam<span class="ff8 fc0 ws4">(Base, debug<span class="fc6 ls34">=</span><span class="fca ws13a">True</span><span class="ws13b">, typecheck<span class="fc6 ws13a">=<span class="fca">False</span></span>):</span></span></span></div><div class="t m0 x15 h10 y24aa ff7 fs5 fca sc0 ls0">pass</div><div class="t m0 x0 h9 y24ab ff1 fs3 fc0 sc0 ls0 wsc">那么可以将其翻译成如下的 <span class="ff6 ws23a">new<span class="_ _7"> </span>class() </span>调用形式：</div><div class="t m0 x5 hf y24ac ff8 fs5 fc0 sc0 ls0 ws13c">Spam <span class="fc6 ls32">=</span><span class="ws13a">types<span class="fc6">.</span>new_class(<span class="ff9 fc9 ws13b">&apos;</span><span class="fc9">Spam<span class="ff9 ls34">&apos;</span></span><span class="ws4">, (Base,),</span></span></div><div class="t m0 x24 hf y24ad ff8 fs5 fc0 sc0 ls34">{<span class="ff9 fc9">&apos;<span class="ff8 ls0 ws13a">debug</span><span class="ls0 ws13b">&apos;</span></span><span class="ls33">:<span class="fca ls0 ws13a">True</span><span class="ls32">,</span></span><span class="ff9 fc9">&apos;<span class="ff8 ls0 ws13a">typecheck</span>&apos;</span><span class="ls33">:<span class="fca ls0 ws13a">False<span class="fc0">},</span></span></span></div><div class="t m0 x24 hf y24ae ff7 fs5 fca sc0 ls0 ws1ff">lambda <span class="ff8 fc0 ws13b">ns: ns<span class="fc6 ls34">.</span>update(cls_dict))</span></div><div class="t m0 x0 h9 y24af ff6 fs3 fc0 sc0 ls0 ws196">new class()<span class="_ _18"> </span><span class="ff1 ls19a wsc40">第四个参数最神秘<span class="_ _d"></span>，<span class="_ _6"></span>它是一个用来接受类命名空间的映射对象的函<span class="_ _c"></span></span></div><div class="t m0 x5 h9 y24b0 ff1 fs3 fc0 sc0 ls22 wsc6c">数。通常这是一个普通的字典<span class="_ _c"></span>，但是<span class="_ _6"></span>它实际上是 <span class="ff6 ls0 ws9e2">prepare<span class="_ _e"> </span>() <span class="ff1 wsa0">方法<span class="_ _6"></span>返<span class="_ _6"></span>回的<span class="_ _6"></span>任<span class="_ _6"></span>意对<span class="_ _6"></span>象，</span></span></div><div class="t m0 x5 h7 y24b1 ff1 fs3 fc0 sc0 ls0 wsc6d">这个<span class="_ _6"></span>在 <span class="ff4 wsc6e">9.14 </span><span class="ls22 ws8a1">小节已经介绍过了。这个函数需要使用上面演示的 </span><span class="ff6 wsc6f">update() </span><span class="ls22 ws119">方法给命名<span class="_ _c"></span></span></div><div class="t m0 x5 h9 y24b2 ff1 fs3 fc0 sc0 ls0">空间增加内容。</div><div class="t m0 x5 he y24b3 ff2 fs2 fc4 sc0 ls0 wsadf">11.18.3 <span class="ff1">讨论</span></div><div class="t m0 x0 h9 y24b4 ff1 fs3 fc0 sc0 ls1a0 wsc70">很多时候如果能构造新的类对象是很有用的<span class="_ _1f"></span>。有个很熟悉的例子是调用<span class="_ _1d"></span></div><div class="t m0 x5 h9 y16c5 ff6 fs3 fc0 sc0 ls0 wsc71">collections.namedtuple() <span class="ff1">函数，例如：</span></div><div class="t m0 x5 hf y24b5 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws15f">Stock <span class="fc6 ls33">=</span><span class="ws13a">collections<span class="fc6">.</span>namedtuple(<span class="ff9 fc9 ls34">&apos;</span><span class="fc9">Stock<span class="ff9 ls34">&apos;</span></span><span class="ws13b">, [<span class="ff9 fc9">&apos;</span></span><span class="fc9">name<span class="ff9 ls34">&apos;</span></span><span class="ls33">,</span><span class="ff9 fc9 ws13b">&apos;</span><span class="fc9">shares<span class="ff9 ws13b">&apos;</span></span><span class="ls33">,<span class="ff9 fc9 ls34">&apos;</span></span><span class="fc9">price<span class="ff9 ls34">&apos;</span></span>])</span></span></div><div class="t m0 x5 hf y154e ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0">Stock</span></div><div class="t m0 x5 hf y24b6 ff8 fs5 fc8 sc0 ls0 ws145">&lt;class <span class="ff9 ls34">&apos;</span><span class="ws13a">__main__.Stock<span class="ff9 ls34">&apos;</span>&gt;</span></div><div class="t m0 x5 hf y24b7 ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h9 y24b8 ff6 fs3 fc0 sc0 ls0 wsc72">namedtuple() <span class="ff1 wsc73">使用 </span><span class="ws6cb">exec() <span class="ff1 wsa0">而不是上面介绍的技术。<span class="_ _c"></span>但是，下面通过一个简单的变</span></span></div><div class="t m0 x5 h9 y24b9 ff1 fs3 fc0 sc0 ls0">化，我们直接创建一个类：</div><div class="t m0 x5 h10 y83d ff7 fs5 fca sc0 ls0 ws146">import <span class="fcc">operator</span></div><div class="t m0 x5 h10 y83e ff7 fs5 fca sc0 ls0 ws146">import <span class="fcc">types</span></div><div class="t m0 x5 h10 ycf5 ff7 fs5 fca sc0 ls0 ws146">import <span class="fcc">sys</span></div><div class="t m0 x5 hf y840 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">named_tuple<span class="fc0 ws13b">(classname, fieldnames):</span></span></div><div class="t m0 x15 h11 y841 ffa fs5 fcd sc0 ls0 ws4"># Populate a dictionary of field property accessors</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 wsae0">11.18.<span class="_ _5"> </span>9.18 <span class="ff1 wsae1">以编程方式定义类 </span>341</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
