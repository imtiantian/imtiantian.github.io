<div id="pf248" class="pf w0 h0" data-page-no="248"><div class="pc pc248 w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg248.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 hf y1ab ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws159">p1 <span class="fc6 ls33">=</span><span class="ws13a">sample<span class="fc6 ls34">.</span>Point(<span class="fc7 ls34">2</span>,<span class="fc7 ls34">3</span>)</span></span></div><div class="t m0 x5 hf y1ac ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h7 y85b ff1 fs3 fc0 sc0 ls0 wsa0">如果略过的话，<span class="ff4 ws1404">P<span class="_ _1"></span>oin<span class="_ _1"></span>t <span class="ff1">对象就必须以更加复杂的方式来被创建：</span></span></div><div class="t m0 x5 h11 yc27 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ffa fcd ws4"># Usage if %extend Point is omitted</span></div><div class="t m0 x5 hf yc28 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws159">p1 <span class="fc6 ls33">=</span><span class="ws13a">sample<span class="fc6 ls34">.</span>Point()</span></span></div><div class="t m0 x5 hf yc29 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws13a">p1<span class="fc6 ls34">.</span><span class="ls33">x<span class="fc6 ls32">=</span></span><span class="fc7">2.0</span></span></div><div class="t m0 x5 hf yc2a ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws13a">p1<span class="fc6 ls34">.</span><span class="ls33">y<span class="fc6 ls32">=</span></span><span class="fc7">3</span></span></div><div class="t m0 x0 h7 y3819 ff1 fs3 fc0 sc0 ls0 ws5fe">第二个自定义涉及到对 <span class="ff6 ws147e">typemaps.i </span><span class="ws1277">库的引入和 <span class="ff6 ws147f">%apply </span><span class="ws889">指令，它会指示 <span class="ff4 ws1480">Swig </span>参数</span></span></div><div class="t m0 x5 h9 y2175 ff1 fs3 fc0 sc0 ls0 wsfd">签名 <span class="ff6 ws1481">int<span class="_ _1e"> </span>*remainder </span><span class="wsa0">要被当做是输出值。这个实际上是一个模式匹配规则。在接下来</span></div><div class="t m0 x5 h9 y381a ff1 fs3 fc0 sc0 ls0 ws1482">的所有声明中，任何时候只要碰上 <span class="ff6 ws1483">int<span class="_ _1e"> </span>*remainder </span><span class="wsa0">，他就会被作为输出。<span class="_ _1"></span>这个自定义</span></div><div class="t m0 x5 h9 y381b ff1 fs3 fc0 sc0 ls0 ws38">方法可以让 <span class="ff6 ws26f">divide() </span>函数返回两个值。</div><div class="t m0 x5 hf y381c ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws13a">sample<span class="fc6 ls34">.</span>divide(<span class="fc7">42</span>,<span class="fc7 ls34">8</span>)</span></div><div class="t m0 x5 hf y381d ff8 fs5 fc8 sc0 ls0 ws4">[5, 2]</div><div class="t m0 x5 hf y381e ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h9 y381f ff1 fs3 fc0 sc0 ls3d ws1484">最后一个涉及到 <span class="ff6 ls0 ws214">%typemap </span><span class="ws164">指令的自定义可能是这里展示的最高级的特性了。一个<span class="_ _1"></span></span></div><div class="t m0 x5 h7 y3820 ff4 fs3 fc0 sc0 ls0 ws1485">t<span class="_ _1"></span>yp<span class="_ _6"></span>emap <span class="ff1 ws1486">就是<span class="_ _6"></span>一个在<span class="_ _6"></span>输入<span class="_ _6"></span>中特定<span class="_ _6"></span>参数模<span class="_ _6"></span>式的<span class="_ _6"></span>规则。在<span class="_ _6"></span>本节<span class="_ _6"></span>中，一个 </span>typemap <span class="ff1 wsa0">被<span class="_ _6"></span>定义<span class="_ _6"></span>为</span></div><div class="t m0 x5 h7 y3821 ff1 fs3 fc0 sc0 ls0 ws1487">匹<span class="_ _6"></span>配<span class="_ _6"></span>参<span class="_ _0"></span>数<span class="_ _6"></span>模<span class="_ _6"></span>式 <span class="ff6 ws1488">(double<span class="_ _17"> </span>*a,<span class="_ _34"> </span>int<span class="_ _17"> </span>n) <span class="ff4 ls27d">.</span></span><span class="ls1a5">在</span><span class="ff4 ws1489">typemap </span><span class="ls24 ws148a">内部是一个 <span class="ff4 ls27e">C</span></span><span class="wsa0">代<span class="_ _6"></span>码<span class="_ _0"></span>片<span class="_ _6"></span>段，<span class="_ _6"></span>它<span class="_ _6"></span>告<span class="_ _0"></span>诉</span></div><div class="t m0 x5 h7 y1e35 ff4 fs3 fc0 sc0 ls0 ws148b">Swig <span class="ff1 ls17 ws148c">怎样将一个 </span><span class="ws587">Python <span class="ff1 ls17 ws148d">对象转换为相应的 </span><span class="ls27f">C<span class="ff1 ls17 ws148e">参数。本节代码使用了 </span></span><span class="ws643">Python <span class="ff1 ls17 wsf6">的缓存<span class="_ _1"></span></span></span></span></div><div class="t m0 x5 h7 y3822 ff1 fs3 fc0 sc0 ls2c ws148f">协议去匹配任何看上去类似双精度数组的输入参数（比如 <span class="ff4 ls0 ws1490">NumPy <span class="ff1 wsa0">数组、</span><span class="ws1491">array <span class="ff1 wsa0">模块创</span></span></span></div><div class="t m0 x5 h7 y3823 ff1 fs3 fc0 sc0 ls0 ws115a">建的数组等）<span class="_ _f"></span>，更多请参考 <span class="ff4 ws1d0">15.3 </span>小节。</div><div class="t m0 x0 h7 y736 ff1 fs3 fc0 sc0 ls280">在<span class="ff4 ls0 ws1492">t<span class="_ _1"></span>yp<span class="_ _6"></span>emap <span class="ff1 wsa0">代<span class="_ _6"></span>码<span class="_ _6"></span>内<span class="_ _6"></span>部，<span class="_ _0"></span><span class="ffe ws305">$</span></span><span class="ls281">1<span class="ff1 ls1d5">和</span></span><span class="ffe ws305">$</span><span class="ls281">2<span class="ff1 ls63 ws1493">这样的变量替换会获取 </span></span>t<span class="_ _c"></span>yp<span class="_ _6"></span>emap <span class="ff1 ws1494">模<span class="_ _6"></span>式<span class="_ _0"></span>的 </span><span class="ls282">C</span><span class="ff1 wsa0">参数</span></span></div><div class="t m0 x5 h7 y3824 ff1 fs3 fc0 sc0 ls0 ws1495">值（比如 <span class="ffe ws305">$<span class="ff4 ls283">1</span></span><span class="ws1496">映射为 <span class="ff6 ws1497">double<span class="_ _11"> </span>*a </span><span class="wsa0">）<span class="_ _f"></span>。<span class="_ _6"></span><span class="ffe ws305">$<span class="ff4 ws1498">input </span></span><span class="ls68 ws1c6">指向一个作为输入的 </span><span class="ff6 ws5f2">PyObject<span class="_ _11"> </span>* </span>参数，而</span></span></div><div class="t m0 x5 h9 y3825 ff16 fs3 fc0 sc0 ls0 ws305">$<span class="ff6 ws25d">argnum <span class="ff1">就代表参数的个数。</span></span></div><div class="t m0 x0 h7 y3826 ff1 fs3 fc0 sc0 ls0 ws663">编<span class="_ _6"></span>写和<span class="_ _6"></span>理<span class="_ _6"></span>解 <span class="ff4 ws1499">t<span class="_ _1"></span>yp<span class="_ _6"></span>emaps <span class="ff1 ws149a">是<span class="_ _6"></span>使<span class="_ _6"></span>用 </span><span class="ws149b">Swig <span class="ff1 ls13 wse5">最基本的前提<span class="_ _1"></span>。不仅是说代码更神秘，而且你<span class="_ _c"></span></span></span></span></div><div class="t m0 x5 h7 y3827 ff1 fs3 fc0 sc0 ls0 ws1326">需要理解 <span class="ff4 ws1133">Python C API </span><span class="ls284">和</span><span class="ff4 ws149c">Swig </span><span class="wsa0">和它交互的方式。<span class="ff4 ws149c">Swig </span>文档有更多这方面的细节，<span class="_ _c"></span>可</span></div><div class="t m0 x5 h9 y3828 ff1 fs3 fc0 sc0 ls0">以参考下。</div><div class="t m0 x0 h7 y71c ff1 fs3 fc0 sc0 ls0 ws149d">不过，<span class="_ _6"></span>如果你<span class="_ _6"></span>有大<span class="_ _6"></span>量的 <span class="ff4 ls265">C</span><span class="wsa0">代<span class="_ _6"></span>码需要<span class="_ _6"></span>被暴<span class="_ _6"></span>露为<span class="_ _6"></span>扩展模<span class="_ _6"></span>块。<span class="ff4 ws1476">Swig </span>是<span class="_ _6"></span>一个<span class="_ _6"></span>非常强<span class="_ _6"></span>大的<span class="_ _6"></span>工</span></div><div class="t m0 x5 h7 y3829 ff1 fs3 fc0 sc0 ls2d ws149e">具<span class="_ _1"></span>。关键点在于 <span class="ff4 ls0 ws149f">Swig </span><span class="ws1446">是一个处理 <span class="ff4 ls25f">C</span><span class="ws132">声明的编译器，通过强大的模式匹配和自定义组<span class="_ _c"></span></span></span></div><div class="t m0 x5 h7 y71e ff1 fs3 fc0 sc0 ls19 ws14a0">件，可以让你更改声明指定和类型处理方式。更多信息请去查阅 <span class="ff4 fc3 ls0 ws14a1">Swig <span class="ff1 wsaa7">网站 </span></span><span class="ws14a2">，还有 <span class="fc3 ls0">特</span></span></div><div class="t m0 x5 h7 y382a ff1 fs3 fc3 sc0 ls0 ws14">定于 <span class="ff4 ws5c">Python </span>的相关文档</div><div class="t m0 x5 hd y382b ff2 fs4 fc4 sc0 ls0 wsd91">17.10<span class="_ _e"> </span>15.10 <span class="ff1 ls7c">用</span><span class="wsce8">Cython <span class="ff1 ws165">包装 </span><span class="ls23d">C</span><span class="ff1">代码</span></span></div><div class="t m0 x5 he y382c ff2 fs2 fc4 sc0 ls0 wsadf">17.10.1 <span class="ff1">问题</span></div><div class="t m0 x0 h7 y382d ff1 fs3 fc0 sc0 ls0 ws14a3">你<span class="_ _6"></span>想<span class="_ _6"></span>使<span class="_ _0"></span>用 <span class="ff4 ws14a4">Cython </span><span class="ls24 ws14a5">来创建一个 </span><span class="ff4 ws644">Python </span><span class="ls24 ws14a6">扩展模块<span class="_ _c"></span>，用来包装某个已存在的 <span class="ff4 ls27e">C</span><span class="ls0 wsa0">函<span class="_ _6"></span>数</span></span></div><div class="t m0 x5 h9 y1111 ff1 fs3 fc0 sc0 ls0">库。</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 wsd97">17.10.<span class="_ _36"> </span>15.10 <span class="ff1 ls7f">用</span><span class="ws747">Cython <span class="ff1 ws16b">包装 </span><span class="ls246">C</span><span class="ff1 ws14a7">代码 </span>575</span></div><a class="l" href="http://www.swig.org/"><div class="d m1" style="border-style:none;position:absolute;left:621.888000px;bottom:417.867000px;width:52.270000px;height:16.821000px;background-color:rgba(255,255,255,0.000001);"></div></a><a class="l" href="http://www.swig.org/Doc2.0/Python.html"><div class="d m1" style="border-style:none;position:absolute;left:766.980000px;bottom:418.659000px;width:11.956000px;height:14.015000px;background-color:rgba(255,255,255,0.000001);"></div></a><a class="l" href="http://www.swig.org/Doc2.0/Python.html"><div class="d m1" style="border-style:none;position:absolute;left:108.000000px;bottom:396.198000px;width:129.044000px;height:16.821000px;background-color:rgba(255,255,255,0.000001);"></div></a></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
