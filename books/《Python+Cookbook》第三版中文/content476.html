<div id="pf1dc" class="pf w0 h0" data-page-no="1dc"><div class="pc pc1dc w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg1dc.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 h11 y1e8 ffa fs5 fcd sc0 ls0 ws4"># Nonparallel code</div><div class="t m0 x5 hf y1e9 ff8 fs5 fc0 sc0 ls0 ws155">results <span class="fc6 ls32">=</span><span class="fca ws13a">map</span><span class="ws4">(work, data)</span></div><div class="t m0 x5 h11 y903 ffa fs5 fcd sc0 ls0 ws4"># Parallel implementation</div><div class="t m0 x5 hf y1eb ff7 fs5 fca sc0 ls0 ws15a">with <span class="ff8 fc0 wsd67">ProcessPoolExecutor() </span><span class="ws157">as <span class="ff8 fc0">pool:</span></span></div><div class="t m0 x15 hf y1ec ff8 fs5 fc0 sc0 ls0 ws155">results <span class="fc6 ls32">=</span><span class="ws13a">pool<span class="fc6 ls34">.</span><span class="ws13b">map(work, data)</span></span></div><div class="t m0 x0 h9 y1ed ff1 fs3 fc0 sc0 ls0 wsc">另外，你可以使用 <span class="ff6 ws317">pool.submit() </span>来手动的提交单个任务：</div><div class="t m0 x5 h11 y2f7f ffa fs5 fcd sc0 ls0 ws4"># Some function</div><div class="t m0 x5 hf y2f80 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">work<span class="fc0">(x):</span></span></div><div class="t m0 x15 hf y2f81 ff8 fs5 fc6 sc0 ls0 ws13a">...</div><div class="t m0 x15 hf y2f82 ff7 fs5 fca sc0 ls0 ws146">return <span class="ff8 fc0">result</span></div><div class="t m0 x5 hf y2f83 ff7 fs5 fca sc0 ls0 ws15a">with <span class="ff8 fc0 wsd67">ProcessPoolExecutor() </span><span class="ws157">as <span class="ff8 fc0">pool:</span></span></div><div class="t m0 x15 hf y2f84 ff8 fs5 fc6 sc0 ls0 ws13a">...</div><div class="t m0 x15 h11 y2f85 ffa fs5 fcd sc0 ls0 ws4"># Example of submitting work to the pool</div><div class="t m0 x15 hf y2f86 ff8 fs5 fc0 sc0 ls0 ws147">future_result <span class="fc6 ls33">=</span><span class="ws13a">pool<span class="fc6 ls34">.</span><span class="ws4">submit(work, arg)</span></span></div><div class="t m0 x15 h11 y2f87 ffa fs5 fcd sc0 ls0 ws4"># Obtaining the result (blocks until done)</div><div class="t m0 x15 hf y2f88 ff8 fs5 fc0 sc0 ls32">r<span class="fc6 ls33">=</span><span class="ls0 ws13a">future_result<span class="fc6 ls34">.</span>result()</span></div><div class="t m0 x15 hf y2f89 ff8 fs5 fc6 sc0 ls0 ws13a">...</div><div class="t m0 x0 h9 y2eb7 ff1 fs3 fc0 sc0 lse ws1102">如果你手动提交一个任务，结果是一个 <span class="ff6 ls0 ws6aa">Future </span><span class="wsd8">实例<span class="_ _1"></span>。要获取最终结果，你需要调</span></div><div class="t m0 x5 h9 y2eb8 ff1 fs3 fc0 sc0 ls0 ws38">用它的 <span class="ff6 ws26f">result() </span>方法。它会阻塞进程直到结果被返回来。</div><div class="t m0 x0 h9 y2f8a ff1 fs3 fc0 sc0 ls0">如果不想阻塞，你还可以使用一个回调函数，例如：</div><div class="t m0 x5 hf y2f8b ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">when_done<span class="fc0">(r):</span></span></div><div class="t m0 x15 hf y2f8c ff7 fs5 fca sc0 ls0 ws156">print<span class="ff8 fc0 ws13a">(<span class="ff9 fc9 ls34">&apos;</span><span class="fc9">Got:<span class="ff9 ls34">&apos;</span></span><span class="ws13b">, r<span class="fc6 ls34">.</span>result())</span></span></div><div class="t m0 x5 hf y2f8d ff7 fs5 fca sc0 ls0 ws15a">with <span class="ff8 fc0 wsd67">ProcessPoolExecutor() </span><span class="ws157">as <span class="ff8 fc0">pool:</span></span></div><div class="t m0 x31 hf y2f8e ff8 fs5 fc0 sc0 ls0 ws147">future_result <span class="fc6 ls32">=</span><span class="ws13a">pool<span class="fc6 ls34">.</span><span class="ws13b">submit(work, arg)</span></span></div><div class="t m0 x31 hf y2f8f ff8 fs5 fc0 sc0 ls0 ws13a">future_result<span class="fc6 ls34">.</span>add_done_callback(when_done)</div><div class="t m0 x0 h9 y2f90 ff1 fs3 fc0 sc0 ls10c ws1103">回调函数接受一个 <span class="ff6 ls0 ws1104">Future <span class="ff1 wsa0">实<span class="_ _0"></span>例，<span class="_ _12"></span>被<span class="_ _12"></span>用<span class="_ _0"></span>来<span class="_ _12"></span>获<span class="_ _0"></span>取<span class="_ _12"></span>最<span class="_ _0"></span>终<span class="_ _12"></span>的<span class="_ _0"></span>结<span class="_ _12"></span>果<span class="_ _0"></span>（比<span class="_ _12"></span>如<span class="_ _0"></span>通<span class="_ _12"></span>过<span class="_ _0"></span>调<span class="_ _12"></span>用<span class="_ _0"></span>它<span class="_ _12"></span>的</span></span></div><div class="t m0 x5 h7 y2f91 ff4 fs3 fc0 sc0 ls0 ws1105">result() <span class="ff1 wsa0">方法）<span class="_ _f"></span>。<span class="_ _6"></span>尽管<span class="_ _6"></span>处<span class="_ _6"></span>理池<span class="_ _6"></span>很容<span class="_ _6"></span>易使<span class="_ _6"></span>用，<span class="_ _6"></span>在设<span class="_ _6"></span>计大<span class="_ _6"></span>程序<span class="_ _6"></span>的<span class="_ _6"></span>时候<span class="_ _6"></span>还是<span class="_ _6"></span>有很<span class="_ _6"></span>多<span class="_ _6"></span>需要<span class="_ _6"></span>注意<span class="_ _6"></span>的</span></div><div class="t m0 x5 h9 y2f92 ff1 fs3 fc0 sc0 ls0">地方，如下几点：</div><div class="t m0 x1f h9 y2f93 ffe fs3 fc0 sc0 lsbf">•<span class="ff1 ls0">这种并行处理技术只适用于那些可以被分解为互相独立部分的问题。</span></div><div class="t m0 x1f h9 y2f94 ffe fs3 fc0 sc0 lsbf">•<span class="ff1 ls18 ws110">被提交的任务必须是简单函数形式。对于方法、闭包和其他类型的并行执行还不</span></div><div class="t m0 x20 h9 y2f95 ff1 fs3 fc0 sc0 ls0">支持。</div><div class="t m0 x1f h7 yc26 ffe fs3 fc0 sc0 lsbf">•<span class="ff1 ls6b ws1106">函数参数和返回值必须兼容 </span><span class="ff4 ls0 wsa5">pic<span class="_ _1"></span>kle<span class="ff1 ls6b ws28f">，因为要使用到进程间的通信，所有解释器之<span class="_ _1"></span></span></span></div><div class="t m0 x20 h9 y2f96 ff1 fs3 fc0 sc0 ls0">间的交换数据必须被序列化</div><div class="t m0 x1f h9 y2f97 ffe fs3 fc0 sc0 lsbf">•<span class="ff1 ls0">被提交的任务函数不应保留状态或有副作用。除了打印日志之类简单的事情，</span></div><div class="t m0 x0 h9 y2f98 ff1 fs3 fc0 sc0 ls68 ws23f">一旦启动你不能控制子进程的任何行为，因此最好保持简单和纯洁—<span class="_ _8"></span>—函数不要去</div><div class="t m0 x5 h9 yb9b ff1 fs3 fc0 sc0 ls0">修改环境。</div><div class="t m0 x1f h7 y2f99 ffe fs3 fc0 sc0 lsbf">•<span class="ff1 ls5">在<span class="ff4 ls0 ws30">Unix </span><span class="ls0 wsc">上进程池通过调用 <span class="ff6 ws25d">fork() </span>系统调用被创建，</span></span></div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 ws21d">14.8.<span class="_ _36"> </span>12.8 <span class="ff1 ws600">简单的并行编程 </span>467</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
