<div id="pf1d9" class="pf w0 h0" data-page-no="1d9"><div class="pc pc1d9 w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg1d9.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 h7 y2a ff1 fs3 fc0 sc0 ls1e ws84d">系统上面创建 <span class="ff4 ls0 ws10d8">2000 </span><span class="ws10d9">个线程<span class="_ _1"></span>，系统显示 <span class="ff4 ls0 ws10da">Python </span><span class="ws10db">进程使用了超过 <span class="ff4 ls0 ws10dc">9GB <span class="ff1 wsa0">的<span class="_ _6"></span>虚<span class="_ _6"></span>拟内<span class="_ _6"></span>存。<span class="_ _6"></span>不</span></span></span></span></div><div class="t m0 x5 h9 y2b ff1 fs3 fc0 sc0 ls1e ws111">过<span class="_ _1"></span>，这个计算通常是有误差的。当创<span class="_ _1"></span>建一个线程时，操作系统会预留一个虚拟内<span class="_ _1"></span>存区</div><div class="t m0 x5 h7 y2c ff1 fs3 fc0 sc0 ls2b ws41b">域来放置线程的执行栈（通常是 <span class="ff4 ls0 ws10dd">8MB </span><span class="ws12e">大小）<span class="_ _f"></span>。但是这个内存只有一小片段被实际映射</span></div><div class="t m0 x5 h7 y2d ff1 fs3 fc0 sc0 ls13 wse5">到真实内存中<span class="_ _1"></span>。因此，<span class="ff4 ls0 wsa18">Python </span><span class="ws10de">进程使用到的真实内存其实很小（<span class="_ _c"></span>比如，对于 <span class="ff4 ls0 ws10df">2000 <span class="ff1">个</span></span></span></div><div class="t m0 x5 h7 y2e ff1 fs3 fc0 sc0 ls0 wsc">线程来讲，只使用到了 <span class="ff4 ws10e0">70MB </span><span class="ws38">的真实内存，而不是 <span class="ff4 wsa5">9GB</span><span class="wsa0">）<span class="_ _f"></span>。如果你担心虚拟内存大小，</span></span></div><div class="t m0 x5 h9 y2f ff1 fs3 fc0 sc0 ls0 ws14">可以使用 <span class="ff6 ws3ce">threading.stack<span class="_ _7"> </span>size() </span>函数来降低它。例如：</div><div class="t m0 x5 h10 y2f4c ff7 fs5 fca sc0 ls0 ws146">import <span class="fcc">threading</span></div><div class="t m0 x5 hf y2f4d ff8 fs5 fc0 sc0 ls0 ws13a">threading<span class="fc6">.</span>stack_size(<span class="fc7">65536</span>)</div><div class="t m0 x0 h7 y2f4e ff1 fs3 fc0 sc0 lsf ws10e1">如果你加上这条语句并再次运行前面的创建 <span class="ff4 ls0 ws10e2">2000 </span><span class="ws10e3">个线程试验<span class="_ _1"></span>，你会发现 <span class="ff4 ls0">Python</span></span></div><div class="t m0 x5 h7 y2f4f ff1 fs3 fc0 sc0 ls1f ws1b7">进程只使用到了大概 <span class="ff4 ls0 ws813">210MB </span><span class="ws113">的虚拟内存，而真实内存使用量没有变。注意线程栈大小</span></div><div class="t m0 x5 h7 y2f50 ff1 fs3 fc0 sc0 ls0 ws38">必须至少为 <span class="ff4 ws10e4">32768 </span><span class="wsa0">字节，通常是系统内存页大小（<span class="ff4 wsa5">4096</span>、<span class="ff4 wsd1">8192 </span>等）的整数倍。</span></div><div class="t m0 x5 hd y2f51 ff2 fs4 fc4 sc0 ls0 ws211">14.8<span class="_ _e"> </span>12.8 <span class="ff1">简单的并行编程</span></div><div class="t m0 x5 he y2f52 ff2 fs2 fc4 sc0 ls0 ws212">14.8.1 <span class="ff1">问题</span></div><div class="t m0 x0 h7 y2f53 ff1 fs3 fc0 sc0 ls6b ws10e5">你有个程序要执行 <span class="ff4 ls0 ws10e6">CPU </span><span class="ws10e7">密集型工作，你想让他利用多核 <span class="ff4 ls0 ws10e8">CPU </span><span class="ws28f">的优势来运行的快<span class="_ _c"></span></span></span></div><div class="t m0 x5 h9 y4be ff1 fs3 fc0 sc0 ls0">一点。</div><div class="t m0 x5 he yfcf ff2 fs2 fc4 sc0 ls0 ws212">14.8.2 <span class="ff1">解决方案</span></div><div class="t m0 x0 h9 y2f54 ff6 fs3 fc0 sc0 ls0 ws10e9">concurrent.futures <span class="ff1 ws10ea">库提供了一个 </span><span class="ws10eb">ProcessPoolExecutor <span class="ff1 wsa0">类，可被<span class="_ _6"></span>用来在一个单</span></span></div><div class="t m0 x5 h7 y2f55 ff1 fs3 fc0 sc0 ls0 ws107">独的 <span class="ff4 ws108">Python </span><span class="wsa0">解释器中执行计算密集型函数。不过，要使用它，<span class="_ _1"></span>你首先要有一些计算密</span></div><div class="t m0 x5 h7 y2f56 ff1 fs3 fc0 sc0 ls0 ws10ec">集型的任务。我们通过一个简单而实际的例子来演示它。假定你有个 <span class="ff4 ws10ed">Apac<span class="_ _c"></span>he web <span class="ff1">服务</span></span></div><div class="t m0 x5 h7 y2f57 ff1 fs3 fc0 sc0 ls0 ws14">器日志目录的 <span class="ff4 wsd7c">gzip </span>压缩包：</div><div class="t m0 x5 hf y2ba4 ff8 fs5 fc0 sc0 ls0">logs/</div><div class="t m0 x3c hf y2f58 ff8 fs5 fc0 sc0 ls0">20120701.log.gz</div><div class="t m0 x3c hf y2f59 ff8 fs5 fc0 sc0 ls0">20120702.log.gz</div><div class="t m0 x3c hf y2f5a ff8 fs5 fc0 sc0 ls0">20120703.log.gz</div><div class="t m0 x3c hf y2f5b ff8 fs5 fc0 sc0 ls0">20120704.log.gz</div><div class="t m0 x3c hf y2f5c ff8 fs5 fc0 sc0 ls0">20120705.log.gz</div><div class="t m0 x3c hf y2f5d ff8 fs5 fc0 sc0 ls0">20120706.log.gz</div><div class="t m0 x3c hf y2f5e ff8 fs5 fc0 sc0 ls0">...</div><div class="t m0 x0 h9 y2f5f ff1 fs3 fc0 sc0 ls0">进一步假设每个日志文件内容类似下面这样：</div><div class="t m0 x5 hf y2d05 ff8 fs5 fc0 sc0 ls0 ws4">124.115.6.12 - - [10/Jul/2012:00:18:50 -0500] &quot;GET /robots.txt ...&quot; 200 71</div><div class="t m0 x5 hf y2f60 ff8 fs5 fc0 sc0 ls0 ws4">210.212.209.67 - - [10/Jul/2012:00:18:51 -0500] &quot;GET /ply/ ...&quot; 200 11875</div><div class="t m0 x5 hf y2f61 ff8 fs5 fc0 sc0 ls0 ws4">210.212.209.67 - - [10/Jul/2012:00:18:51 -0500] &quot;GET /favicon.ico ...&quot; 404 369</div><div class="t m0 x5 hf yd5b ff8 fs5 fc0 sc0 ls0 ws4">61.135.216.105 - - [10/Jul/2012:00:20:04 -0500] &quot;GET /blog/atom.xml ...&quot; 304 -</div><div class="t m0 x5 hf y2f62 ff8 fs5 fc0 sc0 ls0">...</div><div class="t m0 x0 h7 y2f63 ff1 fs3 fc0 sc0 ls0 ws14">下面是一个脚本，在这些日志文件中查找出所有访问过 <span class="ff4 ws10ee">rob<span class="_ _6"></span>ots.txt </span>文件的主机：</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 ws21d">14.8.<span class="_ _36"> </span>12.8 <span class="ff1 ws600">简单的并行编程 </span>464</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
