<div id="pf3b" class="pf w0 h0" data-page-no="3b"><div class="pc pc3b w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg3b.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x0 h9 y2a ff1 fs3 fc0 sc0 ls0">下面是使用上述函数的方法：</div><div class="t m0 x5 hf y655 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws13a">re<span class="fc6 ls34">.</span>sub(<span class="ff9 fc9 ls34">&apos;</span><span class="fc9">python<span class="ff9 ls34">&apos;</span></span><span class="ws13b">, matchcase(<span class="ff9 fc9">&apos;</span></span><span class="fc9">snake<span class="ff9 ls34">&apos;</span></span><span class="ws13b">), text, flags<span class="fc6 ls34">=</span></span>re<span class="fc6 ls34">.</span>IGNORECASE)</span></div><div class="t m0 x5 hf y656 ff9 fs5 fc8 sc0 ls34">&apos;<span class="ff8 ls0 ws4">UPPER SNAKE, lower snake, Mixed Snake<span class="ff9">&apos;</span></span></div><div class="t m0 x5 hf y657 ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h7 y658 ff1 fs3 fc0 sc0 ls0 ws319">译者注： <span class="ff6 ws31a">matchcase(&apos;snake&apos;) </span><span class="ws31b">返回了一个回调函数 <span class="ff4 wsa5">(</span>参数必须是 <span class="ff6 ws31c">match </span><span class="wsa0">对象<span class="ff4 ls1b">)</span>，<span class="_ _1"></span>前</span></span></div><div class="t m0 x5 h9 y659 ff1 fs3 fc0 sc0 ls0 ws38">面一节提到过， <span class="ff6 ws19e">sub() </span>函数除了接受替换字符串外，还能接受一个回调函数。</div><div class="t m0 x5 he y65a ff2 fs2 fc4 sc0 ls0 ws135">4.6.3 <span class="ff1">讨论</span></div><div class="t m0 x0 h9 y65b ff1 fs3 fc0 sc0 ls14 ws31d">对于一般的忽略大小写的匹配操作<span class="_ _1"></span>，简单的传递一个 <span class="ff6 ls0 ws31e">re.IGNORECASE </span><span class="ws174">标志参数就<span class="_ _1"></span></span></div><div class="t m0 x5 h7 y65c ff1 fs3 fc0 sc0 ls30 ws31f">已经足够了。但是需要注意的是<span class="_ _c"></span>，这个对于某些需要大小写转换的 <span class="ff4 ls0 ws320">Unico<span class="_ _6"></span>de <span class="ff1 wsa0">匹<span class="_ _6"></span>配<span class="_ _6"></span>可能</span></span></div><div class="t m0 x5 h7 y65d ff1 fs3 fc0 sc0 ls0 ws14">还不够，参考 <span class="ff4 ws1d0">2.10 </span>小节了解更多细节。</div><div class="t m0 x5 hd y65e ff2 fs4 fc4 sc0 ls0 ws134">4.7<span class="_ _e"> </span>2.7 <span class="ff1">最短匹配模式</span></div><div class="t m0 x5 he y65f ff2 fs2 fc4 sc0 ls0 ws135">4.7.1 <span class="ff1">问题</span></div><div class="t m0 x0 h9 y660 ff1 fs3 fc0 sc0 ls63 ws21f">你正在试着用正则表达式匹配某个文本模式<span class="_ _c"></span>，但是它找到的是模式的最长可能匹<span class="_ _1"></span></div><div class="t m0 x5 h9 y661 ff1 fs3 fc0 sc0 ls0">配。而你想修改它变成查找最短的可能匹配。</div><div class="t m0 x5 he y662 ff2 fs2 fc4 sc0 ls0 ws135">4.7.2 <span class="ff1">解决方案</span></div><div class="t m0 x0 h7 y663 ff1 fs3 fc0 sc0 lse ws321">这个问题一般出现在需要匹配一对分隔符之间的文本的时候 <span class="ff4 ls1b">(</span><span class="wsd8">比如引号包含的字符</span></div><div class="t m0 x5 h7 y5a7 ff1 fs3 fc0 sc0 lsb">串<span class="ff4 ls0 wsa5">)<span class="ff1">。为了说明清楚，考虑如下的例子：</span></span></div><div class="t m0 x5 hf y664 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws155">str_pat <span class="fc6 ls32">=</span><span class="ws13a">re<span class="fc6">.</span>compile(<span class="fc9 ls34">r<span class="ff9">&apos;</span><span class="ls0">\&quot;(.*)\&quot;</span><span class="ff9">&apos;</span></span>)</span></span></div><div class="t m0 x5 hf y665 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws15f">text1 <span class="fc6 ls33">=</span><span class="ff9 fc9 ws13b">&apos;<span class="ff8 ws4">Computer says &quot;no.&quot;</span>&apos;</span></span></div><div class="t m0 x5 hf y666 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws13a">str_pat<span class="fc6 ls34">.</span>findall(text1)</span></div><div class="t m0 x5 hf y667 ff8 fs5 fc8 sc0 ls34">[<span class="ff9 ls0 ws13b">&apos;</span><span class="ls0 ws13a">no.<span class="ff9 ws13b">&apos;</span>]</span></div><div class="t m0 x5 hf y668 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws15f">text2 <span class="fc6 ls33">=</span><span class="ff9 fc9 ws13b">&apos;<span class="ff8 ws4">Computer says &quot;no.&quot; Phone says &quot;yes.&quot;</span>&apos;</span></span></div><div class="t m0 x5 hf y669 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws13a">str_pat<span class="fc6 ls34">.</span>findall(text2)</span></div><div class="t m0 x5 hf y66a ff8 fs5 fc8 sc0 ls34">[<span class="ff9 ls0 ws13b">&apos;</span><span class="ls0 ws4">no.&quot; Phone says &quot;yes.<span class="ff9 ws13b">&apos;</span>]</span></div><div class="t m0 x5 hf y66b ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h9 y66c ff1 fs3 fc0 sc0 ls0 ws322">在<span class="_ _6"></span>这<span class="_ _6"></span>个<span class="_ _6"></span>例<span class="_ _6"></span>子<span class="_ _6"></span>中，<span class="_ _6"></span>模<span class="_ _6"></span>式 <span class="ff6 ws303">r&apos;<span class="ffd ls84">\</span>&quot;(.*)<span class="ffd ls84">\</span><span class="ws323">&quot;&apos; </span></span><span class="ls6f ws2a7">的意图是匹配被双引号包含的文本<span class="_ _1"></span>。但是在正<span class="_ _1"></span></span></div><div class="t m0 x5 h7 y66d ff1 fs3 fc0 sc0 ls6b ws324">则表达式中 <span class="ff4 ls88">*</span><span class="ws28f">操作符是贪婪的，因此匹配操作会查找最长的可能匹配<span class="_ _c"></span>。于是在第二个</span></div><div class="t m0 x5 h9 y66e ff1 fs3 fc0 sc0 ls0 ws38">例子中搜索 <span class="ff6 ws19e">text2 </span>的时候返回结果并不是我们想要的。</div><div class="t m0 x0 h7 y66f ff1 fs3 fc0 sc0 ls0 ws14">为了修正这个问题，可以在模式中的 <span class="ff4 lsc">*</span><span class="wsa0">操作符后面加上<span class="ff4 ls89">?</span>修饰符，就像这样：</span></div><div class="t m0 x5 hf y670 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws155">str_pat <span class="fc6 ls32">=</span><span class="ws13a">re<span class="fc6">.</span>compile(<span class="fc9 ls34">r<span class="ff9">&apos;</span><span class="ls0">\&quot;(.*?)\&quot;</span><span class="ff9">&apos;</span></span>)</span></span></div><div class="t m0 x5 hf y671 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws13a">str_pat<span class="fc6 ls34">.</span>findall(text2)</span></div><div class="t m0 x5 hf y672 ff8 fs5 fc8 sc0 ls34">[<span class="ff9 ls0 ws13b">&apos;</span><span class="ls0 ws13a">no.<span class="ff9 ws13b">&apos;</span><span class="ls33">,</span></span><span class="ff9">&apos;</span><span class="ls0 ws13a">yes.</span><span class="ff9">&apos;</span><span class="ls0">]</span></div><div class="t m0 x5 hf y673 ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h9 y674 ff1 fs3 fc0 sc0 ls0">这样就使得匹配变成非贪婪模式，从而得到最短的匹配，也就是我们想要的结果。</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 ws13e">4.7.<span class="_ _5"> </span>2.7 <span class="ff1 ws325">最短匹配模式 </span>50</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
