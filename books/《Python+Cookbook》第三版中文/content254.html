<div id="pffe" class="pf w0 h0" data-page-no="fe"><div class="pc pcfe w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bgfe.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x0 h9 y2a ff1 fs3 fc0 sc0 ls0 wsa7d">可能<span class="_ _6"></span>两次<span class="_ _6"></span>调用 <span class="ff6 ws3d2">Base.<span class="_ _e"> </span>init<span class="_ _e"> </span>() </span><span class="ls19 ws22a">没什么坏处，但有时候却不是。另一方面<span class="_ _1"></span>，假设你</span></div><div class="t m0 x5 h9 y2b ff1 fs3 fc0 sc0 ls0 ws14">在代码中换成使用 <span class="ff6 ws472">super() </span>，结果就很完美了：</div><div class="t m0 x5 hf y1b7f ff7 fs5 fca sc0 ls0 ws16a">class <span class="fcc ws156">Base<span class="ff8 fc0">:</span></span></div><div class="t m0 x15 hf y1b80 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">__init__<span class="fc0">(<span class="fca">self</span>):</span></span></div><div class="t m0 x16 hf y1b81 ff7 fs5 fca sc0 ls0 ws156">print<span class="ff8 fc0 ls34">(<span class="ff9 fc9">&apos;<span class="ff8 ls0 ws13a">Base.__init__</span>&apos;</span><span class="ls0">)</span></span></div><div class="t m0 x5 hf y1b82 ff7 fs5 fca sc0 ls0 ws16a">class <span class="fcc ls34">A</span><span class="ff8 fc0">(Base):</span></div><div class="t m0 x15 hf y1b83 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">__init__<span class="fc0">(<span class="fca">self</span>):</span></span></div><div class="t m0 x16 hf y16b0 ff8 fs5 fca sc0 ls0 ws13a">super<span class="fc0">()<span class="fc6 ls34">.</span>__init__()</span></div><div class="t m0 x16 hf y16b1 ff7 fs5 fca sc0 ls0 ws156">print<span class="ff8 fc0 ls34">(<span class="ff9 fc9">&apos;<span class="ff8 ls0 ws13a">A.__init__</span>&apos;</span><span class="ls0">)</span></span></div><div class="t m0 x5 hf y1b84 ff7 fs5 fca sc0 ls0 ws16a">class <span class="fcc ls34">B</span><span class="ff8 fc0">(Base):</span></div><div class="t m0 x15 hf y1b85 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">__init__<span class="fc0">(<span class="fca">self</span>):</span></span></div><div class="t m0 x16 hf y1b86 ff8 fs5 fca sc0 ls0 ws13a">super<span class="fc0">()<span class="fc6 ls34">.</span>__init__()</span></div><div class="t m0 x16 hf y1b87 ff7 fs5 fca sc0 ls0 ws156">print<span class="ff8 fc0 ls34">(<span class="ff9 fc9">&apos;<span class="ff8 ls0 ws13a">B.__init__</span>&apos;</span><span class="ls0">)</span></span></div><div class="t m0 x5 hf y1b88 ff7 fs5 fca sc0 ls0 ws16a">class <span class="fcc ls34">C</span><span class="ff8 fc0">(A,B):</span></div><div class="t m0 x15 hf y1b89 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">__init__<span class="fc0">(<span class="fca">self</span>):</span></span></div><div class="t m0 x16 hf y1b8a ff8 fs5 fca sc0 ls0 ws13a">super<span class="fc0">()<span class="fc6 ls34">.</span><span class="wsa7e">__init__() <span class="ffa fcd ws4"># Only one call to super() here</span></span></span></div><div class="t m0 x16 hf y1b8b ff7 fs5 fca sc0 ls0 ws156">print<span class="ff8 fc0 ls34">(<span class="ff9 fc9">&apos;<span class="ff8 ls0 ws13a">C.__init__</span>&apos;</span><span class="ls0">)</span></span></div><div class="t m0 x0 h9 y1b8c ff1 fs3 fc0 sc0 ls0 ws911">运行这个新版本后，你会发现每个 <span class="ff6 ws308">init<span class="_ _e"> </span>() </span>方法只会被调用一次了：</div><div class="t m0 x5 hf y1b8d ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls32">c<span class="fc6 ls33">=</span><span class="ls0">C()</span></span></div><div class="t m0 x5 hf y1b8e ff8 fs5 fc8 sc0 ls0">Base.__init__</div><div class="t m0 x5 hf y1b8f ff8 fs5 fc8 sc0 ls0">B.__init__</div><div class="t m0 x5 hf y1b90 ff8 fs5 fc8 sc0 ls0">A.__init__</div><div class="t m0 x5 hf y1b91 ff8 fs5 fc8 sc0 ls0">C.__init__</div><div class="t m0 x5 hf y1b92 ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h7 y1b93 ff1 fs3 fc0 sc0 ls18 wsa7f">为了弄清它的原理，我们需要花点时间解释下 <span class="ff4 ls0 ws453">Python </span><span class="ws110">是如何实现继承的。对于你<span class="_ _1"></span></span></div><div class="t m0 x5 h7 y1a07 ff1 fs3 fc0 sc0 ls0 wsa0">定义的每一个类，<span class="_ _1"></span><span class="ff4 wsa80">Python <span class="ff1 wsa81">会计算出一个所谓的方法解析顺序 </span><span class="wsa82">(MR<span class="_ _1"></span>O) <span class="ff1 wsa83">列表。这个 </span><span class="wsa5">MR<span class="_ _c"></span>O</span></span></span></div><div class="t m0 x5 h9 y1b94 ff1 fs3 fc0 sc0 ls0">列表就是一个简单的所有基类的线性顺序表。例如：</div><div class="t m0 x5 hf y1b95 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls34">C<span class="fc6 ls0 ws13a">.<span class="fc0">__mro__</span></span></span></div><div class="t m0 x5 hf y1b96 ff8 fs5 fc8 sc0 ls0 ws155">(&lt;class <span class="ff9 ls34">&apos;</span><span class="ws13a">__main__.C<span class="ff9 ls34">&apos;</span><span class="ws13b">&gt;, &lt;class <span class="ff9 ls34">&apos;</span></span>__main__.A<span class="ff9 ls34">&apos;</span><span class="ws13b">&gt;, &lt;class <span class="ff9 ls34">&apos;</span></span>__main__.B<span class="ff9 ls34">&apos;</span>&gt;,</span></div><div class="t m0 x5 hf y1b97 ff8 fs5 fc8 sc0 ls0 ws145">&lt;class <span class="ff9 ls34">&apos;</span><span class="ws13a">__main__.Base<span class="ff9 ls34">&apos;</span><span class="ws16e">&gt;, &lt;class <span class="ff9 ls34">&apos;</span></span>object<span class="ff9 ls34">&apos;</span>&gt;)</span></div><div class="t m0 x5 hf y1b98 ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h7 y1b99 ff1 fs3 fc0 sc0 ls0 wsa0">为了<span class="_ _6"></span>实<span class="_ _6"></span>现<span class="_ _6"></span>继承，<span class="_ _6"></span><span class="ff4 ws49f">Python </span><span class="wsa84">会<span class="_ _6"></span>在 <span class="ff4 wsa85">MRO </span><span class="ls10 wsdf">列表上从左到右开始查找基类<span class="_ _c"></span>，直到找到第一</span></span></div><div class="t m0 x5 h9 y1b9a ff1 fs3 fc0 sc0 ls0">个匹配这个属性的类为止。</div><div class="t m0 x0 h7 y4ea ff1 fs3 fc0 sc0 ls0 wsa86">而这个 <span class="ff4 wsa87">MRO </span><span class="ls2b wsa88">列表的构造是通过一个 </span><span class="ff4 wsa89">C3 </span><span class="ls2b ws12e">线性化算法来实现的<span class="_ _1"></span>。我们不去深究这个</span></div><div class="t m0 x5 h7 y1b9b ff1 fs3 fc0 sc0 ls0 ws63">算法的数学原理，它实际上就是合并所有父类的 <span class="ff4 wsa8a">MR<span class="_ _1"></span>O <span class="ff1">列表并遵循如下三条准则：</span></span></div><div class="t m0 x1f h9 y1b9c ffe fs3 fc0 sc0 lsbf">•<span class="ff1 ls0">子类会先于父类被检查</span></div><div class="t m0 x1f h9 y1b9d ffe fs3 fc0 sc0 lsbf">•<span class="ff1 ls0">多个父类会根据它们在列表中的顺序被检查</span></div><div class="t m0 x1f h9 y1b9e ffe fs3 fc0 sc0 lsbf">•<span class="ff1 ls0">如果对下一个类存在两个合法的选择，选择第一个父类</span></div><div class="t m0 x0 h7 y1b9f ff1 fs3 fc0 sc0 ls0 wsa8b">老实说，你所要知道的就<span class="_ _6"></span>是 <span class="ff4 wsa8c">MR<span class="_ _c"></span>O <span class="ff1 ls3a ws153">列表中的类顺<span class="_ _6"></span>序会让你定义的任意类层级关系变</span></span></div><div class="t m0 x5 h9 y19fc ff1 fs3 fc0 sc0 ls0">得有意义。</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 ws9da">10.7.<span class="_ _5"> </span>8.7 <span class="ff1 ws292">调用父类方法 </span>245</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
