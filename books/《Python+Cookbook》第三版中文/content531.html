<div id="pf213" class="pf w0 h0" data-page-no="213"><div class="pc pc213 w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg213.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x0 h9 y2a ff1 fs3 fc0 sc0 ls3a ws153">这种方法的问题在于它很容易遗漏其他情况，比如没有任何异常抛出的时候。那么</div><div class="t m0 x5 h9 y2b ff1 fs3 fc0 sc0 ls0">你还得需要增加另外的检测过程，如下面这样：</div><div class="t m0 x5 hf y48d ff7 fs5 fca sc0 ls0 ws16a">class <span class="fcc ws156">TestConversion<span class="ff8 fc0 ws13a">(unittest<span class="fc6 ls34">.</span>TestCase):</span></span></div><div class="t m0 x15 hf y48e ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">test_bad_int<span class="fc0">(<span class="fca">self</span>):</span></span></div><div class="t m0 x16 hf y48f ff7 fs5 fca sc0 ls0 ws156">try<span class="ff8 fc0">:</span></div><div class="t m0 x17 hf y490 ff8 fs5 fc0 sc0 ls32">r<span class="fc6 ls33">=</span><span class="ls0 ws13a">parse_int(<span class="ff9 fc9 ls34">&apos;</span><span class="fc9">N/A<span class="ff9 ls34">&apos;</span></span>)</span></div><div class="t m0 x16 hf y7ab ff7 fs5 fca sc0 ls0 ws146">except <span class="ff8 ws2a3">ValueError </span><span class="ws157">as <span class="ff8 fc0">e:</span></span></div><div class="t m0 x17 hf y1760 ff8 fs5 fca sc0 ls0 ws13a">self<span class="fc6">.<span class="fc0">assertEqual(</span></span>type<span class="fc0 ws13c">(e), </span>ValueError<span class="fc0">)</span></div><div class="t m0 x16 hf y1761 ff7 fs5 fca sc0 ls0 ws156">else<span class="ff8 fc0">:</span></div><div class="t m0 x17 hf y1762 ff8 fs5 fca sc0 ls0 ws13a">self<span class="fc6">.<span class="fc0">fail(<span class="ff9 fc9 ls34">&apos;</span><span class="fc9 ws13b">ValueError not raised<span class="ff9 ls34">&apos;</span></span>)</span></span></div><div class="t m0 x0 h9 y3397 ff6 fs3 fc0 sc0 ls0 ws2dc">assertRaises() <span class="ff1">方法会处理所有细节，因此你应该使用它。</span></div><div class="t m0 x0 h9 y3398 ff6 fs3 fc0 sc0 ls0 ws12a0">assertRaises() <span class="ff1 lsc8 wsa6f">的一个缺点是它测不了异常具体的值是多少<span class="_ _c"></span>。为了测试异常值<span class="_ _c"></span>，<span class="_ _1"></span></span></div><div class="t m0 x5 h9 y3399 ff1 fs3 fc0 sc0 lse ws12a1">可以使用 <span class="ff6 ls0 ws12a2">assertRaisesRegex() </span><span class="wsd8">方法，它可同时测试异常的存在以及通过正则式匹配</span></div><div class="t m0 x5 h9 yd7d ff1 fs3 fc0 sc0 ls0">异常的字符串表示。例如：</div><div class="t m0 x5 hf y339a ff7 fs5 fca sc0 ls0 ws16a">class <span class="fcc ws156">TestConversion<span class="ff8 fc0 ws13a">(unittest<span class="fc6 ls34">.</span>TestCase):</span></span></div><div class="t m0 x15 hf y339b ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">test_bad_int<span class="fc0">(<span class="fca">self</span>):</span></span></div><div class="t m0 x16 hf y339c ff8 fs5 fca sc0 ls0 ws13a">self<span class="fc6">.<span class="fc0">assertRaisesRegex(</span></span>ValueError<span class="fc0 ls32">,<span class="ff9 fc9 ls34">&apos;</span></span><span class="fc9 ws4">invalid literal .*<span class="ff9 ls34">&apos;</span><span class="fc0">,</span></span></div><div class="t m0 x4f hf y1e7f ff8 fs5 fc0 sc0 ls0 ws2a3">parse_int, <span class="ff9 fc9 ls34">&apos;</span><span class="fc9 ws13a">N/A<span class="ff9 ls34">&apos;</span></span>)</div><div class="t m0 x0 h9 y1f94 ff6 fs3 fc0 sc0 ls0 ws12a3">assertRaises() <span class="ff1 ls111">和</span><span class="ws12a4">assertRaisesRegex() <span class="ff1 ls68 ws23f">还有一个容易忽略的地方就是它们还能</span></span></div><div class="t m0 x5 h9 y339d ff1 fs3 fc0 sc0 ls0">被当做上下文管理器使用：</div><div class="t m0 x5 hf y339e ff7 fs5 fca sc0 ls0 ws16a">class <span class="fcc ws156">TestConversion<span class="ff8 fc0 ws13a">(unittest<span class="fc6 ls34">.</span>TestCase):</span></span></div><div class="t m0 x15 hf y339f ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">test_bad_int<span class="fc0">(<span class="fca">self</span>):</span></span></div><div class="t m0 x16 hf y33a0 ff7 fs5 fca sc0 ls0 ws218">with <span class="ff8 ws13a">self<span class="fc6 ls34">.</span><span class="fc0">assertRaisesRegex(</span>ValueError<span class="fc0 ls33">,<span class="ff9 fc9 ls34">&apos;</span></span><span class="fc9 ws13b">invalid literal .*<span class="ff9">&apos;</span><span class="fc0">):</span></span></span></div><div class="t m0 x17 hf y33a1 ff8 fs5 fc0 sc0 ls32">r<span class="fc6 ls33">=</span><span class="ls0 ws13a">parse_int(<span class="ff9 fc9 ls34">&apos;</span><span class="fc9">N/A<span class="ff9 ls34">&apos;</span></span>)</span></div><div class="t m0 x0 h9 y33a2 ff1 fs3 fc0 sc0 ls0">但你的测试涉及到多个执行步骤的时候这种方法就很有用了。</div><div class="t m0 x5 hd y33a3 ff2 fs4 fc4 sc0 ls0 ws211">16.4<span class="_ _e"> </span>14.4 <span class="ff1">将测试输出用日志记录到文件中</span></div><div class="t m0 x5 he y33a4 ff2 fs2 fc4 sc0 ls0 ws212">16.4.1 <span class="ff1">问题</span></div><div class="t m0 x0 h9 y6cc ff1 fs3 fc0 sc0 ls0">你希望将单元测试的输出写到到某个文件中去，而不是打印到标准输出。</div><div class="t m0 x5 he y33a5 ff2 fs2 fc4 sc0 ls0 ws212">16.4.2 <span class="ff1">解决方案</span></div><div class="t m0 x0 h9 y33a6 ff1 fs3 fc0 sc0 ls0">运行单元测试一个常见技术就是在测试文件底部加入下面这段代码片段：</div><div class="t m0 x5 h10 y46a ff7 fs5 fca sc0 ls0 ws146">import <span class="fcc">unittest</span></div><div class="t m0 x5 hf y33a7 ff7 fs5 fca sc0 ls0 ws16a">class <span class="fcc ws156">MyTest<span class="ff8 fc0 ws13a">(unittest<span class="fc6 ls34">.</span>TestCase):</span></span></div><div class="t m0 x15 h10 y33a8 ff7 fs5 fca sc0 ls0">pass</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 ws21d">16.4.<span class="_ _36"> </span>14.4 <span class="ff1 ws609">将测试输出用日志记录到文件中 </span>522</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
