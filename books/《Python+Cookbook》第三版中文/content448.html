<div id="pf1c0" class="pf w0 h0" data-page-no="1c0"><div class="pc pc1c0 w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg1c0.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x17 hf y1ab ff8 fs5 fca sc0 ls0 ws13a">self<span class="fc6">.<span class="fc0">done_sock</span><span class="ls34">.</span><span class="fc0">recv(<span class="fc7 ls34">1</span>)</span></span></div><div class="t m0 x16 hf y1ac ff8 fs5 fca sc0 ls0 ws13a">self<span class="fc6">.<span class="fc0 ws155">pending </span><span class="ls33">=</span><span class="fc0">[]</span></span></div><div class="t m0 x0 h9 y2d2a ff1 fs3 fc0 sc0 ls0 wsa0">在代码中，<span class="_ _6"></span><span class="ff6 ws9a1">run() </span><span class="ls51 ws1c8">方法被用来将工作提交给回调函数池，处理完成后被激发。实际<span class="_ _1"></span></span></div><div class="t m0 x5 h9 y2d2b ff1 fs3 fc0 sc0 ls0 ws1040">工作<span class="_ _6"></span>被提<span class="_ _6"></span>交给 <span class="ff6 ws1041">ThreadPoolExecutor </span><span class="wsa0">实<span class="_ _6"></span>例。不过<span class="_ _6"></span>一个<span class="_ _6"></span>难点<span class="_ _6"></span>是协<span class="_ _6"></span>调计<span class="_ _6"></span>算结<span class="_ _6"></span>果和<span class="_ _6"></span>事件循<span class="_ _6"></span>环，</span></div><div class="t m0 x5 h7 y2d2c ff1 fs3 fc0 sc0 ls17 ws1042">为了解决它，我们创建了一对 <span class="ff4 ls0 ws1043">sock<span class="_ _c"></span>et <span class="ff1 ls17 wsf6">并将其作为某种信号量机制来使用。当线程池完</span></span></div><div class="t m0 x5 h7 y2d2d ff1 fs3 fc0 sc0 ls0 ws1044">成工<span class="_ _6"></span>作后，它<span class="_ _6"></span>会执行<span class="_ _6"></span>类中<span class="_ _6"></span>的 <span class="ff6 ws1045">complete() </span><span class="ws1046">方法。这<span class="_ _6"></span>个方<span class="_ _6"></span>法再某<span class="_ _6"></span>个 <span class="ff4 ws1047">so<span class="_ _6"></span>c<span class="_ _1"></span>k<span class="_ _1"></span>et <span class="ff1 wsa0">上写<span class="_ _6"></span>入字<span class="_ _6"></span>节之</span></span></span></div><div class="t m0 x5 h7 y1cef ff1 fs3 fc0 sc0 ls1f ws9fb">前会讲挂起的回调函数和结果放入队列中。 <span class="ff6 ls0 ws1048">fileno() </span><span class="ws1049">方法返回另外的那个 <span class="ff4 ls0 wsa5">so<span class="_ _6"></span>c<span class="_ _1"></span>k<span class="_ _1"></span>et<span class="ff1 wsa0">。因</span></span></span></div><div class="t m0 x5 h9 y2d2e ff1 fs3 fc0 sc0 ls0 ws104a">此，这个字节被写入时，它会通知事件循环，然后 <span class="ff6 ws1d1">handle<span class="_ _7"> </span>receive() </span><span class="wsa0">方法被激活并为</span></div><div class="t m0 x5 h9 y1463 ff1 fs3 fc0 sc0 ls1e ws111">所有之前提交的工作执行回调函数<span class="_ _1"></span>。坦白讲<span class="_ _1"></span>，说了这么多连我自己都晕了。下面<span class="_ _1"></span>是一</div><div class="t m0 x5 h9 y1464 ff1 fs3 fc0 sc0 ls0">个简单的服务器，演示了如何使用线程池来实现耗时的计算：</div><div class="t m0 x5 h11 y413 ffa fs5 fcd sc0 ls0 ws4"># A really bad Fibonacci implementation</div><div class="t m0 x5 hf y2d2f ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">fib<span class="fc0">(n):</span></span></div><div class="t m0 x15 hf y2d30 ff7 fs5 fca sc0 ls0 ws157">if <span class="ff8 fc0 ls33">n<span class="fc6 ls32">&lt;<span class="fc7 ls34">2</span></span><span class="ls0">:</span></span></div><div class="t m0 x16 hf y2d31 ff7 fs5 fca sc0 ls0 ws146">return <span class="ff8 fc7">1</span></div><div class="t m0 x15 hf y2142 ff7 fs5 fca sc0 ls0 ws156">else<span class="ff8 fc0">:</span></div><div class="t m0 x16 hf y2d32 ff7 fs5 fca sc0 ls0 ws146">return <span class="ff8 fc0 ws15f">fib(n <span class="fc6 ls33">-</span><span class="fc7 ws13a">1</span><span class="ls33">)<span class="fc6 ls32">+</span></span><span class="ws458">fib(n <span class="fc6 ls32">-<span class="fc7 ls34">2</span></span>)</span></span></div><div class="t m0 x5 hf y1a86 ff7 fs5 fca sc0 ls0 ws16a">class <span class="fcc ws156">UDPFibServer<span class="ff8 fc0">(UDPServer):</span></span></div><div class="t m0 x15 hf y2d33 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">handle_receive<span class="fc0 ls34">(</span><span class="fca">self<span class="fc0">):</span></span></span></div><div class="t m0 x16 hf y2d34 ff8 fs5 fc0 sc0 ls0 ws13b">msg, addr <span class="fc6 ls33">=</span><span class="fca ws13a">self<span class="fc6 ls34">.</span><span class="fc0">sock<span class="fc6 ls34">.</span>recvfrom(<span class="fc7">128</span>)</span></span></div><div class="t m0 x16 hf y2d35 ff8 fs5 fc0 sc0 ls32">n<span class="fc6 ls33">=<span class="fca ls0 ws13a">int<span class="fc0">(msg)</span></span></span></div><div class="t m0 x16 hf y2d36 ff8 fs5 fc0 sc0 ls0 ws13a">pool<span class="fc6">.</span><span class="ws4">run(fib, (n,), callback<span class="fc6 ls34">=</span><span class="ff7 fca ws146">lambda </span><span class="ws159">r: </span></span><span class="fca">self<span class="fc6 ls34">.</span></span><span class="ws13b">respond(r, addr))</span></div><div class="t m0 x15 hf y2d37 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">respond<span class="fc0 ls34">(</span><span class="fca">self<span class="fc0 ws13b">, result, addr):</span></span></span></div><div class="t m0 x16 hf y2d38 ff8 fs5 fca sc0 ls0 ws13a">self<span class="fc6">.<span class="fc0">sock</span><span class="ls34">.</span><span class="fc0">sendto(</span></span>str<span class="fc0">(result)<span class="fc6 ls34">.</span>encode(<span class="ff9 fc9 ls34">&apos;</span><span class="fc9">ascii<span class="ff9 ls34">&apos;</span></span><span class="ws4">), addr)</span></span></div><div class="t m0 x5 hf y252c ff7 fs5 fca sc0 ls0 ws157">if <span class="ff8 fc0 ws16d">__name__ <span class="fc6 ws159">== <span class="ff9 fc9 ls34">&apos;</span><span class="fc9 ws13a">__main__<span class="ff9 ls34">&apos;</span></span></span>:</span></div><div class="t m0 x15 hf y2d39 ff8 fs5 fc0 sc0 ls0 ws13c">pool <span class="fc6 ls32">=</span><span class="ws13a">ThreadPoolHandler(<span class="fc7">16</span>)</span></div><div class="t m0 x15 hf y2d3a ff8 fs5 fc0 sc0 ls0 ws1f5">handlers <span class="fc6 ls33">=</span><span class="ws13b">[ pool, UDPFibServer((<span class="ff9 fc9">&apos;&apos;</span><span class="ls34">,</span><span class="fc7 ws13a">16000</span>))]</span></div><div class="t m0 x15 hf y2d3b ff8 fs5 fc0 sc0 ls0">event_loop(handlers)</div><div class="t m0 x0 h7 y2d3c ff1 fs3 fc0 sc0 ls0 ws38">运行这个服务器，然后试着用其它 <span class="ff4 ws5c">Python </span>程序来测试它：</div><div class="t m0 x5 hf y2d3d ff7 fs5 fca sc0 ls0 ws15a">from <span class="fcc ws146">socket <span class="fca">import <span class="ff8 fc6">*</span></span></span></div><div class="t m0 x5 hf y2d3e ff8 fs5 fc0 sc0 ls0 ws13c">sock <span class="fc6 ls32">=</span><span class="ws4">socket(AF_INET, SOCK_DGRAM)</span></div><div class="t m0 x5 hf y2d3f ff7 fs5 fca sc0 ls0 ws139">for <span class="ff8 fc0 ls32">x</span><span class="ws160">in <span class="ff8 ws13a">range<span class="fc0 ls34">(</span><span class="fc7">40<span class="fc0">):</span></span></span></span></div><div class="t m0 x15 hf y2d40 ff8 fs5 fc0 sc0 ls0 ws13a">sock<span class="fc6 ls34">.</span>sendto(<span class="fca">str</span>(x)<span class="fc6 ls34">.</span>encode(<span class="ff9 fc9 ls34">&apos;</span><span class="fc9">ascii<span class="ff9 ls34">&apos;</span></span><span class="ws13b">), (<span class="ff9 fc9 ls34">&apos;</span></span><span class="fc9">localhost<span class="ff9 ls34">&apos;</span></span><span class="ls32">,</span><span class="fc7">16000</span>))</div><div class="t m0 x15 hf y2d41 ff8 fs5 fc0 sc0 ls0 ws13c">resp <span class="fc6 ls32">=</span><span class="ws13a">sock<span class="fc6 ls34">.</span>recvfrom(<span class="fc7">8192</span>)</span></div><div class="t m0 x15 hf y1d4a ff7 fs5 fca sc0 ls0 ws156">print<span class="ff8 fc0 ws13a">(resp[<span class="fc7 ls34">0</span>])</span></div><div class="t m0 x0 h9 y2d42 ff1 fs3 fc0 sc0 ls3a ws153">你应该能在不同窗口中重复的执行这个程序，并且不会影响到其他程序，尽管当数</div><div class="t m0 x5 h9 y2d43 ff1 fs3 fc0 sc0 ls0">字便越来越大时候它会变得越来越慢。</div><div class="t m0 x0 h9 y2d44 ff1 fs3 fc0 sc0 ls0 wsa0">已经阅读完了这一小<span class="_ _6"></span>节，那么你应该使用这里的<span class="_ _6"></span>代码吗？也许不会。你应该<span class="_ _6"></span>选择一</div><div class="t m0 x5 h9 y2d45 ff1 fs3 fc0 sc0 ls1e ws111">个可以完成同样任务的高级框架<span class="_ _1"></span>。不过<span class="_ _1"></span>，如果你理解了基本原理，你就能理解这<span class="_ _1"></span>些框</div><div class="t m0 x5 h9 y2d46 ff1 fs3 fc0 sc0 ls13 wse5">架所使用的核心技术<span class="_ _1"></span>。作为对回调函数编程的替代，事件驱动编码有时候会使用到协<span class="_ _c"></span></div><div class="t m0 x5 h7 y2d47 ff1 fs3 fc0 sc0 ls0 ws14">程，参考 <span class="ff4 ws2aa">12.12 </span>小节的一个例子。</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 wsd97">13.12.<span class="_ _36"> </span>11.12 <span class="ff1 ws36c">理解事件驱动的 </span><span class="ws102f">IO 439</span></div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
