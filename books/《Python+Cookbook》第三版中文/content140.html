<div id="pf8c" class="pf w0 h0" data-page-no="8c"><div class="pc pc8c w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg8c.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 hf y1ab ff8 fs5 fc0 sc0 ls0 ws16d">lognames <span class="fc6 ls32">=</span><span class="ws13a">gen_find(<span class="ff9 fc9 ws13b">&apos;</span><span class="fc9">access-log*<span class="ff9 ls34">&apos;</span></span><span class="ls32">,<span class="ff9 fc9 ls34">&apos;</span></span><span class="fc9">www<span class="ff9 ls34">&apos;</span></span>)</span></div><div class="t m0 x5 hf y1ac ff8 fs5 fc0 sc0 ls0 ws15f">files <span class="fc6 ls33">=</span>gen_opener(lognames)</div><div class="t m0 x5 hf y1ad ff8 fs5 fc0 sc0 ls0 ws15f">lines <span class="fc6 ls33">=</span>gen_concatenate(files)</div><div class="t m0 x5 hf y1ae ff8 fs5 fc0 sc0 ls0 ws155">pylines <span class="fc6 ls32">=</span><span class="ws13a">gen_grep(<span class="ff9 fc9 ls34">&apos;</span><span class="fc9">(?i)python<span class="ff9 ls34">&apos;</span></span><span class="ws13b">, lines)</span></span></div><div class="t m0 x5 hf y1af ff7 fs5 fca sc0 ls0 ws139">for <span class="ff8 fc0 ws13c">line </span><span class="ws157">in <span class="ff8 fc0">pylines:</span></span></div><div class="t m0 x15 hf y1b0 ff7 fs5 fca sc0 ls0 ws156">print<span class="ff8 fc0">(line)</span></div><div class="t m0 x0 h9 yf72 ff1 fs3 fc0 sc0 ls0 wsa0">如果将来的时候你想<span class="_ _6"></span>扩展管道，你甚至可以在生<span class="_ _6"></span>成器表达式中包装数据。<span class="_ _6"></span>比如，下</div><div class="t m0 x5 h9 yf73 ff1 fs3 fc0 sc0 ls0">面这个版本计算出传输的字节数并计算其总和。</div><div class="t m0 x5 hf yf74 ff8 fs5 fc0 sc0 ls0 ws16d">lognames <span class="fc6 ls32">=</span><span class="ws13a">gen_find(<span class="ff9 fc9 ws13b">&apos;</span><span class="fc9">access-log*<span class="ff9 ls34">&apos;</span></span><span class="ls32">,<span class="ff9 fc9 ls34">&apos;</span></span><span class="fc9">www<span class="ff9 ls34">&apos;</span></span>)</span></div><div class="t m0 x5 hf yf75 ff8 fs5 fc0 sc0 ls0 ws15f">files <span class="fc6 ls33">=</span>gen_opener(lognames)</div><div class="t m0 x5 hf yf76 ff8 fs5 fc0 sc0 ls0 ws15f">lines <span class="fc6 ls33">=</span>gen_concatenate(files)</div><div class="t m0 x5 hf yf77 ff8 fs5 fc0 sc0 ls0 ws155">pylines <span class="fc6 ls32">=</span><span class="ws13a">gen_grep(<span class="ff9 fc9 ls34">&apos;</span><span class="fc9">(?i)python<span class="ff9 ls34">&apos;</span></span><span class="ws13b">, lines)</span></span></div><div class="t m0 x5 hf yf78 ff8 fs5 fc0 sc0 ls0 ws2a3">bytecolumn <span class="fc6 ls32">=</span><span class="ws13a">(line<span class="fc6 ls34">.</span>rsplit(<span class="fca">None</span><span class="ls34">,</span><span class="fc7">1</span>)[<span class="fc7">1</span><span class="ls33">]</span><span class="ff7 fca ws139">for </span><span class="ws161">line <span class="ff7 fca ws160">in </span>pylines)</span></span></div><div class="t m0 x5 hf yf79 ff8 fs5 fca sc0 ls0 ws15f">bytes <span class="fc6 ls33">=<span class="fc0 ls34">(</span></span><span class="ws13a">int<span class="fc0 ws158">(x) </span><span class="ff7 ws139">for </span><span class="fc0 ls32">x</span><span class="ff7 ws157">in </span><span class="fc0 ws2a3">bytecolumn </span><span class="ff7 ws157">if </span><span class="fc0 ls33">x</span><span class="fc6 ws159">!= <span class="ff9 fc9 ls34">&apos;</span></span><span class="fc9">-<span class="ff9 ls34">&apos;</span><span class="fc0">)</span></span></span></div><div class="t m0 x5 hf yf7a ff7 fs5 fca sc0 ls0 ws156">print<span class="ff8 fc0 ws13a">(<span class="ff9 fc9 ls34">&apos;</span><span class="fc9">Total<span class="ff9 ws13b">&apos;</span></span><span class="ls33">,</span><span class="fca">sum</span><span class="ls34">(</span><span class="fca">bytes</span>))</span></div><div class="t m0 x5 he yf7b ff2 fs2 fc4 sc0 ls0 ws212">6.13.3 <span class="ff1">讨论</span></div><div class="t m0 x0 h9 yf7c ff1 fs3 fc0 sc0 ls0 wsa0">以管道方式处理数据<span class="_ _6"></span>可以用来解决各类其他问<span class="_ _6"></span>题，包括解析，读取实时数<span class="_ _6"></span>据，定时</div><div class="t m0 x5 h9 yf7d ff1 fs3 fc0 sc0 ls0">轮询等。</div><div class="t m0 x0 h9 yf7e ff1 fs3 fc0 sc0 ls10 ws5e1">为了理解上述代码<span class="_ _1"></span>，重点是要明白 <span class="ff6 ls0 ws27d">yield </span><span class="ws5e2">语句作为数据的生产者而 <span class="ff6 ls0 ws5e3">for <span class="ff1 wsa0">循<span class="_ _6"></span>环<span class="_ _6"></span>语句</span></span></span></div><div class="t m0 x5 h9 yf7f ff1 fs3 fc0 sc0 ls0 ws5e4">作为<span class="_ _6"></span>数据<span class="_ _6"></span>的<span class="_ _6"></span>消费<span class="_ _6"></span>者。当<span class="_ _6"></span>这<span class="_ _6"></span>些生<span class="_ _6"></span>成器<span class="_ _6"></span>被连<span class="_ _6"></span>在<span class="_ _6"></span>一起<span class="_ _6"></span>后，每<span class="_ _6"></span>个 <span class="ff6 ws224">yield </span><span class="wsa0">会将<span class="_ _6"></span>一<span class="_ _6"></span>个单<span class="_ _6"></span>独的<span class="_ _6"></span>数据<span class="_ _6"></span>元</span></div><div class="t m0 x5 h9 yf80 ff1 fs3 fc0 sc0 lsa8 ws5e5">素传递给迭代处理管道的下一阶段。在例子最后部分<span class="_ _1"></span>， <span class="ff6 ls0 ws5e6">sum() </span><span class="ws3de">函数是最终的程序驱动</span></div><div class="t m0 x5 h9 yf81 ff1 fs3 fc0 sc0 ls0">者，每次从生成器管道中提取出一个元素。</div><div class="t m0 x0 h9 y74 ff1 fs3 fc0 sc0 ls3a ws153">这种方式一个非常好的特点是每个生成器函数很小并且都是独立的。这样的话就很</div><div class="t m0 x5 h9 yf82 ff1 fs3 fc0 sc0 ls13 wse5">容易编写和维护它们了<span class="_ _1"></span>。很多时候，这些函数如果比较通用的话可以在其他场景重复<span class="_ _c"></span></div><div class="t m0 x5 h9 yf83 ff1 fs3 fc0 sc0 ls0">使用。并且最终将这些组件组合起来的代码看上去非常简单，也很容易理解。</div><div class="t m0 x0 h9 yf84 ff1 fs3 fc0 sc0 ls3a ws153">使用这种方式的内存效率也不得不提。上述代码即便是在一个超大型文件目录中也</div><div class="t m0 x5 h9 yf85 ff1 fs3 fc0 sc0 ls1e ws111">能工作的很好<span class="_ _1"></span>。事实上，由于使用了<span class="_ _1"></span>迭代方式处理，代码运行过程中只需要很小<span class="_ _1"></span>很小</div><div class="t m0 x5 h9 yf86 ff1 fs3 fc0 sc0 ls0">的内存。</div><div class="t m0 x0 h9 yf87 ff1 fs3 fc0 sc0 ls0 ws5e7">在<span class="_ _6"></span>调<span class="_ _6"></span>用 <span class="ff6 ws5e3">gen concatenate()<span class="_ _7"> </span></span><span class="ls36 ws14a">函数的时候你可<span class="_ _6"></span>能会有些不太明白<span class="_ _c"></span>。这个函数的目的</span></div><div class="t m0 x5 h9 y9b9 ff1 fs3 fc0 sc0 ls0 ws5e8">是将输入序列拼接成一个很长的行序列。 <span class="ff6 ws5e9">itertools.chain() </span>函数同样有类似的功能，</div><div class="t m0 x5 h9 yf88 ff1 fs3 fc0 sc0 ls13 wse5">但是它需要将所有可迭代对象最为参数传入<span class="_ _1"></span>。在上面这个例子中，你可能会写类似这<span class="_ _c"></span></div><div class="t m0 x5 h9 yf89 ff1 fs3 fc0 sc0 ls0 ws5ea">样的<span class="_ _6"></span>语<span class="_ _6"></span>句 <span class="ff6 ws5eb">lines = itertools.chain(*files)<span class="_ _7"> </span></span><span class="ls10 ws5ec">，使得 </span><span class="ff6 ws5ed">gen opener() </span><span class="wsa0">生成<span class="_ _6"></span>器<span class="_ _6"></span>能被<span class="_ _6"></span>全<span class="_ _6"></span>部</span></div><div class="t m0 x5 h9 yf8a ff1 fs3 fc0 sc0 ls3a ws1b9">消费掉。但由于 <span class="ff6 ls0 ws5ee">gen<span class="_ _7"> </span>opener() </span><span class="ws153">生成器每次生成一个打开过的文件，等到下一个迭代步</span></div><div class="t m0 x5 h9 yf8b ff1 fs3 fc0 sc0 lsa8 ws5ef">骤时文件就关闭了，因此 <span class="ff6 ls0 ws3dd">china() </span><span class="ws3de">在这里不能这样使用<span class="_ _1"></span>。上面的方案可以避免这种情</span></div><div class="t m0 x5 h9 yf8c ff1 fs3 fc0 sc0 ls0">况。</div><div class="t m0 x0 h9 yf48 ff6 fs3 fc0 sc0 ls0 ws5f0">gen<span class="_ _7"> </span>concatenate() <span class="ff1 ls68 ws5f1">函数中出现过 </span><span class="ws5f2">yield<span class="_ _11"> </span>from <span class="ff1 ls68 ws4e1">语句，它将 </span><span class="ws5f3">yield <span class="ff1 ls68 ws23f">操作代理到父生</span></span></span></div><div class="t m0 x5 h9 yf8d ff1 fs3 fc0 sc0 ls0 ws5f4">成器<span class="_ _6"></span>上<span class="_ _6"></span>去。<span class="_ _6"></span>语<span class="_ _6"></span>句 <span class="ff6 ws5f5">yield from it<span class="_ _7"> </span></span><span class="ls10 ws5f6">简单的返回生成器 </span><span class="ff6 ws5f7">it </span><span class="wsa0">所产<span class="_ _6"></span>生<span class="_ _6"></span>的所<span class="_ _6"></span>有<span class="_ _6"></span>值。<span class="_ _6"></span>关于<span class="_ _6"></span>这<span class="_ _6"></span>个<span class="_ _6"></span>我</span></div><div class="t m0 x5 h7 yf8e ff1 fs3 fc0 sc0 ls0 ws14">们在 <span class="ff4 ws1d0">4.14 </span>小节会有更进一步的描述。</div><div class="t m0 x0 h9 yf8f ff1 fs3 fc0 sc0 ls3a ws153">最后还有一点需要注意的是，管道方式并不是万能的。有时候你想立即处理所有数</div><div class="t m0 x5 h9 y6e ff1 fs3 fc0 sc0 ls0 wsa0">据。<span class="_ _6"></span>然而，<span class="_ _6"></span>即<span class="_ _6"></span>便<span class="_ _6"></span>是<span class="_ _6"></span>这<span class="_ _6"></span>种情<span class="_ _6"></span>况，<span class="_ _6"></span>使<span class="_ _6"></span>用<span class="_ _6"></span>生<span class="_ _6"></span>成<span class="_ _6"></span>器管<span class="_ _6"></span>道<span class="_ _6"></span>也<span class="_ _6"></span>可<span class="_ _6"></span>以<span class="_ _6"></span>将这<span class="_ _6"></span>类<span class="_ _6"></span>问<span class="_ _6"></span>题<span class="_ _6"></span>从<span class="_ _6"></span>逻辑<span class="_ _6"></span>上<span class="_ _6"></span>变<span class="_ _6"></span>为<span class="_ _6"></span>工<span class="_ _6"></span>作流</div><div class="t m0 x5 h9 y674 ff1 fs3 fc0 sc0 ls0">的处理方式。</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 ws21d">6.13.<span class="_ _5"> </span>4.13 <span class="ff1 ws533">创建数据处理管道 </span>131</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
