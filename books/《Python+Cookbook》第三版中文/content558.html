<div id="pf22e" class="pf w0 h0" data-page-no="22e"><div class="pc pc22e w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg22e.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 hf y334 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws145">divide <span class="fc6 ls32">=</span><span class="ws13a">_mod<span class="fc6 ls34">.</span>divide</span></span></div><div class="t m0 x5 hf y335 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws13a">divide<span class="fc6 ls34">.</span><span class="ws16d">argtypes <span class="fc6 ls32">=</span></span>(ctypes<span class="fc6 ls34">.</span><span class="ws13b">c_int, ctypes<span class="fc6 ls34">.</span><span class="ws4">c_int, ctypes<span class="fc6 ls34">.</span></span></span>POINTER(ctypes<span class="fc6 ls34">.</span>c_int))</span></div><div class="t m0 x5 hf y336 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls32">x<span class="fc6 ls33">=<span class="fc7 ls0">0</span></span></span></div><div class="t m0 x5 hf y337 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws13a">divide(<span class="fc7">10</span><span class="ls33">,<span class="fc7 ls34">3</span></span><span class="ws13b">, x)</span></span></div><div class="t m0 x5 hf yadd ff8 fs5 fce sc0 ls0 ws4">Traceback (most recent call last):</div><div class="t m0 x19 hf yade ff8 fs5 fc0 sc0 ls0 ws13c">File <span class="fca ws13a">&quot;&lt;stdin&gt;&quot;</span><span class="ws13b">, line <span class="fc7 ws13a">1</span><span class="ws4">, in &lt;module&gt;</span></span></div><div class="t m0 x5 hf yadf ff8 fs5 fc2 sc0 ls0 ws13a">ctypes.ArgumentError<span class="fc0 ws4">: argument 3: &lt;class <span class="ff9 ls34">&apos;</span><span class="ws13a">TypeError<span class="ff9 ls34">&apos;</span><span class="ws13b">&gt;: expected LP_c_int</span></span></span></div><div class="t m0 x5 hf yc64 ff8 fs5 fc8 sc0 ls0 ws4">instance instead of int</div><div class="t m0 x5 hf y1555 ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h7 y35f7 ff1 fs3 fc0 sc0 ls18 ws326">就算这个能正确的工作，它会违反 <span class="ff4 ls0 wsf8">Python </span><span class="ws110">对于整数的不可更改原则，并且可能会<span class="_ _1"></span></span></div><div class="t m0 x5 h9 y4f0 ff1 fs3 fc0 sc0 ls13 wse5">导致整个解释器陷入一个黑洞中<span class="_ _1"></span>。对于涉及到指针的参数，你通常需要先构建一个相<span class="_ _c"></span></div><div class="t m0 x5 h7 y35f8 ff1 fs3 fc0 sc0 ls0 ws14">应的 <span class="ff4 wsb0">ct<span class="_ _1"></span>yp<span class="_ _6"></span>es <span class="ff1">对象并像下面这样传进去：</span></span></div><div class="t m0 x5 hf y13ab ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls32">x<span class="fc6 ls33">=</span><span class="ls0 ws13a">ctypes<span class="fc6 ls34">.</span>c_int()</span></span></div><div class="t m0 x5 hf y4f3 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws13a">divide(<span class="fc7">10</span><span class="ls33">,<span class="fc7 ls34">3</span></span><span class="ws13b">, x)</span></span></div><div class="t m0 x5 hf y4f4 ff8 fs5 fc8 sc0 ls0">3</div><div class="t m0 x5 hf y35f9 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls34">x<span class="fc6 ls0 ws13a">.<span class="fc0">value</span></span></span></div><div class="t m0 x5 hf y35fa ff8 fs5 fc8 sc0 ls0">1</div><div class="t m0 x5 hf y35fb ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h7 y35fc ff1 fs3 fc0 sc0 ls0 ws1385">在这里，一个 <span class="ff6 ws1386">ctypes.c<span class="_ _16"> </span>int </span>实例被创建并作为一个指针被传进去。跟普通 <span class="ff4">Python</span></div><div class="t m0 x5 h9 y35fd ff1 fs3 fc0 sc0 ls0 ws11cc">整形不同的是，一个 <span class="ff6 ws1387">c<span class="_ _16"> </span>int </span><span class="wsfd">对象是可以被修改的。 <span class="ff6 ws1388">.value </span>属性可被用来获取或更改这</span></div><div class="t m0 x5 h9 y35fe ff1 fs3 fc0 sc0 ls0">个值。</div><div class="t m0 x0 h7 y35ff ff1 fs3 fc0 sc0 ls6c ws1389">对于那些不像 <span class="ff4 ls0 ws355">Python </span><span class="ls100">的<span class="ff4 ls251">C</span></span><span class="ws29d">调用<span class="_ _c"></span>，<span class="_ _6"></span>通常可以写一个小的包装函数<span class="_ _c"></span>。这里，我们让<span class="_ _c"></span></span></div><div class="t m0 x5 h9 y3600 ff6 fs3 fc0 sc0 ls0 ws1f3">divide() <span class="ff1">函数通过元组来返回两个结果：</span></div><div class="t m0 x5 h11 y3601 ffa fs5 fcd sc0 ls0 ws4"># int divide(int, int, int *)</div><div class="t m0 x5 hf y3602 ff8 fs5 fc0 sc0 ls0 ws155">_divide <span class="fc6 ls32">=</span><span class="ws13a">_mod<span class="fc6 ls34">.</span>divide</span></div><div class="t m0 x5 hf y1436 ff8 fs5 fc0 sc0 ls0 ws13a">_divide<span class="fc6 ls34">.</span><span class="ws1f5">argtypes <span class="fc6 ls33">=</span></span>(ctypes<span class="fc6 ls34">.</span><span class="ws13b">c_int, ctypes<span class="fc6 ls34">.</span>c_int, ctypes<span class="fc6 ls34">.</span></span>POINTER(ctypes<span class="fc6 ls34">.</span>c_int))</div><div class="t m0 x5 hf y3603 ff8 fs5 fc0 sc0 ls0 ws13a">_divide<span class="fc6 ls34">.</span><span class="ws155">restype <span class="fc6 ls32">=</span></span>ctypes<span class="fc6 ls34">.</span>c_int</div><div class="t m0 x5 hf y3604 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">divide<span class="fc0 ws4">(x, y):</span></span></div><div class="t m0 x15 hf y3605 ff8 fs5 fc0 sc0 ls0 ws158">rem <span class="fc6 ls32">=</span><span class="ws13a">ctypes<span class="fc6">.</span>c_int()</span></div><div class="t m0 x15 hf y3606 ff8 fs5 fc0 sc0 ls0 ws13c">quot <span class="fc6 ls32">=</span>_divide(x,y,rem)</div><div class="t m0 x15 hf y3607 ff7 fs5 fca sc0 ls0 ws146">return <span class="ff8 fc0 ws4">quot, rem<span class="fc6 ws13a">.</span>value</span></div><div class="t m0 x0 h7 y3608 ff6 fs3 fc0 sc0 ls0 ws138a">avg() <span class="ff1 wsa0">函<span class="_ _6"></span>数又<span class="_ _6"></span>是<span class="_ _6"></span>一<span class="_ _6"></span>个<span class="_ _6"></span>新的<span class="_ _6"></span>挑<span class="_ _6"></span>战。<span class="_ _6"></span><span class="ff4 ls252">C</span>代<span class="_ _6"></span>码期<span class="_ _6"></span>望<span class="_ _6"></span>接<span class="_ _6"></span>受到<span class="_ _6"></span>一<span class="_ _6"></span>个<span class="_ _6"></span>指<span class="_ _6"></span>针和<span class="_ _6"></span>一<span class="_ _6"></span>个<span class="_ _6"></span>数<span class="_ _6"></span>组的<span class="_ _6"></span>长<span class="_ _6"></span>度<span class="_ _6"></span>值。</span></div><div class="t m0 x5 h7 y3609 ff1 fs3 fc0 sc0 ls0 ws138b">但是，在 <span class="ff4 ws1117">Python </span><span class="ls35 ws144">中，我们必须考虑这个问题：数组是啥？它是一个列表？一个元组？</span></div><div class="t m0 x5 h9 y360a ff1 fs3 fc0 sc0 ls0 ws1226">还是 <span class="ff6 ws203">array </span><span class="ws138c">模块<span class="_ _6"></span>中的一<span class="_ _6"></span>个数<span class="_ _6"></span>组？还是<span class="_ _6"></span>一个 <span class="ff6 ws9b0">numpy </span><span class="wsa0">数组？<span class="_ _6"></span>还是说<span class="_ _6"></span>所有都<span class="_ _6"></span>是？实际<span class="_ _6"></span>上，一</span></span></div><div class="t m0 x5 h7 y360b ff1 fs3 fc0 sc0 ls4">个<span class="ff4 ls0 wsa5">Python<span class="ff1">“数组”有多种形式，你可能想要支持多种可能性。</span></span></div><div class="t m0 x0 h9 y806 ff6 fs3 fc0 sc0 ls0 wscbb">DoubleArrayType <span class="ff1 ls10c ws9c5">演示了怎样处理这种情况<span class="_ _8"></span>。在这个类中定义了一个单个方法<span class="_ _d"></span></span></div><div class="t m0 x5 h9 y360c ff6 fs3 fc0 sc0 ls0 ws474">from param() <span class="ff1 wsa0">。<span class="_ _6"></span>这个<span class="_ _6"></span>方法的<span class="_ _6"></span>角色<span class="_ _6"></span>是接<span class="_ _6"></span>受一<span class="_ _6"></span>个单<span class="_ _6"></span>个参<span class="_ _6"></span>数然<span class="_ _6"></span>后将其<span class="_ _6"></span>向下<span class="_ _6"></span>转换<span class="_ _6"></span>为一<span class="_ _6"></span>个合<span class="_ _6"></span>适的</span></div><div class="t m0 x5 h7 y360d ff4 fs3 fc0 sc0 ls0 ws138d">ct<span class="_ _1"></span>yp<span class="_ _6"></span>es <span class="ff1 ws138e">对象（本例中是一<span class="_ _6"></span>个 <span class="ff6 ws205">ctypes.c<span class="_ _16"> </span>double </span><span class="ws138f">的<span class="_ _6"></span>指针）<span class="_ _f"></span>。在 <span class="ff6 ws207">from<span class="_ _7"> </span>param() </span><span class="wsa0">中，你可以</span></span></span></div><div class="t m0 x5 h9 y20ba ff1 fs3 fc0 sc0 ls0 wsa0">做任何<span class="_ _6"></span>你想做<span class="_ _6"></span>的事。参<span class="_ _6"></span>数的类<span class="_ _6"></span>型名被提<span class="_ _6"></span>取出来<span class="_ _6"></span>并被用<span class="_ _6"></span>于分发<span class="_ _6"></span>到一个<span class="_ _6"></span>更具体的<span class="_ _6"></span>方法中<span class="_ _6"></span>去。</div><div class="t m0 x5 h9 y360e ff1 fs3 fc0 sc0 ls0 ws1390">例如，如果一<span class="_ _6"></span>个列表被传递<span class="_ _6"></span>过来，那么 <span class="ff6 ws259">typename </span><span class="ws4e2">就是 <span class="ff6 ws1391">list </span><span class="ws1392">，然<span class="_ _6"></span>后 <span class="ff6 ws1391">from<span class="_ _16"> </span>list </span><span class="wsa0">方<span class="_ _6"></span>法被</span></span></span></div><div class="t m0 x5 h9 y360f ff1 fs3 fc0 sc0 ls0">调用。</div><div class="t m0 x0 h9 y3610 ff1 fs3 fc0 sc0 ls30 ws138">对于列表和元组，<span class="ff6 ls0 ws24a">from list </span><span class="ws1393">方法将其转换为一个 <span class="ff6 ls0 ws8aa">ctypes </span></span>的数组对象<span class="_ _c"></span>。这个看上</div><div class="t m0 x5 h9 y3611 ff1 fs3 fc0 sc0 ls0 ws14">去有点奇怪，下面我们使用一个交互式例子来将一个列表转换为一个 <span class="ff6 ws25d">ctypes </span>数组：</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 ws21d">17.1.<span class="_ _36"> </span>15.1 <span class="ff1 ws16b">使用 </span><span class="ws135b">ctypes <span class="ff1 ws16b">访问 </span><span class="ls246">C</span><span class="ff1 ws135c">代码 </span>549</span></div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
