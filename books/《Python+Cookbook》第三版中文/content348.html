<div id="pf15c" class="pf w0 h0" data-page-no="15c"><div class="pc pc15c w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg15c.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x15 hf y1ab ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">spam<span class="fc0">(<span class="fca">self</span><span class="ws4">, x, <span class="fc6 ls34">*</span><span class="ws13b">, z):</span></span></span></span></div><div class="t m0 x16 h10 y1ac ff7 fs5 fca sc0 ls0">pass</div><div class="t m0 x5 h11 y1ae ffa fs5 fcd sc0 ls0 ws4"># Class with redefined methods, but slightly different signatures</div><div class="t m0 x5 hf y1af ff7 fs5 fca sc0 ls0 ws16a">class <span class="fcc ls34">B</span><span class="ff8 fc0">(A):</span></div><div class="t m0 x15 hf y1b0 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">foo<span class="fc0 ls34">(</span><span class="fca">self<span class="fc0 ws13b">, a, b):</span></span></span></div><div class="t m0 x16 h10 y355 ff7 fs5 fca sc0 ls0">pass</div><div class="t m0 x15 hf y411 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">spam<span class="fc0">(<span class="fca">self</span>,x,z):</span></span></div><div class="t m0 x16 h10 yba ff7 fs5 fca sc0 ls0">pass</div><div class="t m0 x0 h9 y2473 ff1 fs3 fc0 sc0 ls0">如果你运行这段代码，就会得到下面这样的输出结果：</div><div class="t m0 x5 hf y196c ff8 fs5 fc0 sc0 ls0 wsc51">WARNING:root:Signature mismatch <span class="ff7 fca ws157">in </span><span class="ls34">B<span class="fc6">.</span></span><span class="ws13a">spam<span class="fc6 ls32">.</span><span class="ls34">(</span><span class="fca">self</span><span class="ws13b">, x, </span><span class="fc6">*</span><span class="ws4">, z) <span class="fc6 ws159">!= </span><span class="ls34">(</span></span><span class="fca">self</span><span class="ws13b">, x, z)</span></span></div><div class="t m0 x5 hf y2474 ff8 fs5 fc0 sc0 ls0 wsc51">WARNING:root:Signature mismatch <span class="ff7 fca ws157">in </span><span class="ls34">B<span class="fc6">.</span></span><span class="ws13a">foo<span class="fc6 ls33">.</span>(<span class="fca">self</span><span class="ws4">, x, y) <span class="fc6 ws159">!= </span><span class="ls34">(</span></span><span class="fca">self</span><span class="ws13b">, a, b)</span></span></div><div class="t m0 x0 h7 y846 ff1 fs3 fc0 sc0 ls14 wsc52">这种警告信息对于捕获一些微妙的程序 <span class="ff4 ls0 wsc53">bug <span class="ff1 wsa0">是<span class="_ _6"></span>很<span class="_ _6"></span>有<span class="_ _6"></span>用<span class="_ _6"></span>的。<span class="_ _6"></span>例<span class="_ _6"></span>如，<span class="_ _6"></span>如<span class="_ _6"></span>果<span class="_ _6"></span>某<span class="_ _6"></span>个<span class="_ _6"></span>代<span class="_ _6"></span>码<span class="_ _6"></span>依</span></span></div><div class="t m0 x5 h9 y2475 ff1 fs3 fc0 sc0 ls0">赖于传递给方法的关键字参数，那么当子类改变参数名字的时候就会调用出错。</div><div class="t m0 x5 he y2476 ff2 fs2 fc4 sc0 ls0 wsadf">11.17.3 <span class="ff1">讨论</span></div><div class="t m0 x0 h9 y3e1 ff1 fs3 fc0 sc0 ls3a ws153">在大型面向对象的程序中，通常将类的定义放在元类中控制是很有用的。元类可以</div><div class="t m0 x5 h9 y2477 ff1 fs3 fc0 sc0 ls0">监控类的定义，警告编程人员某些没有注意到的可能出现的问题。</div><div class="t m0 x0 h7 y227 ff1 fs3 fc0 sc0 ls51 wsc54">有人可能会说，像这样的错误可以通过程序分析工具或 <span class="ff4 ls0 wsc55">IDE <span class="ff1 wsa0">去做会更好些。诚<span class="_ _6"></span>然，</span></span></div><div class="t m0 x5 h9 y2478 ff1 fs3 fc0 sc0 ls1e ws111">这些工具是很有用<span class="_ _1"></span>。但是，如果你在<span class="_ _1"></span>构建一个框架或函数库供其他人使用，那么<span class="_ _1"></span>你没</div><div class="t m0 x5 h9 y2479 ff1 fs3 fc0 sc0 ls1e ws111">办法去控制使用者要使用什么工具<span class="_ _1"></span>。因此<span class="_ _1"></span>，对于这种类型的程序，如果可以在元<span class="_ _1"></span>类中</div><div class="t m0 x5 h9 y247a ff1 fs3 fc0 sc0 ls0">做检测或许可以带来更好的用户体验。</div><div class="t m0 x0 h9 y172c ff1 fs3 fc0 sc0 ls2c wsc56">在元类中选择重新定义 <span class="ff6 ls0 wsc57">new<span class="_ _e"> </span>() <span class="ff1 wsc58">方法还是 </span><span class="wsc34">init<span class="_ _e"> </span>() </span></span><span class="ws12f">方法取决于你想怎样使用结</span></div><div class="t m0 x5 h9 y247b ff1 fs3 fc0 sc0 ls0 wsc59">果<span class="_ _6"></span>类。 <span class="ff6 wsc5a">new<span class="_ _e"> </span>() </span><span class="ls56 ws1fa">方法在类创建之前被调用<span class="_ _1"></span>，通常用于通过某种方式（<span class="_ _1"></span>比如通过改变<span class="_ _1"></span></span></div><div class="t m0 x5 h9 y2392 ff1 fs3 fc0 sc0 ls0 wsc5b">类字<span class="_ _6"></span>典<span class="_ _6"></span>的内<span class="_ _6"></span>容）<span class="_ _6"></span>修<span class="_ _6"></span>改类<span class="_ _6"></span>的<span class="_ _6"></span>定义。<span class="_ _6"></span>而 <span class="ff6 ws8e8">init<span class="_ _e"> </span>() </span><span class="wsa0">方<span class="_ _6"></span>法是<span class="_ _6"></span>在<span class="_ _6"></span>类被<span class="_ _6"></span>创<span class="_ _6"></span>建之<span class="_ _6"></span>后<span class="_ _6"></span>被<span class="_ _6"></span>调用，<span class="_ _6"></span>当<span class="_ _6"></span>你需</span></div><div class="t m0 x5 h9 y247c ff1 fs3 fc0 sc0 ls1e ws111">要完整构建类对象的时候会很有用<span class="_ _1"></span>。在最后一个例子中<span class="_ _1"></span>，这是必要的，因为它使<span class="_ _1"></span>用了</div><div class="t m0 x5 h9 y247d ff6 fs3 fc0 sc0 ls0 ws575">super() <span class="ff1 ls14 ws174">函数来搜索之前的定义<span class="_ _1"></span>。它只能在类的实例被创建之后<span class="_ _1"></span>，并且相应的方法解<span class="_ _1"></span></span></div><div class="t m0 x5 h9 y247e ff1 fs3 fc0 sc0 ls0">析顺序也已经被设置好了。</div><div class="t m0 x0 h7 y247f ff1 fs3 fc0 sc0 ls19e wsc5c">最后一个例子还演示了 <span class="ff4 ls0 wsc5d">Python </span><span class="wsc5e">的函数签名对象的使用<span class="_ _1d"></span>。实际上<span class="_ _1d"></span>，元类会<span class="_ _1d"></span></span></div><div class="t m0 x5 h9 y2167 ff1 fs3 fc0 sc0 ls19f wsc5f">管理中每个一个调用定义<span class="_ _1f"></span>，搜索前一个定义（<span class="_ _1d"></span>如果有的话<span class="_ _1f"></span>）<span class="_ _31"></span>，<span class="_ _6"></span>然后通过使用<span class="_ _1f"></span></div><div class="t m0 x5 h9 y2480 ff6 fs3 fc0 sc0 ls0 ws284">inspect.signature() <span class="ff1">来简单的比较它们的调用签名。</span></div><div class="t m0 x0 h9 y2481 ff1 fs3 fc0 sc0 ls1e wsc60">最后一点<span class="_ _1"></span>，代码中有一行使用了 <span class="ff6 ls0 wsc61">super(self,<span class="_ _17"> </span>self) <span class="ff1 wsa0">并不<span class="_ _6"></span>是<span class="_ _6"></span>排<span class="_ _6"></span>版<span class="_ _6"></span>错<span class="_ _6"></span>误。<span class="_ _6"></span>当<span class="_ _6"></span>使用<span class="_ _6"></span>元</span></span></div><div class="t m0 x5 h9 y2482 ff1 fs3 fc0 sc0 ls1f wsc62">类的时候，我们要时刻记住一点就是 <span class="ff6 ls0 ws9f6">self </span><span class="ws113">实际上是一个类对象。因此，这条语句其实</span></div><div class="t m0 x5 h9 y2483 ff1 fs3 fc0 sc0 ls0 ws38">就是用来寻找位于继承体系中构建 <span class="ff6 ws27b">self </span>父类的定义。</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 wsae0">11.17.<span class="_ _5"> </span>9.17 <span class="ff1 wsb03">在类上强制使用编程规约 </span>339</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
