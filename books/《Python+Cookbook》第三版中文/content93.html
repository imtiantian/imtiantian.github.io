<div id="pf5d" class="pf w0 h0" data-page-no="5d"><div class="pc pc5d w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg5d.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 he y137 ff2 fs2 fc4 sc0 ls0 ws135">5.2.3 <span class="ff1">讨论</span></div><div class="t m0 x0 h7 y236 ff6 fs3 fc0 sc0 ls0 ws47b">decimal <span class="ff1 ws47c">模块实<span class="_ _6"></span>现了 <span class="ff4 ws47d">IBM </span><span class="wsa0">的<span class="ff4 lscd">”</span><span class="ls3d ws164">通用小数运算规范</span><span class="ff4 wsa5">”</span><span class="ls3d ws164">。不用说，有很多的配置选项这</span></span></span></div><div class="t m0 x5 h9 y237 ff1 fs3 fc0 sc0 ls0">本书没有提到。</div><div class="t m0 x0 h7 ya58 ff4 fs3 fc0 sc0 ls0 ws47e">Python <span class="ff1 ls19 ws47f">新手会倾向于使用 </span><span class="ff6 ws229">decimal <span class="ff1 ls19 ws22a">模块来处理浮点数的精确运算。然而，先理解<span class="_ _c"></span></span></span></div><div class="t m0 x5 h9 y278 ff1 fs3 fc0 sc0 ls13 wse5">你的应用程序目的是非常重要的<span class="_ _1"></span>。如果你是在做科学计算或工程领域的计算、电脑绘<span class="_ _c"></span></div><div class="t m0 x5 h9 y279 ff1 fs3 fc0 sc0 ls1e ws111">图<span class="_ _1"></span>，或者是科学领域的大多数运算<span class="_ _1"></span>，那么使用普通的浮点类型是比较普遍的做法<span class="_ _1"></span>。其</div><div class="t m0 x5 h7 y27a ff1 fs3 fc0 sc0 lsf ws480">中一个原因是<span class="_ _c"></span>，<span class="_ _6"></span>在真实世界中很少会要求精确到普通浮点数能提供的 <span class="ff4 ls0 ws481">17 <span class="ff1 wsa0">位<span class="_ _6"></span>精<span class="_ _6"></span>度。<span class="_ _6"></span>因</span></span></div><div class="t m0 x5 h9 y27b ff1 fs3 fc0 sc0 ls1e ws111">此<span class="_ _1"></span>，计算过程中的那么一点点的误差是被允许的<span class="_ _1"></span>。第二点就是，原生的浮点数计<span class="_ _1"></span>算要</div><div class="t m0 x5 h7 ya59 ff1 fs3 fc0 sc0 ls0 ws38">快的多 <span class="ff4 lsce">-</span>有时候你在执行大量运算的时候速度也是非常重要的。</div><div class="t m0 x0 h9 ya5a ff1 fs3 fc0 sc0 ls0 wsa0">即便如此，你却不能完<span class="_ _6"></span>全忽略误差。数学家花了大<span class="_ _6"></span>量时间去研究各类算法，<span class="_ _6"></span>有些处</div><div class="t m0 x5 h9 ya5b ff1 fs3 fc0 sc0 ls2d ws132">理误差会比其他方法更好。你也得注意下减法删除以及大数和小数的加分运算所带来<span class="_ _1"></span></div><div class="t m0 x5 h9 ya5c ff1 fs3 fc0 sc0 ls0">的影响。比如：</div><div class="t m0 x5 hf ya5d ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws13c">nums <span class="fc6 ls32">=</span><span class="ls34">[</span><span class="fc7 ws13a">1.23e+18</span><span class="ls32">,<span class="fc7 ls34">1</span>,<span class="fc6 ls34">-</span></span><span class="fc7 ws13a">1.23e+18</span>]</span></div><div class="t m0 x5 hf ya5e ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fca ws13a">sum<span class="fc0 ws145">(nums) <span class="ffa fcd ws4"># Notice how 1 disappears</span></span></span></div><div class="t m0 x5 hf yb ff8 fs5 fc8 sc0 ls0">0.0</div><div class="t m0 x5 hf ya5f ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h9 ya60 ff1 fs3 fc0 sc0 ls0 ws38">上面的错误可以利用 <span class="ff6 ws1e2">math.fsum() </span>所提供的更精确计算能力来解决：</div><div class="t m0 x5 h10 y522 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="fca ws146">import <span class="fcc">math</span></span></div><div class="t m0 x5 hf ya61 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws13a">math<span class="fc6 ls34">.</span>fsum(nums)</span></div><div class="t m0 x5 hf ya62 ff8 fs5 fc8 sc0 ls0">1.0</div><div class="t m0 x5 hf ya63 ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h9 ya64 ff1 fs3 fc0 sc0 ls0">然而，对于其他的算法，你应该仔细研究它并理解它的误差产生来源。</div><div class="t m0 x0 h9 ya65 ff1 fs3 fc0 sc0 ls0 ws482">总的来说， <span class="ff6 ws483">decimal </span><span class="wsa0">模块主要用在涉及到金融的领域。<span class="_ _c"></span>在这类程序中，哪怕是一点</span></div><div class="t m0 x5 h9 ya66 ff1 fs3 fc0 sc0 ls0 ws484">小小<span class="_ _6"></span>的误<span class="_ _6"></span>差在<span class="_ _6"></span>计<span class="_ _6"></span>算过<span class="_ _6"></span>程中<span class="_ _6"></span>蔓延<span class="_ _6"></span>都是<span class="_ _6"></span>不允<span class="_ _6"></span>许的。<span class="_ _6"></span>因<span class="_ _6"></span>此， <span class="ff6 ws411">decimal </span><span class="wsa0">模块<span class="_ _6"></span>为解<span class="_ _6"></span>决这<span class="_ _6"></span>类问<span class="_ _6"></span>题提</span></div><div class="t m0 x5 h7 ya67 ff1 fs3 fc0 sc0 ls0 ws485">供<span class="_ _6"></span>了方<span class="_ _6"></span>法。<span class="_ _6"></span>当 <span class="ff4 ws486">Python </span><span class="ls1e ws487">和数据库打交道的时候也通常会遇到 </span><span class="ff6 ws298">Decimal </span><span class="wsa0">对<span class="_ _6"></span>象，<span class="_ _6"></span>并<span class="_ _6"></span>且，<span class="_ _6"></span>通</span></div><div class="t m0 x5 h9 ya68 ff1 fs3 fc0 sc0 ls0">常也是在处理金融数据的时候。</div><div class="t m0 x5 hd ya69 ff2 fs4 fc4 sc0 ls0 ws134">5.3<span class="_ _e"> </span>3.3 <span class="ff1">数字的格式化输出</span></div><div class="t m0 x5 he ya6a ff2 fs2 fc4 sc0 ls0 ws135">5.3.1 <span class="ff1">问题</span></div><div class="t m0 x0 h9 ya6b ff1 fs3 fc0 sc0 ls24 ws11d">你需要将数字格式化后输出<span class="_ _c"></span>，并控制数字的位数<span class="_ _1"></span>、对齐<span class="_ _1"></span>、千位分隔符和其他的细<span class="_ _c"></span></div><div class="t m0 x5 h9 ya6c ff1 fs3 fc0 sc0 ls0">节。</div><div class="t m0 x5 he ya6d ff2 fs2 fc4 sc0 ls0 ws135">5.3.2 <span class="ff1">解决方案</span></div><div class="t m0 x0 h9 ya6e ff1 fs3 fc0 sc0 ls0 ws14">格式化输出单个数字的时候，可以使用内置的 <span class="ff6 ws1f3">format() </span>函数，比如：</div><div class="t m0 x5 hf ya6f ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls32">x<span class="fc6 ls33">=<span class="fc7 ls0">1234.56789</span></span></span></div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 ws13e">5.3.<span class="_ _5"> </span>3.3 <span class="ff1 ws2fa">数字的格式化输出 </span>84</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
