<div id="pf1e4" class="pf w0 h0" data-page-no="1e4"><div class="pc pc1e4 w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg1e4.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 h11 y181 ffa fs5 fcd sc0 ls0 ws4"># Dictionary of all created exchanges</div><div class="t m0 x5 hf y182 ff8 fs5 fc0 sc0 ls0 ws2a3">_exchanges <span class="fc6 ls32">=</span>defaultdict(Exchange)</div><div class="t m0 x5 h11 y184 ffa fs5 fcd sc0 ls0 ws4"># Return the Exchange instance associated with a given name</div><div class="t m0 x5 hf y185 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">get_exchange<span class="fc0">(name):</span></span></div><div class="t m0 x15 hf y186 ff7 fs5 fca sc0 ls0 ws146">return <span class="ff8 fc0">_exchanges[name]</span></div><div class="t m0 x0 h9 y1504 ff1 fs3 fc0 sc0 ls0 wsa0">一个交换机就是一个<span class="_ _6"></span>普通对象，负责维护一个活<span class="_ _6"></span>跃的订阅者集合，并为绑<span class="_ _6"></span>定、解绑</div><div class="t m0 x5 h9 y302e ff1 fs3 fc0 sc0 ls42 ws186">和发送消息提供相应的方法。每个交换机通过一个名称定位<span class="_ _c"></span>，<span class="ff6 ls0 ws6e1">get<span class="_ _7"> </span>exchange() <span class="ff1 wsa0">通<span class="_ _6"></span>过给</span></span></div><div class="t m0 x5 h9 y302f ff1 fs3 fc0 sc0 ls0 ws14">定一个名称返回相应的 <span class="ff6 ws1f3">Exchange </span>实例。</div><div class="t m0 x0 h9 y3030 ff1 fs3 fc0 sc0 ls0">下面是一个简单例子，演示了如何使用一个交换机：</div><div class="t m0 x5 h11 y3031 ffa fs5 fcd sc0 ls0 ws4"># Example of a task.<span class="_ _29"> </span>Any object with a send() method</div><div class="t m0 x5 hf y3032 ff7 fs5 fca sc0 ls0 ws16a">class <span class="fcc ws156">Task<span class="ff8 fc0">:</span></span></div><div class="t m0 x15 hf y3033 ff8 fs5 fc6 sc0 ls0 ws13a">...</div><div class="t m0 x15 hf y3034 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">send<span class="fc0">(<span class="fca">self</span><span class="ws4">, msg):</span></span></span></div><div class="t m0 x16 hf y3035 ff8 fs5 fc6 sc0 ls0 ws13a">...</div><div class="t m0 x5 hf y3036 ff8 fs5 fc0 sc0 ls0 ws145">task_a <span class="fc6 ls33">=</span>Task()</div><div class="t m0 x5 hf y3037 ff8 fs5 fc0 sc0 ls0 ws145">task_b <span class="fc6 ls33">=</span>Task()</div><div class="t m0 x5 h11 y3038 ffa fs5 fcd sc0 ls0 ws4"># Example of getting an exchange</div><div class="t m0 x5 hf y3039 ff8 fs5 fc0 sc0 ls0 ws158">exc <span class="fc6 ls32">=</span><span class="ws13a">get_exchange(<span class="ff9 fc9 ls34">&apos;</span><span class="fc9">name<span class="ff9 ls34">&apos;</span></span>)</span></div><div class="t m0 x5 h11 y303a ffa fs5 fcd sc0 ls0 ws4"># Examples of subscribing tasks to it</div><div class="t m0 x5 hf y303b ff8 fs5 fc0 sc0 ls0 ws13a">exc<span class="fc6 ls34">.</span>attach(task_a)</div><div class="t m0 x5 hf y303c ff8 fs5 fc0 sc0 ls0 ws13a">exc<span class="fc6 ls34">.</span>attach(task_b)</div><div class="t m0 x5 h11 y303d ffa fs5 fcd sc0 ls0 ws4"># Example of sending messages</div><div class="t m0 x5 hf y26cd ff8 fs5 fc0 sc0 ls0 ws13a">exc<span class="fc6 ls34">.</span>send(<span class="ff9 fc9 ws13b">&apos;</span><span class="fc9">msg1<span class="ff9 ls34">&apos;</span></span>)</div><div class="t m0 x5 hf y303e ff8 fs5 fc0 sc0 ls0 ws13a">exc<span class="fc6 ls34">.</span>send(<span class="ff9 fc9 ws13b">&apos;</span><span class="fc9">msg2<span class="ff9 ls34">&apos;</span></span>)</div><div class="t m0 x5 h11 y2a0c ffa fs5 fcd sc0 ls0 ws4"># Example of unsubscribing</div><div class="t m0 x5 hf y303f ff8 fs5 fc0 sc0 ls0 ws13a">exc<span class="fc6 ls34">.</span>detach(task_a)</div><div class="t m0 x5 hf y3040 ff8 fs5 fc0 sc0 ls0 ws13a">exc<span class="fc6 ls34">.</span>detach(task_b)</div><div class="t m0 x0 h9 y3041 ff1 fs3 fc0 sc0 ls56 ws1fa">尽管对于这个问题有很多的变种<span class="_ _c"></span>，不过万变不离其宗<span class="_ _1"></span>。消息会被发送给一个交换<span class="_ _1"></span></div><div class="t m0 x5 h9 y2fbc ff1 fs3 fc0 sc0 ls0">机，然后交换机会将它们发送给被绑定的订阅者。</div><div class="t m0 x5 he y3042 ff2 fs2 fc4 sc0 ls0 wsadf">14.11.3 <span class="ff1">讨论</span></div><div class="t m0 x0 h9 y3043 ff1 fs3 fc0 sc0 ls3a ws153">通过队列发送消息的任务或线程的模式很容易被实现并且也非常普遍。不过，使用</div><div class="t m0 x5 h7 y3044 ff1 fs3 fc0 sc0 ls0 wsa0">发布<span class="ff4 ls6">/</span>订阅模式的好处更加明显。</div><div class="t m0 x0 h9 y3045 ff1 fs3 fc0 sc0 ls3a ws153">首先，使用一个交换机可以简化大部分涉及到线程通信的工作。无需去写通过多进</div><div class="t m0 x5 h9 y3046 ff1 fs3 fc0 sc0 ls1e ws111">程模块来操作多个线程<span class="_ _1"></span>，你只需要使用这个交换机来连接它们<span class="_ _1"></span>。某种程度上<span class="_ _1"></span>，这个就</div><div class="t m0 x5 h9 yc86 ff1 fs3 fc0 sc0 ls0">跟日志模块的工作原理类似。实际上，它可以轻松的解耦程序中多个任务。</div><div class="t m0 x0 h9 y3047 ff1 fs3 fc0 sc0 ls0 wsa0">其次，交换机广播消息<span class="_ _6"></span>给多个订阅者的能力带来<span class="_ _6"></span>了一个全新的通信模式。<span class="_ _6"></span>例如，你</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 wsd97">14.11.<span class="_ _36"> </span>12.11 <span class="ff1 wsa0">实现消息发布</span><span class="ls20f">/</span><span class="ff1 ws1180">订阅模型 </span>475</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
