<div id="pfbf" class="pf w0 h0" data-page-no="bf"><div class="pc pcbf w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bgbf.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 h7 y2a ff1 fs3 fc0 sc0 ls18 ws818">或多种类型的事件列表： <span class="ff6 ls0 ws819">start <span class="ff4 ls135">,</span><span class="ws303">end<span class="ff4 ls136">,</span><span class="ws81a">start-ns </span></span></span><span class="ls5d">和<span class="ff6 ls0 ws81b">end-ns <span class="ff1 ws55b">。由 </span><span class="ws81c">iterparse() <span class="ff1 wsa0">创建<span class="_ _6"></span>的</span></span></span></span></div><div class="t m0 x5 h9 y2b ff1 fs3 fc0 sc0 ls0 ws81d">迭<span class="_ _6"></span>代器<span class="_ _6"></span>会<span class="_ _6"></span>产<span class="_ _6"></span>生<span class="_ _6"></span>形如 <span class="ff6 ws81e">(event,<span class="_ _17"> </span>elem) </span><span class="ws81f">的元<span class="_ _6"></span>组，<span class="_ _6"></span>其<span class="_ _6"></span>中 <span class="ff6 ws820">event </span><span class="wsa0">是<span class="_ _6"></span>上述<span class="_ _6"></span>事<span class="_ _6"></span>件<span class="_ _6"></span>列<span class="_ _6"></span>表中<span class="_ _6"></span>的<span class="_ _6"></span>某<span class="_ _6"></span>一<span class="_ _6"></span>个，</span></span></div><div class="t m0 x5 h7 y2c ff1 fs3 fc0 sc0 ls4">而<span class="ff6 ls0 ws27b">elem </span><span class="ls0 ws14">是相应的 <span class="ff4 ws64">XML </span>元素。例如：</span></div><div class="t m0 x5 hf yec3 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws13c">data <span class="fc6 ls32">=</span><span class="ws13a">iterparse(<span class="ff9 fc9 ls34">&apos;</span><span class="fc9">potholes.xml<span class="ff9 ws13b">&apos;</span></span>,(<span class="ff9 fc9 ls34">&apos;</span><span class="fc9">start<span class="ff9 ls34">&apos;</span></span><span class="ls34">,</span><span class="ff9 fc9 ws13b">&apos;</span><span class="fc9">end<span class="ff9 ws13b">&apos;</span></span>))</span></span></div><div class="t m0 x5 hf y14d1 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fca ws13a">next<span class="fc0">(data)</span></span></div><div class="t m0 x5 hf yec4 ff8 fs5 fc8 sc0 ls34">(<span class="ff9 ls0 ws13b">&apos;</span><span class="ls0 ws13a">start</span><span class="ff9">&apos;</span><span class="ls0 ws13b">, &lt;Element </span><span class="ff9">&apos;</span><span class="ls0 ws13a">response<span class="ff9 ls33">&apos;</span><span class="ws13b">at 0x100771d60&gt;)</span></span></div><div class="t m0 x5 hf yec5 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fca ws13a">next<span class="fc0">(data)</span></span></div><div class="t m0 x5 hf y14d2 ff8 fs5 fc8 sc0 ls34">(<span class="ff9 ls0 ws13b">&apos;</span><span class="ls0 ws13a">start</span><span class="ff9">&apos;</span><span class="ls0 ws13b">, &lt;Element </span><span class="ff9">&apos;</span><span class="ls0 ws13a">row<span class="ff9 ls32">&apos;</span><span class="ws4">at 0x100771e68&gt;)</span></span></div><div class="t m0 x5 hf yec6 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fca ws13a">next<span class="fc0">(data)</span></span></div><div class="t m0 x5 hf yec7 ff8 fs5 fc8 sc0 ls34">(<span class="ff9 ls0 ws13b">&apos;</span><span class="ls0 ws13a">start</span><span class="ff9">&apos;</span><span class="ls0 ws13b">, &lt;Element </span><span class="ff9">&apos;</span><span class="ls0 ws13a">row<span class="ff9 ls32">&apos;</span><span class="ws4">at 0x100771fc8&gt;)</span></span></div><div class="t m0 x5 hf yec8 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fca ws13a">next<span class="fc0">(data)</span></span></div><div class="t m0 x5 hf yec9 ff8 fs5 fc8 sc0 ls34">(<span class="ff9 ls0 ws13b">&apos;</span><span class="ls0 ws13a">start</span><span class="ff9">&apos;</span><span class="ls0 ws13b">, &lt;Element </span><span class="ff9">&apos;</span><span class="ls0 ws13a">creation_date<span class="ff9 ls32">&apos;</span><span class="ws4">at 0x100771f18&gt;)</span></span></div><div class="t m0 x5 hf yeca ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fca ws13a">next<span class="fc0">(data)</span></span></div><div class="t m0 x5 hf y35a ff8 fs5 fc8 sc0 ls34">(<span class="ff9 ls0 ws13b">&apos;</span><span class="ls0 ws13a">end<span class="ff9 ws13b">&apos;</span><span class="ws4">, &lt;Element </span></span><span class="ff9">&apos;</span><span class="ls0 ws13a">creation_date<span class="ff9 ls32">&apos;</span><span class="ws4">at 0x100771f18&gt;)</span></span></div><div class="t m0 x5 hf y59b ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fca ws13a">next<span class="fc0">(data)</span></span></div><div class="t m0 x5 hf y14d3 ff8 fs5 fc8 sc0 ls34">(<span class="ff9 ls0 ws13b">&apos;</span><span class="ls0 ws13a">start</span><span class="ff9">&apos;</span><span class="ls0 ws13b">, &lt;Element </span><span class="ff9">&apos;</span><span class="ls0 ws13a">status<span class="ff9 ls32">&apos;</span><span class="ws4">at 0x1006a7f18&gt;)</span></span></div><div class="t m0 x5 hf y14d4 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fca ws13a">next<span class="fc0">(data)</span></span></div><div class="t m0 x5 hf y14d5 ff8 fs5 fc8 sc0 ls34">(<span class="ff9 ls0 ws13b">&apos;</span><span class="ls0 ws13a">end<span class="ff9 ws13b">&apos;</span><span class="ws4">, &lt;Element </span></span><span class="ff9">&apos;</span><span class="ls0 ws13a">status<span class="ff9 ls33">&apos;</span><span class="ws13b">at 0x1006a7f18&gt;)</span></span></div><div class="t m0 x5 hf yc ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h7 y14d6 ff6 fs3 fc0 sc0 ls0 ws2b7">start <span class="ff1 ls1e ws821">事件在某个元素第一次被创建并且还没有被插入其他数据 <span class="ff4 ls1b">(</span><span class="ls0 wsa0">如<span class="_ _6"></span>子<span class="_ _6"></span>元素<span class="ff4 ls137">)</span>时<span class="_ _6"></span>被</span></span></div><div class="t m0 x5 h9 y14d7 ff1 fs3 fc0 sc0 ls0 ws822">创建。而 <span class="ff6 ws823">end </span><span class="ls35 ws824">事件在某个元素已经完成时被创建。尽管没有在例子中演示， </span><span class="ff6 ws303">start-ns</span></div><div class="t m0 x5 h7 y14d8 ff1 fs3 fc0 sc0 ls4">和<span class="ff6 ls0 ws25d">end-ns </span><span class="ls0 ws38">事件被用来处理 <span class="ff4 ws61">XML </span>文档命名空间的声明。</span></div><div class="t m0 x0 h9 ybf9 ff1 fs3 fc0 sc0 ls10 ws825">这本节例子中<span class="_ _1"></span>， <span class="ff6 ls0 ws27d">start </span><span class="ls96">和<span class="ff6 ls0 ws196">end </span></span><span class="wsdf">事件被用来管理元素和标签栈。栈代表了文档被解<span class="_ _c"></span></span></div><div class="t m0 x5 h9 y14d9 ff1 fs3 fc0 sc0 ls68 ws826">析时的层次结构，还被用来判断某个元素是否匹配传给函数 <span class="ff6 ls0 ws259">parse and<span class="_ _7"> </span>remove() <span class="ff1 wsa0">的路</span></span></div><div class="t m0 x5 h9 y14da ff1 fs3 fc0 sc0 ls0 ws14">径。如果匹配，就利用 <span class="ff6 ws17d">yield </span>语句向调用者返回这个元素。</div><div class="t m0 x0 h7 y14db ff1 fs3 fc0 sc0 ls5a">在<span class="ff6 ls0 ws1a5">yield </span><span class="ls49 ws827">之后的下面这个语句才是使得程序占用极少内存的 </span><span class="ff4 ls0 ws828">Elemen<span class="_ _1"></span>tT<span class="_ _8"></span>ree <span class="ff1 ls49 ws1a6">的核心</span></span></div><div class="t m0 x5 h9 y14dc ff1 fs3 fc0 sc0 ls0">特性：</div><div class="t m0 x5 hf y14dd ff8 fs5 fc0 sc0 ls0 ws13a">elem_stack[<span class="fc6 ls34">-</span><span class="fc7">2</span><span class="ls34">]<span class="fc6">.</span></span>remove(elem)</div><div class="t m0 x0 h9 y14de ff1 fs3 fc0 sc0 ls0 ws829">这<span class="_ _6"></span>个<span class="_ _6"></span>语<span class="_ _6"></span>句<span class="_ _6"></span>使<span class="_ _6"></span>得<span class="_ _6"></span>之<span class="_ _6"></span>前<span class="_ _6"></span>由 <span class="ff6 ws177">yield </span><span class="ls14 ws174">产生的元素从它的父节点中删除掉<span class="_ _1"></span>。假设已经没有其</span></div><div class="t m0 x5 h9 y1122 ff1 fs3 fc0 sc0 ls0">它的地方引用这个元素了，那么这个元素就被销毁并回收内存。</div><div class="t m0 x0 h9 y14df ff1 fs3 fc0 sc0 ls0 wsa0">对节<span class="_ _6"></span>点<span class="_ _6"></span>的迭<span class="_ _6"></span>代<span class="_ _6"></span>式<span class="_ _6"></span>解析<span class="_ _6"></span>和<span class="_ _6"></span>删除<span class="_ _6"></span>的<span class="_ _6"></span>最终<span class="_ _6"></span>效<span class="_ _6"></span>果就<span class="_ _6"></span>是<span class="_ _6"></span>一个<span class="_ _6"></span>在<span class="_ _6"></span>文<span class="_ _6"></span>档上<span class="_ _6"></span>高<span class="_ _6"></span>效的<span class="_ _6"></span>增<span class="_ _6"></span>量式<span class="_ _6"></span>清<span class="_ _6"></span>扫过<span class="_ _6"></span>程。</div><div class="t m0 x5 h9 y14e0 ff1 fs3 fc0 sc0 ls13 wse5">文档树结构从始自终没被完整的创建过<span class="_ _1"></span>。尽管如此，还是能通过上述简单的方式来处<span class="_ _c"></span></div><div class="t m0 x5 h7 y14e1 ff1 fs3 fc0 sc0 ls0 ws38">理这个 <span class="ff4 ws61">XML </span>数据。</div><div class="t m0 x0 h9 y14e2 ff1 fs3 fc0 sc0 ls3a ws153">这种方案的主要缺陷就是它的运行性能了。我自己测试的结果是，读取整个文档到</div><div class="t m0 x5 h9 y14e3 ff1 fs3 fc0 sc0 ls2d ws132">内存中的版本的运行速度差不多是增量式处理版本的两倍快。但是它却使用了超过后<span class="_ _1"></span></div><div class="t m0 x5 h7 y14e4 ff1 fs3 fc0 sc0 ls4">者<span class="ff4 ls0 ws82a">60 <span class="ff1">倍的内存。因此，如果你更关心内存使用量的话，那么增量式的版本完胜。</span></span></div><div class="t m0 x5 hd y14e5 ff2 fs4 fc4 sc0 ls0 ws134">8.5<span class="_ _e"> </span>6.5 <span class="ff1 ws165">将字典转换为 </span>XML</div><div class="t m0 x5 he y14e6 ff2 fs2 fc4 sc0 ls0 ws135">8.5.1 <span class="ff1">问题</span></div><div class="t m0 x0 h7 y14e7 ff1 fs3 fc0 sc0 ls0 wsc">你想使用一个 <span class="ff4 ws5c">Python </span><span class="ws63">字典存储数据，并将它转换成 <span class="ff4 ws64">XML </span>格式。</span></div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 ws13e">8.5.<span class="_ _5"> </span>6.5 <span class="ff1 ws16b">将字典转换为 </span><span class="ws82b">XML 182</span></div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
