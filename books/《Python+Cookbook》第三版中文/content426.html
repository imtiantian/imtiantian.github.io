<div id="pf1aa" class="pf w0 h0" data-page-no="1aa"><div class="pc pc1aa w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg1aa.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 hf y1e8 ff8 fs5 fc0 sc0 ls0 ws13a">echo_server((<span class="ff9 fc9 ls34">&apos;&apos;</span><span class="ls32">,</span><span class="fc7">25000</span><span class="ws4">), authkey<span class="fc6 ls34">=<span class="fc0">b</span></span><span class="ff9 fc9 ws13b">&apos;</span></span><span class="fc9">peekaboo<span class="ff9 ls34">&apos;</span></span>)</div><div class="t m0 x0 h9 y2b5a ff1 fs3 fc0 sc0 ls0">然后客户端连接服务器并发送消息的简单示例：</div><div class="t m0 x5 hf y2b5b ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="fca ws15a">from <span class="fcc wsf5c">multiprocessing.connection </span><span class="ws146">import <span class="ff8 fc0">Client</span></span></span></div><div class="t m0 x5 hf y2b5c ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls32">c<span class="fc6 ls33">=</span><span class="ls0 ws13a">Client((<span class="ff9 fc9 ws13b">&apos;</span><span class="fc9">localhost<span class="ff9 ls34">&apos;</span></span></span>,<span class="fc7 ls0 ws13a">25000<span class="fc0 ws13b">), authkey<span class="fc6 ls34">=</span><span class="ws13a">b<span class="ff9 fc9 ls34">&apos;</span><span class="fc9">peekaboo<span class="ff9 ls34">&apos;</span></span>)</span></span></span></span></div><div class="t m0 x5 hf y2b5d ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls34">c<span class="fc6 ls0 ws13a">.<span class="fc0">send(</span></span><span class="ff9 fc9">&apos;<span class="ff8 ls0 ws13a">hello</span>&apos;</span><span class="ls0">)</span></span></div><div class="t m0 x5 hf y2b5e ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls34">c<span class="fc6 ls0 ws13a">.<span class="fc0">recv()</span></span></span></div><div class="t m0 x5 hf y2b5f ff9 fs5 fc8 sc0 ls34">&apos;<span class="ff8 ls0 ws13a">hello<span class="ff9">&apos;</span></span></div><div class="t m0 x5 hf y2b60 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls34">c<span class="fc6 ls0 ws13a">.<span class="fc0">send(<span class="fc7">42</span>)</span></span></span></div><div class="t m0 x5 hf y2b61 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls34">c<span class="fc6 ls0 ws13a">.<span class="fc0">recv()</span></span></span></div><div class="t m0 x5 hf y2b62 ff8 fs5 fc8 sc0 ls0">42</div><div class="t m0 x5 hf y2b63 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls34">c<span class="fc6 ls0 ws13a">.<span class="fc0">send([<span class="fc7">1</span><span class="ls33">,</span></span></span><span class="fc7">2</span><span class="ls32">,</span><span class="fc7">3</span><span class="ls32">,</span><span class="fc7">4</span><span class="ls32">,</span><span class="fc7">5</span><span class="ls0">])</span></span></div><div class="t m0 x5 hf y2b64 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls34">c<span class="fc6 ls0 ws13a">.<span class="fc0">recv()</span></span></span></div><div class="t m0 x5 hf y2b65 ff8 fs5 fc8 sc0 ls0 ws4">[1, 2, 3, 4, 5]</div><div class="t m0 x5 hf y2b66 ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h7 y2b67 ff1 fs3 fc0 sc0 ls0 wsf5e">跟<span class="_ _0"></span>底<span class="_ _6"></span>层 <span class="ff4 wsf5f">so<span class="_ _6"></span>ck<span class="_ _c"></span>et <span class="ff1 ls98 wsf60">不同的是<span class="_ _c"></span>，每个消息会完整保存（<span class="_ _c"></span>每一个通过 <span class="ff4 ls0 wsf61">send() </span><span class="ws3a3">发送的对象<span class="_ _c"></span></span></span></span></div><div class="t m0 x5 h7 y2b68 ff1 fs3 fc0 sc0 ls1e wsf62">能通过 <span class="ff4 ls0 wsf63">recv() </span><span class="wsf64">来完整接受<span class="_ _1"></span>）<span class="_ _f"></span>。另外<span class="_ _c"></span>，所有对象会通过 <span class="ff4 ls0 wsf65">pickle <span class="ff1 wsa0">序列<span class="_ _6"></span>化。<span class="_ _6"></span>因<span class="_ _6"></span>此，<span class="_ _6"></span>任<span class="_ _6"></span>何兼<span class="_ _6"></span>容</span></span></span></div><div class="t m0 x5 h7 y2b69 ff4 fs3 fc0 sc0 ls0 wsf66">pic<span class="_ _1"></span>kle <span class="ff1">的对象都能在此连接上面被发送和接受。</span></div><div class="t m0 x5 he y2b6a ff2 fs2 fc4 sc0 ls0 ws212">13.7.3 <span class="ff1">讨论</span></div><div class="t m0 x0 h7 y2b6b ff1 fs3 fc0 sc0 ls82 wsf67">目前有很多用来实现各种消息传输的包和函数库，比如 <span class="ff4 ls0 wsa5">ZeroMQ</span><span class="ls1e6">、<span class="ff4 ls0 wsf68">Celery <span class="ff1 wsa0">等。你还</span></span></span></div><div class="t m0 x5 h7 y2b6c ff1 fs3 fc0 sc0 ls17 wsf69">有另外一种选择就是自己在底层 <span class="ff4 ls0 wsf6a">so<span class="_ _6"></span>c<span class="_ _1"></span>k<span class="_ _1"></span>et <span class="ff1 ls17 wsf6">基础之上来实现一个消息传输层。但是你想要<span class="_ _1"></span></span></span></div><div class="t m0 x5 h9 y2b6d ff1 fs3 fc0 sc0 ls36 wsf6b">简单一点的方案<span class="_ _1"></span>，那么这时候 <span class="ff6 ls0 wsf6c">multiprocessing.connection <span class="ff1 wsa0">就<span class="_ _6"></span>派<span class="_ _6"></span>上<span class="_ _6"></span>用<span class="_ _0"></span>场了。<span class="_ _0"></span>仅仅<span class="_ _6"></span>使</span></span></div><div class="t m0 x5 h9 y2b6e ff1 fs3 fc0 sc0 ls0">用一些简单的语句即可实现多个解释器之间的消息通信。</div><div class="t m0 x0 h9 y2b6f ff1 fs3 fc0 sc0 ls56 ws1fa">如果你的解释器运行在同一台机器上面<span class="_ _c"></span>，那么你可以使用另外的通信机制<span class="_ _1"></span>，比如<span class="_ _1"></span></div><div class="t m0 x5 h7 y2b70 ff4 fs3 fc0 sc0 ls0 wsf6d">Unix <span class="ff1 ls35 wsf6e">域套接字或者是 </span><span class="wsf6f">Windo<span class="_ _1"></span>ws <span class="ff1 ls35 wsf70">命名管道。要想使用 </span><span class="wsf71">UNIX <span class="ff1 ls35 ws144">域套接字来创建一个连接，</span></span></span></div><div class="t m0 x5 h9 y2b71 ff1 fs3 fc0 sc0 ls0">只需简单的将地址改写一个文件名即可：</div><div class="t m0 x5 hf y2b72 ff8 fs5 fc0 sc0 ls32">s<span class="fc6 ls33">=</span><span class="ls0 ws13a">Listener(<span class="ff9 fc9 ls34">&apos;</span><span class="fc9">/tmp/myconn<span class="ff9 ls34">&apos;</span></span><span class="ws13b">, authkey<span class="fc6 ls34">=<span class="fc0">b<span class="ff9 fc9">&apos;</span></span></span></span><span class="fc9">peekaboo<span class="ff9 ls34">&apos;</span></span>)</span></div><div class="t m0 x0 h7 y2b73 ff1 fs3 fc0 sc0 ls0 wsc">要想使用 <span class="ff4 wse50">Windo<span class="_ _1"></span>ws <span class="ff1">命名管道来创建连接，只需像下面这样使用一个文件名：</span></span></div><div class="t m0 x5 hf y2b74 ff8 fs5 fc0 sc0 ls32">s<span class="fc6 ls33">=</span><span class="ls0 ws13a">Listener(<span class="fc9 ls34">r<span class="ff9">&apos;<span class="ff7 ls0 ws156">\\</span></span><span class="ls0">.\pipe\myconn</span><span class="ff9">&apos;</span></span><span class="ws13b">, authkey<span class="fc6 ls34">=<span class="fc0">b</span></span><span class="ff9 fc9">&apos;</span></span><span class="fc9">peekaboo<span class="ff9 ls34">&apos;</span></span>)</span></div><div class="t m0 x0 h9 y2b75 ff1 fs3 fc0 sc0 ls0 wsf72">一<span class="_ _12"></span>个<span class="_ _0"></span>通<span class="_ _12"></span>用<span class="_ _12"></span>准<span class="_ _12"></span>则<span class="_ _12"></span>是，<span class="_ _12"></span>你<span class="_ _0"></span>不<span class="_ _12"></span>要<span class="_ _12"></span>使<span class="_ _12"></span>用 <span class="ff6 wsf73">multiprocessing </span><span class="ls1e5 wsf41">来实现一个对外的公共服务<span class="_ _8"></span>。<span class="_ _8"></span></span></div><div class="t m0 x5 h9 y2b76 ff6 fs3 fc0 sc0 ls0 wsf74">Client() <span class="ff1 lsc9">和</span><span class="ws141">Listener() <span class="ff1 ws55b">中的 </span><span class="wsf75">authkey <span class="ff1 ls18 ws110">参数用来认证发起连接的终端用户。如果密钥</span></span></span></div><div class="t m0 x5 h9 y2b77 ff1 fs3 fc0 sc0 ls0 wsa0">不对<span class="_ _6"></span>会产<span class="_ _6"></span>生<span class="_ _6"></span>一个<span class="_ _6"></span>异常。<span class="_ _6"></span>此外，<span class="_ _6"></span>该<span class="_ _6"></span>模块<span class="_ _6"></span>最适<span class="_ _6"></span>合<span class="_ _6"></span>用来<span class="_ _6"></span>建立<span class="_ _6"></span>长连<span class="_ _6"></span>接<span class="_ _6"></span>（而不<span class="_ _6"></span>是大<span class="_ _6"></span>量的<span class="_ _6"></span>短<span class="_ _6"></span>连接）<span class="_ _f"></span>，</div><div class="t m0 x5 h9 y2b78 ff1 fs3 fc0 sc0 ls2d ws132">例如<span class="_ _1"></span>，两个解释器之间启动后就开始建立连接并在处理某个问题过程中会一直保<span class="_ _6"></span>持连<span class="_ _1"></span></div><div class="t m0 x5 h9 y2b79 ff1 fs3 fc0 sc0 ls0">接状态。</div><div class="t m0 x0 h7 y2b7a ff1 fs3 fc0 sc0 ls48 wsf76">如果你需要对底层连接做更多的控制<span class="_ _1"></span>，比如需要支持超时<span class="_ _1"></span>、非阻塞 <span class="ff4 ls0 ws3c9">I/<span class="_ _6"></span>O <span class="ff1 wsa0">或<span class="_ _6"></span>其他<span class="_ _6"></span>类</span></span></div><div class="t m0 x5 h7 y2b7b ff1 fs3 fc0 sc0 ls0 ws14">似的特性，你最好使用另外的库或者是在高层 <span class="ff4 wsebb">so<span class="_ _6"></span>c<span class="_ _1"></span>k<span class="_ _1"></span>et <span class="ff1">上来实现这些特性。</span></span></div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 ws21d">13.7.<span class="_ _5"> </span>11.7 <span class="ff1 ws16b">在不同的 </span><span class="wscda">Python <span class="ff1 wsf5d">解释器之间交互 </span>417</span></div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
