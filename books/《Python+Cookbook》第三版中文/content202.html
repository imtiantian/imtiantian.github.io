<div id="pfca" class="pf w0 h0" data-page-no="ca"><div class="pc pcca w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bgca.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x16 hf y1ab ff8 fs5 fc0 sc0 ls34">f<span class="fc6 ls0 ws13a">.<span class="fc0">write(record_struct</span><span class="ls34">.</span><span class="fc0">pack(</span><span class="ls34">*</span><span class="fc0">r))</span></span></div><div class="t m0 x5 h11 y1ad ffa fs5 fcd sc0 ls0 ws4"># Example</div><div class="t m0 x5 hf y1ae ff7 fs5 fca sc0 ls0 ws157">if <span class="ff8 fc0 ws16d">__name__ <span class="fc6 ws159">== <span class="ff9 fc9 ls34">&apos;</span><span class="fc9 ws13a">__main__<span class="ff9 ls34">&apos;</span></span></span>:</span></div><div class="t m0 x15 hf y1af ff8 fs5 fc0 sc0 ls0 ws155">records <span class="fc6 ls32">=</span><span class="ws4">[ (<span class="fc7 ls34">1</span><span class="ls33">,</span><span class="fc7 ws13a">2.3</span><span class="ls32">,</span><span class="fc7 ws13a">4.5</span>),</span></div><div class="t m0 x18 hf y1b0 ff8 fs5 fc0 sc0 ls0 ws13a">(<span class="fc7 ls34">6</span><span class="ls33">,</span><span class="fc7">7.8</span><span class="ls32">,</span><span class="fc7">9.0</span>),</div><div class="t m0 x18 hf y355 ff8 fs5 fc0 sc0 ls0 ws13a">(<span class="fc7">12</span><span class="ls32">,</span><span class="fc7">13.4</span><span class="ls33">,</span><span class="fc7">56.7</span><span class="ws13b">) ]</span></div><div class="t m0 x15 hf y410 ff7 fs5 fca sc0 ls0 ws15a">with <span class="ff8 ws13a">open<span class="fc0 ls34">(<span class="ff9 fc9">&apos;</span></span><span class="fc9">data.b<span class="ff9 ls34">&apos;</span><span class="fc0 ls32">,</span><span class="ff9 ls34">&apos;</span>wb<span class="ff9 ws13b">&apos;</span><span class="fc0 ls33">)</span></span></span><span class="ws157">as <span class="ff8 fc0">f:</span></span></div><div class="t m0 x16 hf y411 ff8 fs5 fc0 sc0 ls0 ws8a2">write_records(records, <span class="ff9 fc9 ws13b">&apos;<span class="ff8 ws13a">&lt;idd</span><span class="ls34">&apos;</span></span><span class="ws13b">, f)</span></div><div class="t m0 x0 h9 y15f2 ff1 fs3 fc0 sc0 ls3a ws153">有很多种方法来读取这个文件并返回一个元组列表。首先，如果你打算以块的形式</div><div class="t m0 x5 h9 y15f3 ff1 fs3 fc0 sc0 ls0">增量读取文件，你可以这样做：</div><div class="t m0 x5 hf y15f4 ff7 fs5 fca sc0 ls0 ws15a">from <span class="fcc ws146">struct <span class="fca">import <span class="ff8 fc0">Struct</span></span></span></div><div class="t m0 x5 hf yf37 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">read_records<span class="fc0 ws13b">(format, f):</span></span></div><div class="t m0 x15 hf y15f5 ff8 fs5 fc0 sc0 ls0 ws147">record_struct <span class="fc6 ls33">=</span>Struct(format)</div><div class="t m0 x15 hf y15f6 ff8 fs5 fc0 sc0 ls0 ws145">chunks <span class="fc6 ls32">=</span><span class="fca ws13a">iter</span><span class="ls34">(</span><span class="ff7 fca ws156">lambda</span><span class="ws4">: f<span class="fc6 ws13a">.<span class="fc0">read(record_struct</span><span class="ls34">.</span></span>size), b<span class="ff9 fc9 ws13b">&apos;&apos;</span>)</span></div><div class="t m0 x15 hf y15f7 ff7 fs5 fca sc0 ls0 ws146">return <span class="ff8 fc0 ws13a">(record_struct<span class="fc6 ls34">.</span><span class="ws147">unpack(chunk) </span></span><span class="ws139">for <span class="ff8 fc0 ws15f">chunk </span><span class="ws160">in <span class="ff8 fc0">chunks)</span></span></span></div><div class="t m0 x5 h11 y15f8 ffa fs5 fcd sc0 ls0 ws4"># Example</div><div class="t m0 x5 hf y15f9 ff7 fs5 fca sc0 ls0 ws157">if <span class="ff8 fc0 ws16d">__name__ <span class="fc6 ws159">== <span class="ff9 fc9 ls34">&apos;</span><span class="fc9 ws13a">__main__<span class="ff9 ls34">&apos;</span></span></span>:</span></div><div class="t m0 x15 hf y15fa ff7 fs5 fca sc0 ls0 ws15a">with <span class="ff8 ws13a">open<span class="fc0 ls34">(<span class="ff9 fc9">&apos;</span></span><span class="fc9">data.b<span class="ff9 ls34">&apos;<span class="ff8 fc0">,</span><span class="ls0 ws13b">&apos;</span></span>rb<span class="ff9 ls34">&apos;</span><span class="fc0 ls32">)</span></span></span><span class="ws157">as <span class="ff8 fc0">f:</span></span></div><div class="t m0 x16 hf y15fb ff7 fs5 fca sc0 ls0 ws139">for <span class="ff8 fc0 ws158">rec </span><span class="ws157">in <span class="ff8 fc0 ws13a">read_records(<span class="ff9 fc9 ls34">&apos;</span><span class="fc9">&lt;idd<span class="ff9 ls34">&apos;</span></span><span class="ws13b">, f):</span></span></span></div><div class="t m0 x17 h11 y15fc ffa fs5 fcd sc0 ls0 ws13b"># Process rec</div><div class="t m0 x17 hf y15fd ff8 fs5 fc6 sc0 ls0 ws13a">...</div><div class="t m0 x0 h9 y15fe ff1 fs3 fc0 sc0 ls3a ws153">如果你想将整个文件一次性读取到一个字节字符串中，然后在分片解析。那么你可</div><div class="t m0 x5 h9 y15ff ff1 fs3 fc0 sc0 ls0">以这样做：</div><div class="t m0 x5 hf y1600 ff7 fs5 fca sc0 ls0 ws15a">from <span class="fcc ws146">struct <span class="fca">import <span class="ff8 fc0">Struct</span></span></span></div><div class="t m0 x5 hf y1601 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">unpack_records<span class="fc0 ws4">(format, data):</span></span></div><div class="t m0 x15 hf y1602 ff8 fs5 fc0 sc0 ls0 ws147">record_struct <span class="fc6 ls33">=</span>Struct(format)</div><div class="t m0 x15 hf y1603 ff7 fs5 fca sc0 ls0 ws146">return <span class="ff8 fc0 ws13a">(record_struct<span class="fc6 ls34">.</span><span class="ws13b">unpack_from(data, offset)</span></span></div><div class="t m0 x17 hf y1604 ff7 fs5 fca sc0 ls0 ws139">for <span class="ff8 fc0 ws145">offset </span><span class="ws157">in <span class="ff8 ws13a">range<span class="fc0">(<span class="fc7 ls34">0</span><span class="ls32">,</span></span>len<span class="fc0 ws13b">(data), record_struct<span class="fc6 ls34">.</span>size))</span></span></span></div><div class="t m0 x5 h11 y1605 ffa fs5 fcd sc0 ls0 ws4"># Example</div><div class="t m0 x5 hf y1606 ff7 fs5 fca sc0 ls0 ws157">if <span class="ff8 fc0 ws16d">__name__ <span class="fc6 ws159">== <span class="ff9 fc9 ls34">&apos;</span><span class="fc9 ws13a">__main__<span class="ff9 ls34">&apos;</span></span></span>:</span></div><div class="t m0 x15 hf y1607 ff7 fs5 fca sc0 ls0 ws15a">with <span class="ff8 ws13a">open<span class="fc0 ls34">(<span class="ff9 fc9">&apos;</span></span><span class="fc9">data.b<span class="ff9 ls34">&apos;</span><span class="fc0 ls32">,</span><span class="ff9 ls34">&apos;</span>rb<span class="ff9 ws13b">&apos;</span><span class="fc0 ls33">)</span></span></span><span class="ws157">as <span class="ff8 fc0">f:</span></span></div><div class="t m0 x16 hf y1608 ff8 fs5 fc0 sc0 ls0 ws161">data <span class="fc6 ls33">=</span><span class="ls34">f</span><span class="fc6 ws13a">.</span>read()</div><div class="t m0 x15 hf y1609 ff7 fs5 fca sc0 ls0 ws139">for <span class="ff8 fc0 ws158">rec </span><span class="ws157">in <span class="ff8 fc0 ws13a">unpack_records(<span class="ff9 fc9 ls34">&apos;</span><span class="fc9">&lt;idd<span class="ff9 ls34">&apos;</span></span><span class="ws4">, data):</span></span></span></div><div class="t m0 x16 h11 y160a ffa fs5 fcd sc0 ls0 ws13b"># Process rec</div><div class="t m0 x16 hf y160b ff8 fs5 fc6 sc0 ls0 ws13a">...</div><div class="t m0 x0 h9 y160c ff1 fs3 fc0 sc0 ls0">两种情况下的结果都是一个可返回用来创建该文件的原始元组的可迭代对象。</div><div class="t m0 x5 he yec1 ff2 fs2 fc4 sc0 ls0 ws212">8.11.3 <span class="ff1">讨论</span></div><div class="t m0 x0 h9 y6e ff1 fs3 fc0 sc0 lse ws435">对于需要编码和解码二进制数据的程序而言，通常会使用 <span class="ff6 ls0 ws20b">struct <span class="ff1 wsa0">模块。为了<span class="_ _6"></span>声明</span></span></div><div class="t m0 x5 h9 y674 ff1 fs3 fc0 sc0 ls0 ws14">一个新的结构体，只需要像这样创建一个 <span class="ff6 ws25d">Struct </span>实例即可：</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 ws21d">8.11.<span class="_ _5"> </span>6.11 <span class="ff1 ws544">读写二进制数组数据 </span>193</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
