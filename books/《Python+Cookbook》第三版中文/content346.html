<div id="pf15a" class="pf w0 h0" data-page-no="15a"><div class="pc pc15a w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg15a.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 hf y1ab ff8 fs5 fc8 sc0 ls0 ws4">(x, y)</div><div class="t m0 x5 hf y1ac ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x5 hd yac1 ff2 fs4 fc4 sc0 ls0 ws211">11.17<span class="_ _e"> </span>9.17 <span class="ff1">在类上强制使用编程规约</span></div><div class="t m0 x5 he yac2 ff2 fs2 fc4 sc0 ls0 wsadf">11.17.1 <span class="ff1">问题</span></div><div class="t m0 x0 h9 y243f ff1 fs3 fc0 sc0 ls3a ws153">你的程序包含一个很大的类继承体系，你希望强制执行某些编程规约（或者代码诊</div><div class="t m0 x5 h9 y453 ff1 fs3 fc0 sc0 ls0">断）来帮助程序员保持清醒。</div><div class="t m0 x5 he y2440 ff2 fs2 fc4 sc0 ls0 wsadf">11.17.2 <span class="ff1">解决方案</span></div><div class="t m0 x0 h9 y1af1 ff1 fs3 fc0 sc0 ls3a ws153">如果你想监控类的定义，通常可以通过定义一个元类。一个基本元类通常是继承自</div><div class="t m0 x5 h9 y2441 ff6 fs3 fc0 sc0 ls0 ws27b">type <span class="ff1 ws9d6">并重定义它的 </span><span class="ws308">new<span class="_ _e"> </span>() <span class="ff1 ws911">方法或者是 </span>init<span class="_ _e"> </span>() <span class="ff1">方法。比如：</span></span></div><div class="t m0 x5 hf y2442 ff7 fs5 fca sc0 ls0 ws16a">class <span class="fcc ws156">MyMeta<span class="ff8 fc0 ws13a">(<span class="fca">type</span>):</span></span></div><div class="t m0 x15 hf y2443 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">__new__<span class="fc0 ls34">(</span><span class="fca">self<span class="fc0 ws4">, clsname, bases, clsdict):</span></span></span></div><div class="t m0 x16 h11 y69b ffa fs5 fcd sc0 ls0 ws4"># clsname is name of class being defined</div><div class="t m0 x16 h11 y2444 ffa fs5 fcd sc0 ls0 ws4"># bases is tuple of base classes</div><div class="t m0 x16 h11 y2445 ffa fs5 fcd sc0 ls0 ws4"># clsdict is class dictionary</div><div class="t m0 x16 hf y2446 ff7 fs5 fca sc0 ls0 ws146">return <span class="ff8 ws13a">super<span class="fc0">()<span class="fc6 ls34">.</span><span class="ws4">__new__(cls, clsname, bases, clsdict)</span></span></span></div><div class="t m0 x0 h9 y2447 ff1 fs3 fc0 sc0 ls0 ws911">另一种是，定义 <span class="ff6 ws308">init<span class="_ _e"> </span>() </span>方法：</div><div class="t m0 x5 hf y19b9 ff7 fs5 fca sc0 ls0 ws16a">class <span class="fcc ws156">MyMeta<span class="ff8 fc0 ws13a">(<span class="fca">type</span>):</span></span></div><div class="t m0 x15 hf y2448 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">__init__<span class="fc0">(<span class="fca">self</span><span class="ws4">, clsname, bases, clsdict):</span></span></span></div><div class="t m0 x16 hf y2449 ff8 fs5 fca sc0 ls0 ws13a">super<span class="fc0">()<span class="fc6 ls34">.</span><span class="ws13b">__init__(clsname, bases, clsdict)</span></span></div><div class="t m0 x16 h11 y244a ffa fs5 fcd sc0 ls0 ws4"># clsname is name of class being defined</div><div class="t m0 x16 h11 y244b ffa fs5 fcd sc0 ls0 ws4"># bases is tuple of base classes</div><div class="t m0 x16 h11 y244c ffa fs5 fcd sc0 ls0 ws4"># clsdict is class dictionary</div><div class="t m0 x0 h9 y244d ff1 fs3 fc0 sc0 ls3a ws153">为了使用这个元类，你通常要将它放到到一个顶级父类定义中，然后其他的类继承</div><div class="t m0 x5 h9 y244e ff1 fs3 fc0 sc0 ls0">这个顶级父类。例如：</div><div class="t m0 x5 hf y244f ff7 fs5 fca sc0 ls0 ws16a">class <span class="fcc ws156">Root<span class="ff8 fc0 ws13a">(metaclass<span class="fc6">=</span>MyMeta):</span></span></div><div class="t m0 x15 h10 y483 ff7 fs5 fca sc0 ls0">pass</div><div class="t m0 x5 hf y2450 ff7 fs5 fca sc0 ls0 ws16a">class <span class="fcc ls34">A</span><span class="ff8 fc0">(Root):</span></div><div class="t m0 x15 h10 y1f6e ff7 fs5 fca sc0 ls0">pass</div><div class="t m0 x5 hf y2451 ff7 fs5 fca sc0 ls0 ws16a">class <span class="fcc ls34">B</span><span class="ff8 fc0">(Root):</span></div><div class="t m0 x15 h10 y2452 ff7 fs5 fca sc0 ls0">pass</div><div class="t m0 x0 h9 y80a ff1 fs3 fc0 sc0 ls143 ws8b1">元类的一个关键特点是它允许你在定义的时候检查类的内容<span class="_ _1d"></span>。在重新定义<span class="_ _19"></span></div><div class="t m0 x32 h9 y80b ff6 fs3 fc0 sc0 ls0 wsc4e">init<span class="_ _e"> </span>() <span class="ff1 ls19d wsc4f">方法中<span class="_ _d"></span>，你可以很轻松的检查类字典<span class="_ _d"></span>、父类等等<span class="_ _d"></span>。并且<span class="_ _d"></span>，一旦某个<span class="_ _6"></span>元类<span class="_ _8"></span></span></div><div class="t m0 x5 h9 y2453 ff1 fs3 fc0 sc0 ls0 wsa0">被<span class="_ _6"></span>指定<span class="_ _6"></span>给<span class="_ _6"></span>了<span class="_ _6"></span>某<span class="_ _6"></span>个<span class="_ _6"></span>类，那<span class="_ _6"></span>么<span class="_ _6"></span>就<span class="_ _6"></span>会<span class="_ _6"></span>被<span class="_ _6"></span>继承<span class="_ _6"></span>到<span class="_ _6"></span>所<span class="_ _6"></span>有<span class="_ _6"></span>子<span class="_ _6"></span>类中<span class="_ _6"></span>去。<span class="_ _6"></span>因<span class="_ _6"></span>此，<span class="_ _6"></span>一<span class="_ _6"></span>个<span class="_ _6"></span>框架<span class="_ _6"></span>的<span class="_ _6"></span>构<span class="_ _6"></span>建<span class="_ _6"></span>者<span class="_ _6"></span>就能</div><div class="t m0 x5 h9 y2454 ff1 fs3 fc0 sc0 ls0">在大型的继承体系中通过给一个顶级父类指定一个元类去捕获所有下面子类的定义。</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 wsae0">11.17.<span class="_ _5"> </span>9.17 <span class="ff1 wsb03">在类上强制使用编程规约 </span>337</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
