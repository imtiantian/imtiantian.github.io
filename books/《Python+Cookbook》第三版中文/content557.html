<div id="pf22d" class="pf w0 h0" data-page-no="22d"><div class="pc pc22d w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg22d.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 hf y1ab ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws159">p1 <span class="fc6 ls33">=</span><span class="ws13a">sample<span class="fc6 ls34">.</span>Point(<span class="fc7 ls34">1</span>,<span class="fc7 ls34">2</span>)</span></span></div><div class="t m0 x5 hf y1ac ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws159">p2 <span class="fc6 ls33">=</span><span class="ws13a">sample<span class="fc6 ls34">.</span>Point(<span class="fc7 ls34">4</span>,<span class="fc7 ls34">5</span>)</span></span></div><div class="t m0 x5 hf y1ad ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws13a">sample<span class="fc6 ls34">.</span>distance(p1,p2)</span></div><div class="t m0 x5 hf y1ae ff8 fs5 fc8 sc0 ls0">4.242640687119285</div><div class="t m0 x5 hf y1af ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x5 he y35d7 ff2 fs2 fc4 sc0 ls0 ws212">17.1.3 <span class="ff1">讨论</span></div><div class="t m0 x0 h7 y35d8 ff1 fs3 fc0 sc0 ls0 ws1368">本小节有很多值得我们详细讨论的地方。首先是对于 <span class="ff4 ls204">C</span><span class="ls1ec">和</span><span class="ff4 ws1369">Python </span>代码一起打包的</div><div class="t m0 x5 h7 y35d9 ff1 fs3 fc0 sc0 ls30 ws136a">问题，如果你在使用 <span class="ff6 ls0 ws8aa">ctypes </span><span class="ws136b">来访问编译后的 <span class="ff4 ls249">C</span><span class="ws138">代码<span class="_ _c"></span>，那么需要确保这个共享库放在</span></span></div><div class="t m0 x5 h7 y35da ff6 fs3 fc0 sc0 ls0 ws1231">sample.py <span class="ff1 ls82 ws7d0">模块同一个地方。一种可能是将生成的 </span><span class="ws136c">.so <span class="ff1 ls82 ws136d">文件放置在要使用它的 </span><span class="ff4">Python</span></span></div><div class="t m0 x5 h9 y35db ff1 fs3 fc0 sc0 ls40 ws136e">代码同一个目录下<span class="_ _1"></span>。我们在 <span class="ff6 ls0 ws303">recipe<span class="_ _6"></span><span class="ffc fs7 ls24a">—</span><span class="ws136f">sample.py <span class="ff1 ws1370">中<span class="_ _6"></span>使用 </span><span class="ws1371">file <span class="ff1 wsa0">变<span class="_ _6"></span>量<span class="_ _6"></span>来<span class="_ _6"></span>查<span class="_ _6"></span>看<span class="_ _6"></span>它<span class="_ _6"></span>被<span class="_ _6"></span>安装</span></span></span></span></div><div class="t m0 x5 h9 y35dc ff1 fs3 fc0 sc0 ls0 ws63">的位置，然后构造一个指向同一个目录中的 <span class="ff6 ws1dc">libsample.so </span>文件的路径。</div><div class="t m0 x0 h7 y143 ff1 fs3 fc0 sc0 ls0 ws1372">如果 <span class="ff4 ls24b">C</span><span class="ls3d ws1373">函数库被安装到其他地方，那么你就要修改相应的路径。如果 <span class="ff4 ls24b">C</span></span><span class="wsa0">函数库<span class="_ _6"></span>在</span></div><div class="t m0 x5 h9 y35dd ff1 fs3 fc0 sc0 ls1d ws1374">你机器上被安装为一个标准库了<span class="_ _c"></span>，那么可以使用 <span class="ff6 ls0 wsf27">ctypes.util.find library()<span class="_ _18"> </span><span class="ff1 wsa0">函<span class="_ _6"></span>数</span></span></div><div class="t m0 x5 h9 y35de ff1 fs3 fc0 sc0 ls0">来查找：</div><div class="t m0 x5 hf y35df ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="fca ws15a">from <span class="fcc ws168">ctypes.util </span><span class="ws146">import <span class="ff8 fc0">find_library</span></span></span></div><div class="t m0 x5 hf y35e0 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws13a">find_library(<span class="ff9 fc9 ls34">&apos;<span class="ff8">m</span>&apos;</span>)</span></div><div class="t m0 x5 hf y35e1 ff9 fs5 fc8 sc0 ls34">&apos;<span class="ff8 ls0 ws13a">/usr/lib/libm.dylib<span class="ff9">&apos;</span></span></div><div class="t m0 x5 hf y35e2 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws13a">find_library(<span class="ff9 fc9 ls34">&apos;</span><span class="fc9">pthread<span class="ff9 ls34">&apos;</span></span>)</span></div><div class="t m0 x5 hf y35e3 ff9 fs5 fc8 sc0 ls34">&apos;<span class="ff8 ls0 ws13a">/usr/lib/libpthread.dylib<span class="ff9">&apos;</span></span></div><div class="t m0 x5 hf y35e4 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws13a">find_library(<span class="ff9 fc9 ls34">&apos;</span><span class="fc9">sample<span class="ff9 ls34">&apos;</span></span>)</span></div><div class="t m0 x5 hf y35e5 ff9 fs5 fc8 sc0 ls34">&apos;<span class="ff8 ls0 ws13a">/usr/local/lib/libsample.so<span class="ff9">&apos;</span></span></div><div class="t m0 x5 hf y35e6 ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h7 y261d ff1 fs3 fc0 sc0 ls0 ws1375">一 旦 你 知 道 了<span class="_ _29"> </span><span class="ff4 ls24c">C</span><span class="ls24d ws1376">函数库的位置<span class="_ _20"></span>，那么就可以像下面这样使用<span class="_ _20"></span></span></div><div class="t m0 x5 h9 y35e7 ff6 fs3 fc0 sc0 ls0 ws1026">ctypes.cdll.LoadLibrary() <span class="ff1 ws2b1">来加载它，其中 </span><span class="ws17a">path <span class="ff1">是标准库的全路径：</span></span></div><div class="t m0 x5 hf y25a5 ff8 fs5 fc0 sc0 ls0 ws13c">_mod <span class="fc6 ls32">=</span><span class="ws13a">ctypes<span class="fc6 ls34">.</span>cdll<span class="fc6 ls34">.</span>LoadLibrary(_path)</span></div><div class="t m0 x0 h9 y35e8 ff1 fs3 fc0 sc0 ls3a ws153">函数库被加载后，你需要编写几个语句来提取特定的符号并指定它们的类型。就像</div><div class="t m0 x5 h9 y35e9 ff1 fs3 fc0 sc0 ls0">下面这个代码片段一样：</div><div class="t m0 x5 h11 y35ea ffa fs5 fcd sc0 ls0 ws4"># int in_mandel(double, double, int)</div><div class="t m0 x5 hf y35eb ff8 fs5 fc0 sc0 ls0 ws16e">in_mandel <span class="fc6 ls33">=</span><span class="ws13a">_mod<span class="fc6">.</span>in_mandel</span></div><div class="t m0 x5 hf y35ec ff8 fs5 fc0 sc0 ls0 ws13a">in_mandel<span class="fc6">.</span><span class="ws16d">argtypes <span class="fc6 ls32">=</span></span>(ctypes<span class="fc6 ls34">.</span><span class="ws4">c_double, ctypes</span><span class="fc6">.</span><span class="ws4">c_double, ctypes<span class="fc6 ls34">.</span>c_int)</span></div><div class="t m0 x5 hf y35ed ff8 fs5 fc0 sc0 ls0 ws13a">in_mandel<span class="fc6">.</span><span class="ws155">restype <span class="fc6 ls33">=</span></span>ctypes<span class="fc6 ls34">.</span>c_int</div><div class="t m0 x0 h9 y35ee ff1 fs3 fc0 sc0 ls0 wsa0">在<span class="_ _0"></span>这<span class="_ _12"></span>段<span class="_ _0"></span>代<span class="_ _12"></span>码<span class="_ _0"></span>中，<span class="_ _12"></span><span class="ff6 ws1377">.argtypes </span><span class="ls10c ws9c5">属性是一个元组<span class="_ _8"></span>，<span class="_ _6"></span>包含了某个函数的输入按时<span class="_ _8"></span>，而<span class="_ _d"></span></span></div><div class="t m0 x5 h7 y35ef ff6 fs3 fc0 sc0 ls0 ws1378">.restype <span class="ff1 ws1379">就是相应的返回类型。 </span><span class="ws137a">ctypes <span class="ff1 ws137b">定义了大量的类型对象<span class="_ _c"></span>（比如 <span class="ff4 ws137c">c<span class="_ _7"> </span>double, c<span class="_ _7"> </span>in<span class="_ _1"></span>t,</span></span></span></div><div class="t m0 x5 h7 y35f0 ff4 fs3 fc0 sc0 ls0 ws137d">c short,<span class="_ _18"> </span>c ﬂoat<span class="_ _18"> </span><span class="ff1 ws137e">等）<span class="_ _f"></span>，<span class="_ _6"></span>代<span class="_ _6"></span>表<span class="_ _0"></span>了<span class="_ _6"></span>对<span class="_ _0"></span>应<span class="_ _6"></span>的 <span class="ff4 ls24e">C</span><span class="ws137f">数<span class="_ _6"></span>据<span class="_ _0"></span>类<span class="_ _6"></span>型。<span class="_ _0"></span>如<span class="_ _6"></span>果<span class="_ _6"></span>你<span class="_ _0"></span>想<span class="_ _6"></span>让 <span class="ff4 wsca1">Python </span><span class="ls23 ws11a">能够传递正确<span class="_ _c"></span></span></span></span></div><div class="t m0 x5 h9 y35f1 ff1 fs3 fc0 sc0 ls13 wse5">的参数类型并且正确的转换数据的话<span class="_ _1"></span>，那么这些类型签名的绑定是很重要的一步。如<span class="_ _c"></span></div><div class="t m0 x5 h9 y35f2 ff1 fs3 fc0 sc0 ls1e ws111">果你没有这么做<span class="_ _1"></span>，不但代码不能正常运行<span class="_ _1"></span>，还可能会导致整个解释器进程挂掉<span class="_ _1"></span>。使用</div><div class="t m0 x5 h7 y35f3 ff4 fs3 fc0 sc0 ls0 ws1380">ct<span class="_ _1"></span>yp<span class="_ _6"></span>es <span class="ff1 ws1381">有一<span class="_ _6"></span>个<span class="_ _6"></span>麻烦<span class="_ _6"></span>点<span class="_ _6"></span>的地<span class="_ _6"></span>方是<span class="_ _6"></span>原<span class="_ _6"></span>生的 </span><span class="ls24f">C</span><span class="ff1 ws1382">代<span class="_ _6"></span>码使<span class="_ _6"></span>用<span class="_ _6"></span>的术<span class="_ _6"></span>语可<span class="_ _6"></span>能<span class="_ _6"></span>跟 </span><span class="ws10ff">Python <span class="ff1 wsa0">不能<span class="_ _6"></span>明<span class="_ _6"></span>确的<span class="_ _6"></span>对</span></span></div><div class="t m0 x5 h9 y35f4 ff1 fs3 fc0 sc0 ls0 ws348">应上来。 <span class="ff6 ws12b0">divide() </span><span class="wsa0">函数是一个很好的例子，它通过一个参数除以另一个参数返回一个</span></div><div class="t m0 x5 h7 y35f5 ff1 fs3 fc0 sc0 ls0 ws1383">结果<span class="_ _6"></span>值。<span class="_ _6"></span>尽管<span class="_ _6"></span>这<span class="_ _6"></span>是一<span class="_ _6"></span>个<span class="_ _6"></span>很常<span class="_ _6"></span>见<span class="_ _6"></span>的 <span class="ff4 ls250">C</span><span class="ws1384">技术，<span class="_ _6"></span>但<span class="_ _6"></span>是在 <span class="ff4 ws759">Python </span><span class="wsa0">中<span class="_ _6"></span>却不<span class="_ _6"></span>知<span class="_ _6"></span>道怎<span class="_ _6"></span>样<span class="_ _6"></span>清晰<span class="_ _6"></span>的<span class="_ _6"></span>表达</span></span></div><div class="t m0 x5 h9 y35f6 ff1 fs3 fc0 sc0 ls0">出来。例如，你不能像下面这样简单的做：</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 ws21d">17.1.<span class="_ _36"> </span>15.1 <span class="ff1 ws16b">使用 </span><span class="ws135b">ctypes <span class="ff1 ws16b">访问 </span><span class="ls246">C</span><span class="ff1 ws135c">代码 </span>548</span></div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
