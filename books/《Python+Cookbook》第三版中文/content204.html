<div id="pfcc" class="pf w0 h0" data-page-no="cc"><div class="pc pccc w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bgcc.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 hf y1ab ff8 fs5 fc8 sc0 ls34">b<span class="ff9 ls0 ws13b">&apos;</span><span class="ls0 ws13a">\x0c\x00\x00\x00\xcd\xcc\xcc\xcc\xcc\xcc*@\x9a\x99\x99\x99\x99YL@<span class="ff9">&apos;</span></span></div><div class="t m0 x5 hf y1ac ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h9 y85b ff1 fs3 fc0 sc0 ls3a ws153">如你所见，创建一个可迭代对象的一个原因是它能允许使用一个生成器推导来创建</div><div class="t m0 x5 h9 y85c ff1 fs3 fc0 sc0 ls0">记录。如果你不使用这种技术，那么代码可能会像下面这样：</div><div class="t m0 x5 hf y162f ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">read_records<span class="fc0 ws13b">(format, f):</span></span></div><div class="t m0 x15 hf y70e ff8 fs5 fc0 sc0 ls0 ws147">record_struct <span class="fc6 ls33">=</span>Struct(format)</div><div class="t m0 x15 hf y70f ff7 fs5 fca sc0 ls0 ws16a">while <span class="ff8 ws13a">True<span class="fc0">:</span></span></div><div class="t m0 x16 hf y710 ff8 fs5 fc0 sc0 ls0 ws158">chk <span class="fc6 ls32">=</span><span class="ls34">f<span class="fc6">.</span></span><span class="ws13a">read(record_struct<span class="fc6">.</span>size)</span></div><div class="t m0 x16 hf y5db ff7 fs5 fca sc0 ls0 ws157">if <span class="ff8 fc0 ws158">chk <span class="fc6 ws159">== </span><span class="ls34">b</span><span class="ff9 fc9 ws13b">&apos;&apos;</span>:</span></div><div class="t m0 x17 h10 y598 ff7 fs5 fca sc0 ls0">break</div><div class="t m0 x16 hf y599 ff7 fs5 fca sc0 ls0 ws16a">yield <span class="ff8 fc0 ws13a">record_struct<span class="fc6">.</span>unpack(chk)</span></div><div class="t m0 x0 h9 y1630 ff1 fs3 fc0 sc0 ls147 ws8b9">在函数 <span class="ff6 ls0 ws3b7">unpack records()<span class="_ _29"> </span></span><span class="ls148 ws8ba">中使用了另外一种方法 <span class="ff6 ls0 ws3cd">unpack from()<span class="_ _29"> </span><span class="ff1">。</span></span></span></div><div class="t m0 x5 h9 y1631 ff6 fs3 fc0 sc0 ls0 ws3b7">unpack from()<span class="_ _b"> </span><span class="ff1 wsa0">对<span class="_ _0"></span>于<span class="_ _0"></span>从<span class="_ _0"></span>一<span class="_ _0"></span>个<span class="_ _0"></span>大<span class="_ _0"></span>型<span class="_ _0"></span>二<span class="_ _0"></span>进<span class="_ _0"></span>制<span class="_ _0"></span>数<span class="_ _12"></span>组<span class="_ _0"></span>中<span class="_ _0"></span>提<span class="_ _0"></span>取<span class="_ _0"></span>二<span class="_ _0"></span>进<span class="_ _0"></span>制<span class="_ _0"></span>数<span class="_ _0"></span>据<span class="_ _0"></span>非<span class="_ _0"></span>常<span class="_ _0"></span>有<span class="_ _0"></span>用，<span class="_ _0"></span>因<span class="_ _0"></span>为<span class="_ _0"></span>它<span class="_ _12"></span>不</span></div><div class="t m0 x5 h7 y1632 ff1 fs3 fc0 sc0 ls6c ws8bb">会产生任何的临时对象或者进行内存复制操作<span class="_ _c"></span>。<span class="_ _6"></span>你只需要给它一个字节字符串 <span class="ff4 ls1b">(</span><span class="ls0 wsa0">或<span class="_ _6"></span>数</span></div><div class="t m0 x5 h7 y1633 ff1 fs3 fc0 sc0 lsb">组<span class="ff4 ls6a">)</span><span class="ls0">和一个字节偏移量，它会从那个位置开始直接解包数据。</span></div><div class="t m0 x0 h9 y1634 ff1 fs3 fc0 sc0 ls0 ws8bc">如果你使用 <span class="ff6 ws8bd">unpack() </span><span class="ls82 ws8be">来代替 </span><span class="ff6 ws8bf">unpack<span class="_ _7"> </span>from() </span><span class="ls82 ws2f9">，你需要修改代码来构造大量的小的</span></div><div class="t m0 x5 h9 y1635 ff1 fs3 fc0 sc0 ls0">切片以及进行偏移量的计算。比如：</div><div class="t m0 x5 hf y1636 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">unpack_records<span class="fc0 ws4">(format, data):</span></span></div><div class="t m0 x15 hf y1637 ff8 fs5 fc0 sc0 ls0 ws147">record_struct <span class="fc6 ls33">=</span>Struct(format)</div><div class="t m0 x15 hf y1638 ff7 fs5 fca sc0 ls0 ws146">return <span class="ff8 fc0 ws13a">(record_struct<span class="fc6 ls34">.</span><span class="ws8c0">unpack(data[offset:offset <span class="fc6 ls32">+</span></span>record_struct<span class="fc6">.</span>size])</span></div><div class="t m0 x17 hf y1639 ff7 fs5 fca sc0 ls0 ws139">for <span class="ff8 fc0 ws145">offset </span><span class="ws157">in <span class="ff8 ws13a">range<span class="fc0">(<span class="fc7 ls34">0</span><span class="ls32">,</span></span>len<span class="fc0 ws13b">(data), record_struct<span class="fc6 ls34">.</span>size))</span></span></span></div><div class="t m0 x0 h9 y163a ff1 fs3 fc0 sc0 ls3a ws153">这种方案除了代码看上去很复杂外，还得做很多额外的工作，因为它执行了大量的</div><div class="t m0 x5 h9 y163b ff1 fs3 fc0 sc0 ls13 wse5">偏移量计算<span class="_ _1"></span>，复制数据以及构造小的切片对象。如果你准备从读取到的一个大型字节<span class="_ _c"></span></div><div class="t m0 x5 h9 yf60 ff1 fs3 fc0 sc0 ls0 wsa0">字符串中解包大量的结构体的话，<span class="ff6 ws25d">unpack<span class="_ _7"> </span>from() </span>会表现的更出色。</div><div class="t m0 x0 h9 y163c ff1 fs3 fc0 sc0 ls0 wsa0">在解包的时候，<span class="ff6 ws1e8">collections </span><span class="ls35 ws144">模块中的命名元组对象或许是你想要用到的。它可以</span></div><div class="t m0 x5 h9 y163d ff1 fs3 fc0 sc0 ls0">让你给返回元组设置属性名称。例如：</div><div class="t m0 x5 hf y163e ff7 fs5 fca sc0 ls0 ws15a">from <span class="fcc ws168">collections </span><span class="ws146">import <span class="ff8 fc0">namedtuple</span></span></div><div class="t m0 x5 hf y163f ff8 fs5 fc0 sc0 ls0 ws145">Record <span class="fc6 ls33">=</span><span class="ws13a">namedtuple(<span class="ff9 fc9 ws13b">&apos;</span><span class="fc9">Record<span class="ff9 ws13b">&apos;</span></span><span class="ws4">, [<span class="ff9 fc9 ws13b">&apos;</span></span><span class="fc9">kind<span class="ff9 ls34">&apos;</span></span><span class="ls34">,</span><span class="ff9 fc9 ws13b">&apos;<span class="ff8 ls34">x<span class="ff9">&apos;</span><span class="fc0">,</span></span>&apos;<span class="ff8 ls34">y<span class="ff9">&apos;</span></span></span>])</span></div><div class="t m0 x5 hf y1640 ff7 fs5 fca sc0 ls0 ws15a">with <span class="ff8 ws13a">open<span class="fc0">(<span class="ff9 fc9 ls34">&apos;</span><span class="fc9">data.p<span class="ff9 ls34">&apos;</span></span><span class="ls33">,</span><span class="ff9 fc9 ws13b">&apos;</span><span class="fc9">rb<span class="ff9 ws13b">&apos;</span></span><span class="ls33">)</span></span></span><span class="ws157">as <span class="ff8 fc0">f:</span></span></div><div class="t m0 x15 hf y1641 ff8 fs5 fc0 sc0 ls0 ws155">records <span class="fc6 ls32">=</span><span class="ws13a">(Record(<span class="fc6 ls34">*</span><span class="ws159">r) <span class="ff7 fca ws139">for </span><span class="ls32">r</span><span class="ff7 fca ws157">in </span></span>read_records(<span class="ff9 fc9 ls34">&apos;</span><span class="fc9">&lt;idd<span class="ff9 ws13b">&apos;</span></span><span class="ws4">, f))</span></span></div><div class="t m0 x5 hf y1642 ff7 fs5 fca sc0 ls0 ws139">for <span class="ff8 fc0 ls32">r</span><span class="ws160">in <span class="ff8 fc0">records:</span></span></div><div class="t m0 x15 hf y1643 ff7 fs5 fca sc0 ls0 ws156">print<span class="ff8 fc0 ws13a">(r<span class="fc6 ls34">.</span><span class="ws13b">kind, r<span class="fc6 ls34">.</span>x, r<span class="fc6 ls34">.</span>y)</span></span></div><div class="t m0 x0 h9 y1644 ff1 fs3 fc0 sc0 ls0 ws48a">如果你的程序需要处理大量的二进制数据，<span class="_ _1"></span>你最好使用 <span class="ff6 ws8c1">numpy </span><span class="wsa0">模块。<span class="_ _1"></span>例如，<span class="_ _1"></span>你可以</span></div><div class="t m0 x5 h9 y1645 ff1 fs3 fc0 sc0 ls0">将一个二进制数据读取到一个结构化数组中而不是一个元组列表中。就像下面这样：</div><div class="t m0 x5 h10 y1646 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="fca ws146">import <span class="fcc ws16a">numpy </span><span class="ws160">as <span class="fcc">np</span></span></span></div><div class="t m0 x5 hf y1647 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls32">f<span class="fc6 ls33">=<span class="fca ls0 ws13a">open<span class="fc0">(<span class="ff9 fc9 ls34">&apos;</span><span class="fc9">data.b<span class="ff9 ws13b">&apos;</span></span><span class="ls33">,</span><span class="ff9 fc9 ws13b">&apos;</span><span class="fc9">rb<span class="ff9 ls34">&apos;</span></span>)</span></span></span></span></div><div class="t m0 x5 hf y1648 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws155">records <span class="fc6 ls32">=</span><span class="ws13a">np<span class="fc6">.</span><span class="ws4">fromfile(f, dtype</span><span class="fc6">=<span class="ff9 fc9 ls34">&apos;</span><span class="fc9">&lt;i,&lt;d,&lt;d<span class="ff9 ls34">&apos;</span></span></span>)</span></span></div><div class="t m0 x5 hf y1649 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0">records</span></div><div class="t m0 x5 hf y164a ff8 fs5 fc8 sc0 ls0 ws4">array([(1, 2.3, 4.5), (6, 7.8, 9.0), (12, 13.4, 56.7)],</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 ws21d">8.11.<span class="_ _5"> </span>6.11 <span class="ff1 ws544">读写二进制数组数据 </span>195</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
