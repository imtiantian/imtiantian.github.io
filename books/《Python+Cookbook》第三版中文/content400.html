<div id="pf190" class="pf w0 h0" data-page-no="190"><div class="pc pc190 w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg190.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 h7 y2a ff1 fs3 fc0 sc0 ls0 wse13">位于 <span class="ff4 wse0e">path </span><span class="lsa8 wse14">中的实体会被 </span><span class="ff6 wse15">handle<span class="_ _7"> </span>url() </span><span class="lsa8 wse16">函数检查。这会导致新的 </span><span class="ff6 wse17">UrlPathFinder </span>实</div><div class="t m0 x5 h9 y2b ff1 fs3 fc0 sc0 ls0 ws14">例被创建并且被加入到 <span class="ff6 ws3a9">sys.path importer cache<span class="_ _a"> </span></span>中。</div><div class="t m0 x0 h9 y8dd ff1 fs3 fc0 sc0 ls0 wse18">还<span class="_ _6"></span>有<span class="_ _6"></span>个<span class="_ _0"></span>难点<span class="_ _0"></span>就<span class="_ _6"></span>是 <span class="ff6 ws3cd">handle url() </span><span class="ls56 wse19">函数以<span class="_ _6"></span>及它跟内部使用的 </span><span class="ff6 ws196">get links() </span><span class="wsa0">函<span class="_ _0"></span>数<span class="_ _6"></span>之<span class="_ _6"></span>间</span></div><div class="t m0 x5 h7 y99 ff1 fs3 fc0 sc0 ls0 wse1a">的交互。如果你的查找器实现需要使用到其他模块（比如 <span class="ff4 wsa5">urllib.request</span><span class="wsa0">）<span class="_ _f"></span>，有可能这些</span></div><div class="t m0 x5 h9 y9a ff1 fs3 fc0 sc0 ls3a wse1b">模块会在查找器操作期间进行更多的导入。它可以导致 <span class="ff6 ls0 ws4e9">handle<span class="_ _7"> </span>url() </span><span class="ws153">和其他查找器部</span></div><div class="t m0 x5 h9 y9b ff1 fs3 fc0 sc0 ls13 wse5">分陷入一种递归循环状态<span class="_ _1"></span>。为了解释这种可能性，实现中有一个被创建的查找器缓存<span class="_ _c"></span></div><div class="t m0 x38 h7 y9c ff1 fs3 fc0 sc0 ls0 wse1c">（每一<span class="_ _6"></span>个 <span class="ff4 wse1d">URL </span><span class="wsa0">一个）<span class="_ _f"></span>。<span class="_ _6"></span>它<span class="_ _6"></span>可以<span class="_ _6"></span>避免<span class="_ _6"></span>创建<span class="_ _6"></span>重<span class="_ _6"></span>复查<span class="_ _6"></span>找器<span class="_ _6"></span>的问<span class="_ _6"></span>题。<span class="_ _6"></span>另外，<span class="_ _6"></span>下面<span class="_ _6"></span>的<span class="_ _6"></span>代码<span class="_ _6"></span>片段<span class="_ _6"></span>可</span></div><div class="t m0 x5 h9 y9d ff1 fs3 fc0 sc0 ls0">以确保查找器不会在初始化链接集合的时候响应任何导入请求：</div><div class="t m0 x5 h11 y23ed ffa fs5 fcd sc0 ls0 ws4"># Check link cache</div><div class="t m0 x5 hf y28d8 ff7 fs5 fca sc0 ls0 ws157">if <span class="ff8 ws13a">self<span class="fc6 ls34">.</span><span class="fc0 ws145">_links </span></span>is <span class="ff8 ws13a">None<span class="fc0">:</span></span></div><div class="t m0 x15 hf y28d9 ff8 fs5 fca sc0 ls0 ws13a">self<span class="fc6 ls34">.</span><span class="fc0 ws145">_links <span class="fc6 ls32">=</span><span class="ws159">[] <span class="ffa fcd ws4"># See discussion</span></span></span></div><div class="t m0 x15 hf y28da ff8 fs5 fca sc0 ls0 ws13a">self<span class="fc6 ls34">.</span><span class="fc0 ws145">_links <span class="fc6 ls32">=</span><span class="ws13a">_get_links(</span></span>self<span class="fc6 ls34">.</span><span class="fc0">_baseurl)</span></div><div class="t m0 x0 h9 y28db ff1 fs3 fc0 sc0 ls0 wse1e">最后，<span class="_ _6"></span>查找<span class="_ _6"></span>器的 <span class="ff6 wse1f">invalidate<span class="_ _7"> </span>caches() </span><span class="ls17 wsf6">方法是一个工具方法，用来清理内部缓存。<span class="_ _1"></span></span></div><div class="t m0 x5 h9 y28dc ff1 fs3 fc0 sc0 ls16d wse20">这个方法再用户调用 <span class="ff6 ls0 wse21">importlib.invalidate caches()<span class="_ _b"> </span><span class="ff1 wsa0">的<span class="_ _0"></span>时<span class="_ _0"></span>候<span class="_ _0"></span>被<span class="_ _0"></span>触<span class="_ _0"></span>发。<span class="_ _0"></span>如<span class="_ _0"></span>果<span class="_ _6"></span>你<span class="_ _0"></span>想<span class="_ _0"></span>让</span></span></div><div class="t m0 x5 h7 y715 ff4 fs3 fc0 sc0 ls0 ws30">URL <span class="ff1">导入者重新读取链接列表的话可以使用它。</span></div><div class="t m0 x0 h7 y28dd ff1 fs3 fc0 sc0 ls0 wse22">对比<span class="_ _6"></span>下两<span class="_ _6"></span>种方<span class="_ _6"></span>案（修<span class="_ _6"></span>改 <span class="ff4 wse23">sys.meta path </span><span class="ls17 wse24">或使用一个路径钩子）<span class="_ _f"></span>。使用 <span class="ff4 ls0 wse25">sys.meta path</span></span></div><div class="t m0 x5 h9 y1f8 ff1 fs3 fc0 sc0 ls13 wse5">的导入者可以按照自己的需要自由处理模块<span class="_ _1"></span>。例如，它们可以从数据库中导入或以不<span class="_ _c"></span></div><div class="t m0 x5 h7 y28de ff1 fs3 fc0 sc0 ls0 wsa0">同于一<span class="_ _6"></span>般模块<span class="ff4 ls6">/</span><span class="ls2c ws12f">包处理方式导入。这种自由同样意味着导入者需要自己进行内部的一些</span></div><div class="t m0 x5 h7 y28df ff1 fs3 fc0 sc0 ls22 wse26">管理。另外<span class="_ _c"></span>，基于路径的钩子只是适用于对 <span class="ff4 ls0 wse27">sys.path </span><span class="ws119">的处理。通过这种扩展加载的模</span></div><div class="t m0 x5 h9 y28e0 ff1 fs3 fc0 sc0 ls0">块跟普通方式加载的特性是一样的。</div><div class="t m0 x0 h9 y28e1 ff1 fs3 fc0 sc0 ls63 ws21f">如果到现在为止你还是不是很明白<span class="_ _c"></span>，那么可以通过增加一些日志打印来测试下本<span class="_ _1"></span></div><div class="t m0 x5 h9 y28e2 ff1 fs3 fc0 sc0 ls0">节。像下面这样：</div><div class="t m0 x5 hf y28e3 ff8 fs5 fc0 sc0 ls0 ws4">&gt;&gt;&gt; import logging</div><div class="t m0 x5 hf y28e4 ff8 fs5 fc0 sc0 ls0 ws4">&gt;&gt;&gt; logging.basicConfig(level=logging.DEBUG)</div><div class="t m0 x5 hf y28e5 ff8 fs5 fc0 sc0 ls0 ws4">&gt;&gt;&gt; import urlimport</div><div class="t m0 x5 hf y566 ff8 fs5 fc0 sc0 ls0 ws4">&gt;&gt;&gt; urlimport.install_path_hook()</div><div class="t m0 x5 hf y567 ff8 fs5 fc0 sc0 ls0 ws4">DEBUG:urlimport:Installing handle_url</div><div class="t m0 x5 hf y28e6 ff8 fs5 fc0 sc0 ls0 ws4">&gt;&gt;&gt; import fib</div><div class="t m0 x5 hf y28e7 ff8 fs5 fc0 sc0 ls0 ws4">DEBUG:urlimport:Handle path? /usr/local/lib/python33.zip. [No]</div><div class="t m0 x5 hf y28e8 ff8 fs5 fc0 sc0 ls0 ws4">Traceback (most recent call last):</div><div class="t m0 x5 hf y28e9 ff8 fs5 fc0 sc0 ls0 ws4">File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="t m0 x5 hf y28ea ff8 fs5 fc0 sc0 ls0 ws4">ImportError: No module named <span class="ff9 ls34">&apos;</span><span class="ws13a">fib<span class="ff9">&apos;</span></span></div><div class="t m0 x5 hf y28eb ff8 fs5 fc0 sc0 ls0 ws4">&gt;&gt;&gt; import sys</div><div class="t m0 x5 hf y28ec ff8 fs5 fc0 sc0 ls0 ws4">&gt;&gt;&gt; sys.path.append(<span class="ff9 ws13b">&apos;</span><span class="ws13a">http://localhost:15000<span class="ff9 ls34">&apos;</span>)</span></div><div class="t m0 x5 hf y28ed ff8 fs5 fc0 sc0 ls0 ws4">&gt;&gt;&gt; import fib</div><div class="t m0 x5 hf y17ff ff8 fs5 fc0 sc0 ls0 ws4">DEBUG:urlimport:Handle path? http://localhost:15000. [Yes]</div><div class="t m0 x5 hf y28ee ff8 fs5 fc0 sc0 ls0 ws4">DEBUG:urlimport:Getting links from http://localhost:15000</div><div class="t m0 x5 hf y28ef ff8 fs5 fc0 sc0 ls0 ws4">DEBUG:urlimport:links: {<span class="ff9 ls34">&apos;</span><span class="ws13a">spam.py<span class="ff9 ls34">&apos;</span><span class="ls32">,<span class="ff9 ls34">&apos;</span></span>fib.py<span class="ff9 ws13b">&apos;</span><span class="ls33">,</span><span class="ff9 ws13b">&apos;</span>grok<span class="ff9 ls34">&apos;</span>}</span></div><div class="t m0 x5 hf y28f0 ff8 fs5 fc0 sc0 ls0 wse28">DEBUG:urlimport:find_loader: <span class="ff9 ls34">&apos;</span><span class="ws13a">fib<span class="ff9">&apos;</span></span></div><div class="t m0 x5 hf y24f9 ff8 fs5 fc0 sc0 ls0 wse29">DEBUG:urlimport:find_loader: module <span class="ff9 ls34">&apos;</span><span class="ws13a">fib<span class="ff9 ls33">&apos;</span>found</span></div><div class="t m0 x5 hf y28f1 ff8 fs5 fc0 sc0 ls0 wsc51">DEBUG:urlimport:loader: reading <span class="ff9 ls34">&apos;</span><span class="ws13a">http://localhost:15000/fib.py<span class="ff9">&apos;</span></span></div><div class="t m0 x5 hf y1a94 ff8 fs5 fc0 sc0 ls0 wscb8">DEBUG:urlimport:loader: <span class="ff9 ls34">&apos;</span><span class="ws13a">http://localhost:15000/fib.py<span class="ff9 ls33">&apos;</span>loaded</span></div><div class="t m0 x5 hf y28f2 ff8 fs5 fc0 sc0 ls34">I<span class="ff9 ls0 ws13b">&apos;</span><span class="ls0 ws4">m fib</span></div><div class="t m0 x5 hf y28f3 ff8 fs5 fc0 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h7 y28f4 ff1 fs3 fc0 sc0 ls0 wsc">最后，建议你花点时间看看 <span class="ff4 fc3 ws9c">PEP 302 </span><span class="ws14">以及 <span class="ff4 wse2a">imp<span class="_ _6"></span>ortlib </span>的文档。</span></div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 wsd97">12.11.<span class="_ _5"> </span>10.11 <span class="ff1 wsd98">通过钩子远程加载模块 </span>391</div><a class="l" href="http://www.python.org/dev/peps/pep-0302"><div class="d m1" style="border-style:none;position:absolute;left:358.927500px;bottom:121.282500px;width:45.358000px;height:16.821000px;background-color:rgba(255,255,255,0.000001);"></div></a></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
