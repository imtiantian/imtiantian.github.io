<div id="pf228" class="pf w0 h0" data-page-no="228"><div class="pc pc228 w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg228.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 hf y1ab ff8 fs5 fc0 sc0 ls0 ws155">squares <span class="fc6 ls32">=</span><span class="ws13a">[x<span class="fc6">*</span><span class="ls33">x</span><span class="ff7 fca ws139">for </span><span class="ls32">x</span><span class="ff7 fca ws157">in </span>sequence]</span></div><div class="t m0 x0 h7 y2ac1 ff1 fs3 fc0 sc0 ls23 ws132b">与此相关<span class="_ _c"></span>，还要注意下那些对 <span class="ff4 ls0 wsca1">Python </span><span class="ws11a">的共享数据机制过于偏执的程序所写的代<span class="_ _c"></span></span></div><div class="t m0 x5 h7 y3597 ff1 fs3 fc0 sc0 ls0 ws132c">码。<span class="_ _6"></span>有些<span class="_ _6"></span>人<span class="_ _6"></span>并<span class="_ _6"></span>没<span class="_ _6"></span>有很<span class="_ _6"></span>好<span class="_ _6"></span>的<span class="_ _6"></span>理<span class="_ _6"></span>解或<span class="_ _6"></span>信<span class="_ _6"></span>任 <span class="ff4 ws4c8">Python </span><span class="ws132d">的<span class="_ _6"></span>内存<span class="_ _6"></span>模<span class="_ _6"></span>型，<span class="_ _6"></span>滥<span class="_ _6"></span>用 <span class="ff6 ws1132">copy.deepcopy() </span>之</span></div><div class="t m0 x5 h9 y3598 ff1 fs3 fc0 sc0 ls0">类的函数。通常在这些代码中是可以去掉复制操作的。</div><div class="t m0 x5 he y3599 ff2 fs2 fc4 sc0 ls0 wsadf">16.14.3 <span class="ff1">讨论</span></div><div class="t m0 x0 h7 y359a ff1 fs3 fc0 sc0 ls0 ws132e">在优化之前，有必要先研究下使用的算法。<span class="_ _1"></span>选择一个复杂度为 <span class="ff4 wsa9d">O(n log n) </span>的算法要</div><div class="t m0 x5 h7 y359b ff1 fs3 fc0 sc0 ls0 ws38">比你去调整一个复杂度为 <span class="ff4 ws132f">O(n**2) </span>的算法所带来的性能提升要大得多。</div><div class="t m0 x0 h9 y359c ff1 fs3 fc0 sc0 ls0 wsa0">如果你觉得你还是得<span class="_ _6"></span>进行优化，那么请从整体考<span class="_ _6"></span>虑。作为一般准则，不要对<span class="_ _6"></span>程序的</div><div class="t m0 x5 h7 y359d ff1 fs3 fc0 sc0 ls82 ws2f9">每一个部分都去优化<span class="ff4 ls23a">,</span>因为这些修改回导致代码难以阅读和理解。你应该专注于优化产</div><div class="t m0 x5 h9 y359e ff1 fs3 fc0 sc0 ls0">生性能瓶颈的地方，比如内部循环。</div><div class="t m0 x0 h9 y359f ff1 fs3 fc0 sc0 ls0">你还要注意微小优化的结果。例如考虑下面创建一个字典的两种方式：</div><div class="t m0 x5 hf y3014 ff8 fs5 fc0 sc0 ls32">a<span class="fc6 ls33">=</span><span class="ls0">{</span></div><div class="t m0 x15 hf y3015 ff9 fs5 fc9 sc0 ls34">&apos;<span class="ff8 ls0 ws13a">name</span><span class="ls32">&apos;<span class="ff8 fc0">:</span></span>&apos;<span class="ff8 ls0 ws13a">AAPL</span>&apos;<span class="ff8 fc0 ls0">,</span></div><div class="t m0 x15 hf y35a0 ff9 fs5 fc9 sc0 ls34">&apos;<span class="ff8 ls0 ws13a">shares</span><span class="ls32">&apos;<span class="ff8 fc0 ls33">:<span class="fc7 ls0 ws13a">100<span class="fc0">,</span></span></span></span></div><div class="t m0 x15 hf y3016 ff9 fs5 fc9 sc0 ls34">&apos;<span class="ff8 ls0 ws13a">price</span><span class="ls33">&apos;<span class="ff8 fc0 ls32">:<span class="fc7 ls0">534.22</span></span></span></div><div class="t m0 x5 hf y3017 ff8 fs5 fc0 sc0 ls0">}</div><div class="t m0 x5 hf y3018 ff8 fs5 fc0 sc0 ls32">b<span class="fc6 ls33">=<span class="fca ls0 ws13a">dict<span class="fc0">(name</span></span><span class="ls34">=<span class="ff9 fc9">&apos;<span class="ff8 ls0 ws13a">AAPL</span>&apos;</span></span></span><span class="ls0 ws13b">, shares<span class="fc6 ls34">=</span><span class="fc7 ws13a">100</span><span class="ws4">, price<span class="fc6 ls34">=</span><span class="fc7 ws13a">534.22</span>)</span></span></div><div class="t m0 x0 h9 y35a1 ff1 fs3 fc0 sc0 ls3d ws164">后面一种写法更简洁一些（你不需要在关键字上输入引号<span class="_ _1"></span>）<span class="_ _f"></span>。不过，如果你将这两<span class="_ _1"></span></div><div class="t m0 x5 h7 y35a2 ff1 fs3 fc0 sc0 lse ws1330">个代码片段进行性能测试对比时，会发现使用 <span class="ff6 ls0 ws1331">dict() </span><span class="ws1313">的方式会慢了 <span class="ff4 ls23b">3</span><span class="ls0 wsa0">倍。看到<span class="_ _6"></span>这个，</span></span></div><div class="t m0 x5 h9 y35a3 ff1 fs3 fc0 sc0 ls0 ws877">你是不是有冲动把所有使用 <span class="ff6 ws496">dict() </span><span class="wsa0">的代码都替换成第一种。不够，聪明的程序员只会</span></div><div class="t m0 x5 h9 y35a4 ff1 fs3 fc0 sc0 ls0">关注他应该关注的地方，比如内部循环。在其他地方，这点性能损失没有什么影响。</div><div class="t m0 x0 h9 yb73 ff1 fs3 fc0 sc0 ls56 ws1fa">如果你的优化要求比较高<span class="_ _c"></span>，本节的这些简单技术满足不了<span class="_ _1"></span>，那么你可以研究下基<span class="_ _1"></span></div><div class="t m0 x5 h7 y22d ff1 fs3 fc0 sc0 ls0 wsa0">于<span class="_ _6"></span>即时<span class="_ _6"></span>编<span class="_ _6"></span>译<span class="_ _6"></span>（<span class="ff4 wsa5">JIT</span><span class="ls40 ws180">）技术的一些工具。例如<span class="_ _c"></span>，<span class="ff4 ls0 ws1332">PyPy </span><span class="wsce6">工程是 <span class="ff4 ls0 wsb5c">Python </span></span>解释器的另外一种</span></div><div class="t m0 x5 h9 y35a5 ff1 fs3 fc0 sc0 ls139 ws859">实现<span class="_ _d"></span>，它会分析你的程序运行并对那些频繁执行的部分生成本机机器码<span class="_ _c"></span>。它有时候<span class="_ _c"></span></div><div class="t m0 x5 h7 y35a6 ff1 fs3 fc0 sc0 ls49 ws1333">能极大的提升性能<span class="_ _1"></span>，通常可以接近 <span class="ff4 ls23c">C</span><span class="ws1a6">代码的速度<span class="_ _1"></span>。不过可惜的是，到写这本书位置<span class="_ _c"></span>，</span></div><div class="t m0 x5 h7 y35a7 ff4 fs3 fc0 sc0 ls0 ws1334">PyPy <span class="ff1 lse ws1335">还不能完全支持 </span><span class="ws1336">Python3. <span class="ff1 lse wsd8">因此，这个是你将来需要去研究的。你还可以考虑下<span class="_ _1"></span></span></span></div><div class="t m0 x5 h7 y2e36 ff4 fs3 fc0 sc0 ls0 ws1337">Num<span class="_ _1"></span>ba <span class="ff1 wsa0">工程，</span><span class="ws1338">Numba <span class="ff1 ls35 ws1339">是一个在你使用装饰器来选择 </span><span class="ws1117">Python <span class="ff1 ls35 ws144">函数进行优化时的动态编</span></span></span></div><div class="t m0 x5 h7 y2a9a ff1 fs3 fc0 sc0 lse ws133a">译器。这些函数会使用 <span class="ff4 ls0 ws133b">LL<span class="_ _19"></span>VM <span class="ff1 lse wsd8">被编译成本地机器码。它同样可以极大的提升<span class="_ _1"></span>性能。但</span></span></div><div class="t m0 x5 h7 y17c0 ff1 fs3 fc0 sc0 ls0 ws38">是，跟 <span class="ff4 ws133c">PyPy </span><span class="wsc">一样，它对于 <span class="ff4 ws9c">Python 3 </span>的支持现在还停留在实验阶段。</span></div><div class="t m0 x0 h7 y35a8 ff1 fs3 fc0 sc0 ls40 ws133d">最后我引用 <span class="ff4 ls0 ws133e">John Ousterhout </span><span class="ws180">说过的话作为结尾<span class="_ _1"></span>：<span class="_ _3"></span>“<span class="_ _c"></span>最好的性能优化时从不工作到</span></div><div class="t m0 x5 h9 y35a9 ff1 fs3 fc0 sc0 ls68 ws23f">工作状态的迁移”<span class="_ _31"></span>。直到你真的需要优化的时候再去考虑它。确保你程序正确的运行通</div><div class="t m0 x5 h7 y35aa ff1 fs3 fc0 sc0 ls0 wsa0">常比让它运行更快要更重要一些（至少开始是这样的）<span class="ff4">.</span></div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 wsd97">16.14.<span class="_ _36"> </span>14.14 <span class="ff1 wse4d">加速程序运行 </span>543</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
