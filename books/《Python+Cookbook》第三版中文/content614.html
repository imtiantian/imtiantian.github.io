<div id="pf266" class="pf w0 h0" data-page-no="266"><div class="pc pc266 w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg266.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 hd y112 ff2 fs4 fc4 sc0 ls0 wsd91">17.21<span class="_ _e"> </span>15.21 <span class="ff1">诊断分段错误</span></div><div class="t m0 x5 he y113 ff2 fs2 fc4 sc0 ls0 wsadf">17.21.1 <span class="ff1">问题</span></div><div class="t m0 x0 h9 y658 ff1 fs3 fc0 sc0 ls0 wsa0">解释器因为某个分段<span class="_ _6"></span>错误、总线错误、访问越界或<span class="_ _6"></span>其他致命错误而突然间<span class="_ _6"></span>奔溃。你</div><div class="t m0 x5 h7 y659 ff1 fs3 fc0 sc0 ls0 ws38">想获得 <span class="ff4 ws5c">Python </span>堆栈信息，从而找出在发生错误的时候你的程序运行点。</div><div class="t m0 x5 he y18fe ff2 fs2 fc4 sc0 ls0 wsadf">17.21.2 <span class="ff1">解决方案</span></div><div class="t m0 x0 h9 y18bb ff6 fs3 fc0 sc0 ls0 ws1dc">faulthandler <span class="ff1">模块能被用来帮你解决这个问题。在你的程序中引入下列代码：</span></div><div class="t m0 x5 h10 y3ac5 ff7 fs5 fca sc0 ls0 ws146">import <span class="fcc">faulthandler</span></div><div class="t m0 x5 hf y3ac6 ff8 fs5 fc0 sc0 ls0 ws13a">faulthandler<span class="fc6">.</span>enable()</div><div class="t m0 x0 h7 y53c ff1 fs3 fc0 sc0 ls0 wsc">另外还可以像下面这样使用 <span class="ff6 wsae2">-Xfaulthandler </span><span class="ws38">来运行 <span class="ff4 wsa5">Python</span>：</span></div><div class="t m0 x5 hf y2cb5 ff8 fs5 fc0 sc0 ls0 ws4">bash % python3 -Xfaulthandler program.py</div><div class="t m0 x0 h7 y3ac7 ff1 fs3 fc0 sc0 ls0 ws1603">最后，你可以设置 <span class="ff6 ws1604">PYTHONFAULTHANDLER </span><span class="ws1605">环境变量。开启 <span class="ff4 ws1606">faulthandler </span><span class="ws1607">后，在 <span class="ff4 ls2b0">C</span>扩</span></span></div><div class="t m0 x5 h7 y3ac8 ff1 fs3 fc0 sc0 ls0 ws14">展中的致命错误会导致一个 <span class="ff4 ws5c">Python </span>错误堆栈被打印出来。例如：</div><div class="t m0 x5 hf y1b6d ff8 fs5 fc0 sc0 ls0 ws4">Fatal Python error: Segmentation fault</div><div class="t m0 x5 hf y1b6f ff8 fs5 fc0 sc0 ls0 ws4">Current thread 0x00007fff71106cc0:</div><div class="t m0 x19 hf y1d81 ff8 fs5 fc0 sc0 ls0 ws4">File &quot;example.py&quot;, line 6 in foo</div><div class="t m0 x19 hf y1b70 ff8 fs5 fc0 sc0 ls0 ws4">File &quot;example.py&quot;, line 10 in bar</div><div class="t m0 x19 hf y1b71 ff8 fs5 fc0 sc0 ls0 ws4">File &quot;example.py&quot;, line 14 in spam</div><div class="t m0 x19 hf y3ac9 ff8 fs5 fc0 sc0 ls0 ws4">File &quot;example.py&quot;, line 19 in &lt;module&gt;</div><div class="t m0 x5 hf y3aca ff8 fs5 fc0 sc0 ls0 ws4">Segmentation fault</div><div class="t m0 x0 h7 y3acb ff1 fs3 fc0 sc0 ls0 ws1114">尽管这个并不能告诉你 <span class="ff4 ls2a9">C</span><span class="ws13d5">代码中哪里出错了，但是至少能告诉你 <span class="ff4 ws1115">Python </span>里面哪里</span></div><div class="t m0 x5 h9 y3acc ff1 fs3 fc0 sc0 ls0">有错。</div><div class="t m0 x5 he y3acd ff2 fs2 fc4 sc0 ls0 wsadf">17.21.3 <span class="ff1">讨论</span></div><div class="t m0 x0 h7 y3ace ff4 fs3 fc0 sc0 ls0 ws1608">faulthandler <span class="ff1 ws1609">会<span class="_ _6"></span>在 </span><span class="ws745">Python <span class="ff1 ls6f ws2a7">代码执行出错的时候向你展示跟踪信息<span class="_ _1"></span>。至少<span class="_ _1"></span>，它会告</span></span></div><div class="t m0 x5 h7 y39f7 ff1 fs3 fc0 sc0 ls68 ws160a">诉你出错时被调用的最顶级扩展函数是哪个。在 <span class="ff4 ls0 ws160b">pdb <span class="ff1 ws1496">和<span class="_ _6"></span>其他 </span><span class="ws886">Python <span class="ff1 wsa0">调试器的帮<span class="_ _6"></span>助下，</span></span></span></div><div class="t m0 x5 h9 y3acf ff1 fs3 fc0 sc0 ls0">你就能追根溯源找到错误所在的位置了。</div><div class="t m0 x0 h7 y3ad0 ff4 fs3 fc0 sc0 ls0 ws160c">faulthandler <span class="ff1 ws31b">不会告诉你任何 </span><span class="ls2b1">C</span><span class="ff1 ws160d">语言中的错误信息。<span class="_ _1"></span>因此，你需要使用传统的 <span class="ff4 ls2b1">C</span>调</span></div><div class="t m0 x5 h7 y3ad1 ff1 fs3 fc0 sc0 ls0 ws160e">试器，比如 <span class="ff4 wsa5">gdb</span><span class="ws160f">。不过，在 <span class="ff4 ws1610">faulthandler </span>追踪信息可以让你去判断从哪里着手。还要注</span></div><div class="t m0 x5 h7 y3ad2 ff1 fs3 fc0 sc0 ls0 ws1611">意<span class="_ _6"></span>的<span class="_ _6"></span>是<span class="_ _6"></span>在 <span class="ff4 ls2a7">C</span><span class="lsa5 ws1612">中某些类型的错误可能不太容易恢复<span class="_ _1"></span>。例如<span class="_ _1"></span>，如果一个 <span class="ff4 ls2a7">C</span><span class="ls0 wsa0">扩<span class="_ _6"></span>展<span class="_ _6"></span>丢<span class="_ _6"></span>弃<span class="_ _6"></span>了<span class="_ _6"></span>程</span></span></div><div class="t m0 x5 h7 y3ad3 ff1 fs3 fc0 sc0 ls0 ws1613">序<span class="_ _6"></span>堆<span class="_ _6"></span>栈<span class="_ _6"></span>信<span class="_ _6"></span>息，<span class="_ _6"></span>它<span class="_ _0"></span>会让 <span class="ff4 ws1614">faulthandler </span><span class="wsa0">不<span class="_ _6"></span>可<span class="_ _0"></span>用，那<span class="_ _6"></span>么<span class="_ _0"></span>你也<span class="_ _0"></span>得不<span class="_ _6"></span>到<span class="_ _0"></span>任何<span class="_ _6"></span>输<span class="_ _0"></span>出（除<span class="_ _6"></span>了<span class="_ _0"></span>程序<span class="_ _0"></span>奔溃</span></div><div class="t m0 x5 h9 y1fa4 ff1 fs3 fc0 sc0 ls0 wsa0">外）<span class="_ _f"></span>。</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 wsd97">17.21.<span class="_ _36"> </span>15.21 <span class="ff1 wse4d">诊断分段错误 </span>605</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
