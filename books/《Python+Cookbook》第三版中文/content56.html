<div id="pf38" class="pf w0 h0" data-page-no="38"><div class="pc pc38 w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg38.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 h9 y2a ff1 fs3 fc0 sc0 ls0 ws14">回匹配，可以使用 <span class="ff6 ws17c">finditer() </span>方法来代替，比如：</div><div class="t m0 x5 hf y212 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="fca">for <span class="ff8 fc0 ls32">m</span><span class="ws157">in <span class="ff8 fc0 ws13a">datepat<span class="fc6">.</span>finditer(text):</span></span></span></div><div class="t m0 x5 hf y213 ff7 fs5 fc5 sc0 ls0 ws139">... <span class="fca ws156">print<span class="ff8 fc0 ws13a">(m<span class="fc6 ls34">.</span>groups())</span></span></div><div class="t m0 x5 h10 y214 ff7 fs5 fc5 sc0 ls0">...</div><div class="t m0 x5 hf y215 ff8 fs5 fc8 sc0 ls34">(<span class="ff9 ls0 ws13b">&apos;</span><span class="ls0 ws13a">11</span><span class="ff9">&apos;</span><span class="ls32">,</span><span class="ff9">&apos;</span><span class="ls0 ws13a">27</span><span class="ff9">&apos;</span><span class="ls32">,</span><span class="ff9">&apos;</span><span class="ls0 ws13a">2012</span><span class="ff9">&apos;</span><span class="ls0">)</span></div><div class="t m0 x5 hf y216 ff8 fs5 fc8 sc0 ls34">(<span class="ff9 ls0 ws13b">&apos;</span>3<span class="ff9">&apos;</span><span class="ls32">,</span><span class="ff9">&apos;</span><span class="ls0 ws13a">13<span class="ff9 ws13b">&apos;</span><span class="ls33">,</span><span class="ff9 ws13b">&apos;</span>2013</span><span class="ff9">&apos;</span><span class="ls0">)</span></div><div class="t m0 x5 hf y217 ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x5 he y5fa ff2 fs2 fc4 sc0 ls0 ws135">4.4.3 <span class="ff1">讨论</span></div><div class="t m0 x0 h7 y5fb ff1 fs3 fc0 sc0 ls0 ws2ff">关<span class="_ _6"></span>于<span class="_ _6"></span>正<span class="_ _6"></span>则<span class="_ _6"></span>表<span class="_ _6"></span>达<span class="_ _6"></span>式<span class="_ _6"></span>理<span class="_ _6"></span>论<span class="_ _6"></span>的<span class="_ _6"></span>教<span class="_ _6"></span>程<span class="_ _6"></span>已<span class="_ _0"></span>经超<span class="_ _6"></span>出<span class="_ _6"></span>了<span class="_ _6"></span>本<span class="_ _6"></span>书<span class="_ _0"></span>的范<span class="_ _6"></span>围。<span class="_ _6"></span>不<span class="_ _6"></span>过，<span class="_ _0"></span>这一<span class="_ _6"></span>节<span class="_ _6"></span>阐<span class="_ _6"></span>述<span class="_ _6"></span>了<span class="_ _0"></span>使用 <span class="ff4">re</span></div><div class="t m0 x5 h9 y5fc ff1 fs3 fc0 sc0 ls0 ws300">模块进行匹配和搜索文本的最基本方法。<span class="_ _1"></span>核心步骤就是先使用 <span class="ff6 ws301">re.compile() </span>编译正则</div><div class="t m0 x5 h7 y5fd ff1 fs3 fc0 sc0 ls0 ws38">表达式字符串，然后使用 <span class="ff6 ws23a">match() <span class="ff4 ls83">,</span><span class="ws1d1">findall() </span></span><span class="ws14">或者 <span class="ff6 ws2d1">finditer() </span>等方法。</span></div><div class="t m0 x0 h9 y5fe ff1 fs3 fc0 sc0 ls1d ws302">当写正则式字符串的时候<span class="_ _c"></span>，相对普遍的做法是使用原始字符串比如 <span class="ff6 ls0 ws303">r&apos;(<span class="ffd ls84">\</span>d<span class="_ _6"></span>+)/<span class="_ _6"></span>(<span class="ffd ls84">\</span>d</span></div><div class="t m0 x5 h9 y5ff ff6 fs3 fc0 sc0 ls0 ws303">+)/<span class="_ _6"></span>(<span class="ffd ls84">\</span><span class="ws304">d+)&apos; <span class="ff1 ls48 ws242">。这种字符串将不去解析反斜杠，这在正则表达式中是很有用的<span class="_ _c"></span>。如果不</span></span></div><div class="t m0 x5 h9 y600 ff1 fs3 fc0 sc0 ls0 ws63">这样做的话，你必须使用两个反斜杠，类似 <span class="ff6 ws303">&apos;(<span class="ffd ws305">\\</span>d+)/(<span class="ffd ws305">\\</span>d+)/(<span class="ffd ws305">\\</span><span class="ws27b">d+)&apos; </span></span>。</div><div class="t m0 x0 h9 y601 ff1 fs3 fc0 sc0 ls0 ws306">需<span class="_ _6"></span>要<span class="_ _6"></span>注<span class="_ _6"></span>意<span class="_ _6"></span>的<span class="_ _6"></span>是 <span class="ff6 ws307">match() </span><span class="ls14 ws174">方法仅仅检查字符串的开始部分<span class="_ _1"></span>。它的匹配结果有可能并<span class="_ _1"></span></span></div><div class="t m0 x5 h9 y602 ff1 fs3 fc0 sc0 ls0">不是你期望的那样。比如：</div><div class="t m0 x5 hf y603 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls32">m<span class="fc6 ls33">=</span><span class="ls0 ws13a">datepat<span class="fc6 ls34">.</span>match(<span class="ff9 fc9 ls34">&apos;</span><span class="fc9">11/27/2012abcdef<span class="ff9 ls34">&apos;</span></span>)</span></span></div><div class="t m0 x5 hf y604 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0">m</span></div><div class="t m0 x5 hf y605 ff8 fs5 fc8 sc0 ls0 ws4">&lt;_sre.SRE_Match object at 0x1005d27e8&gt;</div><div class="t m0 x5 hf y606 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls34">m<span class="fc6 ls0 ws13a">.<span class="fc0">group()</span></span></span></div><div class="t m0 x5 hf y607 ff9 fs5 fc8 sc0 ls34">&apos;<span class="ff8 ls0 ws13a">11/27/2012<span class="ff9">&apos;</span></span></div><div class="t m0 x5 hf y608 ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h9 y609 ff1 fs3 fc0 sc0 ls0 ws63">如果你想精确匹配，确保你的正则表达式以 <span class="ffe ls85">$</span>结尾，就像这么这样：</div><div class="t m0 x5 hf y60a ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws155">datepat <span class="fc6 ls32">=</span><span class="ws13a">re<span class="fc6">.</span>compile(<span class="fc9 ls34">r<span class="ff9">&apos;</span><span class="ls0">(\d+)/(\d+)/(\d+)$<span class="ff9 ws13b">&apos;</span></span></span>)</span></span></div><div class="t m0 x5 hf y60b ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws13a">datepat<span class="fc6 ls34">.</span>match(<span class="ff9 fc9 ls34">&apos;</span><span class="fc9">11/27/2012abcdef<span class="ff9 ls34">&apos;</span></span>)</span></div><div class="t m0 x5 hf y60c ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws13a">datepat<span class="fc6 ls34">.</span>match(<span class="ff9 fc9 ls34">&apos;</span><span class="fc9">11/27/2012<span class="ff9 ls34">&apos;</span></span>)</span></div><div class="t m0 x5 hf y60d ff8 fs5 fc8 sc0 ls0 ws4">&lt;_sre.SRE_Match object at 0x1005d2750&gt;</div><div class="t m0 x5 hf y60e ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h7 y60f ff1 fs3 fc0 sc0 ls1d ws1c3">最后<span class="_ _c"></span>，如果你仅仅是做一次简单的文本匹配<span class="_ _1"></span><span class="ff4 ls0 wsa5">/<span class="ff1 ls1d ws1c3">搜索操作的话<span class="_ _c"></span>，<span class="_ _6"></span>可以略过编译部分<span class="_ _c"></span>，<span class="_ _1"></span></span></span></div><div class="t m0 x5 h9 y610 ff1 fs3 fc0 sc0 ls0 ws14">直接使用 <span class="ff6 ws308">re </span>模块级别的函数。比如：</div><div class="t m0 x5 hf y611 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws13a">re<span class="fc6 ls34">.</span>findall(<span class="fc9 ls34">r<span class="ff9 ls0 ws13b">&apos;</span><span class="ls0">(\d+)/(\d+)/(\d+)<span class="ff9 ws13b">&apos;</span></span></span><span class="ws4">, text)</span></span></div><div class="t m0 x5 hf y612 ff8 fs5 fc8 sc0 ls0 ws13a">[(<span class="ff9 ls34">&apos;</span>11<span class="ff9 ws13b">&apos;</span><span class="ls33">,<span class="ff9 ls34">&apos;</span></span>27<span class="ff9 ls34">&apos;</span><span class="ls32">,<span class="ff9 ls34">&apos;</span></span>2012<span class="ff9 ls34">&apos;</span><span class="ws13b">), (<span class="ff9 ls34">&apos;<span class="ff8">3</span>&apos;</span><span class="ls32">,<span class="ff9 ls34">&apos;</span></span></span>13<span class="ff9 ls34">&apos;</span><span class="ls32">,<span class="ff9 ls34">&apos;</span></span>2013<span class="ff9 ls34">&apos;</span>)]</div><div class="t m0 x5 hf y613 ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h9 y614 ff1 fs3 fc0 sc0 ls3a ws153">但是需要注意的是，如果你打算做大量的匹配和搜索操作的话，最好先编译正则表</div><div class="t m0 x5 h9 y615 ff1 fs3 fc0 sc0 ls0 wsa0">达<span class="_ _6"></span>式，然<span class="_ _6"></span>后<span class="_ _6"></span>再<span class="_ _6"></span>重<span class="_ _6"></span>复<span class="_ _6"></span>使用<span class="_ _6"></span>它。<span class="_ _6"></span>模<span class="_ _6"></span>块<span class="_ _6"></span>级<span class="_ _6"></span>别的<span class="_ _6"></span>函<span class="_ _6"></span>数<span class="_ _6"></span>会<span class="_ _6"></span>将<span class="_ _6"></span>最<span class="_ _6"></span>近编<span class="_ _6"></span>译<span class="_ _6"></span>过<span class="_ _6"></span>的<span class="_ _6"></span>模<span class="_ _6"></span>式缓<span class="_ _6"></span>存<span class="_ _6"></span>起<span class="_ _6"></span>来，<span class="_ _6"></span>因<span class="_ _6"></span>此并</div><div class="t m0 x5 h9 y616 ff1 fs3 fc0 sc0 ls13 wse5">不会消耗太多的性能<span class="_ _1"></span>，但是如果使用预编译模式的话，你将会减少查找和一些额外的<span class="_ _c"></span></div><div class="t m0 x5 h9 y617 ff1 fs3 fc0 sc0 ls0">处理损耗。</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 ws13e">4.4.<span class="_ _5"> </span>2.4 <span class="ff1 ws2fa">字符串匹配和搜索 </span>47</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
