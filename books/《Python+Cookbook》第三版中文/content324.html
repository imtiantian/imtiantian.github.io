<div id="pf144" class="pf w0 h0" data-page-no="144"><div class="pc pc144 w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg144.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 hf y1ab ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws150">bound_values <span class="fc6 ls33">=</span><span class="ws13a">sig<span class="fc6 ls34">.</span>bind(<span class="fc7 ls34">1</span><span class="ls33">,</span><span class="fc7">2</span><span class="ls33">,</span><span class="fc7">3</span>)</span></span></div><div class="t m0 x5 hf y1ac ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws13a">bound_values<span class="fc6">.</span>arguments</span></div><div class="t m0 x5 hf y1ad ff8 fs5 fc8 sc0 ls0 ws13a">OrderedDict([(<span class="ff9 ls34">&apos;<span class="ff8">x</span><span class="ls0 ws13b">&apos;</span></span><span class="ws4">, 1), (<span class="ff9 ls34">&apos;<span class="ff8">y</span>&apos;</span><span class="ws13b">, 2), (<span class="ff9">&apos;</span><span class="ls34">z<span class="ff9">&apos;</span></span>, 3)])</span></span></div><div class="t m0 x5 hf y1ae ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h9 yffa ff1 fs3 fc0 sc0 ls0">使用这个映射我们可以很轻松的实现我们的强制类型检查：</div><div class="t m0 x5 hf yc29 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="fca">for <span class="ff8 fc0 ws13b">name, value </span><span class="ws157">in <span class="ff8 fc0 ws13a">bound_values<span class="fc6 ls34">.</span>arguments<span class="fc6">.</span>items():</span></span></span></div><div class="t m0 x5 hf yc2a ff7 fs5 fc5 sc0 ls0 ws1a2">... <span class="fca ws157">if <span class="ff8 fc0 ws13c">name </span>in <span class="ff8 fc0 ws13a">bound_types<span class="fc6 ls34">.</span>arguments:</span></span></div><div class="t m0 x5 hf yc2b ff7 fs5 fc5 sc0 ls0 ws1a3">... <span class="fca ws157">if not <span class="ff8 ws13a">isinstance<span class="fc0 ws4">(value, bound_types<span class="fc6 ls34">.</span>arguments[name]):</span></span></span></div><div class="t m0 x5 hf y357 ff7 fs5 fc5 sc0 ls0 ws8e2">... <span class="fca ws16a">raise <span class="ff8 ws13a">TypeError<span class="fc0">()</span></span></span></div><div class="t m0 x5 h10 y358 ff7 fs5 fc5 sc0 ls0">...</div><div class="t m0 x5 hf yca3 ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h9 y1765 ff1 fs3 fc0 sc0 ls3a ws153">不过这个方案还有点小瑕疵，它对于有默认值的参数并不适用。比如下面的代码可</div><div class="t m0 x5 h7 y59b ff1 fs3 fc0 sc0 ls0 ws14">以正常工作，尽管 <span class="ff4 wsbe3">items </span>的类型是错误的：</div><div class="t m0 x5 hf y35c ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="fc12 ws156">@typeassert<span class="ff8 fc0 ls34">(<span class="fca ls0 ws13a">int</span><span class="ls32">,<span class="fca ls0 ws13a">list<span class="fc0">)</span></span></span></span></span></div><div class="t m0 x5 hf y35d ff7 fs5 fc5 sc0 ls0 ws139">... <span class="fca">def <span class="ff8 fcb ws13a">bar<span class="fc0 ws4">(x, items</span><span class="fc6">=<span class="fca">None<span class="fc0">):</span></span></span></span></span></div><div class="t m0 x5 hf y35e ff7 fs5 fc5 sc0 ls0 ws1a2">... <span class="fca ws157">if <span class="ff8 fc0 ws15f">items </span><span class="ws160">is <span class="ff8 ws13a">None<span class="fc0">:</span></span></span></span></div><div class="t m0 x5 hf y35f ff7 fs5 fc5 sc0 ls0 ws1a3">... <span class="ff8 fc0 ws15f">items <span class="fc6 ls33">=</span>[]</span></div><div class="t m0 x5 hf y360 ff7 fs5 fc5 sc0 ls0 ws1a2">... <span class="ff8 fc0 ws13a">items<span class="fc6 ls34">.</span>append(x)</span></div><div class="t m0 x5 hf y361 ff7 fs5 fc5 sc0 ls0 ws1a2">... <span class="fca ws146">return <span class="ff8 fc0">items</span></span></div><div class="t m0 x5 hf y362 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws13a">bar(<span class="fc7 ls34">2</span>)</span></div><div class="t m0 x5 hf y363 ff8 fs5 fc8 sc0 ls0">[2]</div><div class="t m0 x5 hf y364 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws13a">bar(<span class="fc7 ls34">2</span>,<span class="fc7 ls34">3</span>)</span></div><div class="t m0 x5 hf y365 ff8 fs5 fce sc0 ls0 ws4">Traceback (most recent call last):</div><div class="t m0 x15 hf y366 ff8 fs5 fc0 sc0 ls0 ws13c">File <span class="fc9 ws13a">&quot;&lt;stdin&gt;&quot;</span><span class="ws145">, line <span class="fc7 ls34">1</span><span class="ls32">,</span><span class="ff7 fca ws160">in </span><span class="fc6 ws13a">&lt;<span class="fc0">module</span>&gt;</span></span></div><div class="t m0 x15 hf y367 ff8 fs5 fc0 sc0 ls0 ws13c">File <span class="fc9 ws13a">&quot;contract.py&quot;</span><span class="ws13b">, line <span class="fc7 ws13a">33</span><span class="ls32">,</span><span class="ff7 fca ws157">in </span>wrapper</span></div><div class="t m0 x5 hf y368 ff8 fs5 fc2 sc0 ls0 ws13a">TypeError<span class="fc0 ws4">: Argument items must be &lt;class <span class="ff9 ls34">&apos;</span><span class="ws13a">list<span class="ff9 ls34">&apos;</span>&gt;</span></span></div><div class="t m0 x5 hf y369 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws13a">bar(<span class="fc7 ls34">4</span><span class="ws13b">, [</span><span class="fc7">1</span><span class="ls33">,<span class="fc7 ls34">2</span><span class="ls32">,<span class="fc7 ls34">3</span></span></span>])</span></div><div class="t m0 x5 hf y36a ff8 fs5 fc8 sc0 ls0 ws4">[1, 2, 3, 4]</div><div class="t m0 x5 hf y36b ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h9 y2208 ff1 fs3 fc0 sc0 ls3a ws153">最后一点是关于适用装饰器参数和函数注解之间的争论。例如，为什么不像下面这</div><div class="t m0 x5 h9 y2209 ff1 fs3 fc0 sc0 ls0">样写一个装饰器来查找函数中的注解呢？</div><div class="t m0 x5 h10 y220a ff7 fs5 fc12 sc0 ls0">@typeassert</div><div class="t m0 x5 hf y6a ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">spam<span class="fc0">(x:<span class="fca">int</span><span class="ws4">, y, z:<span class="fca ws158">int <span class="fc6 ls33">=</span></span></span><span class="fc7">42</span>):</span></span></div><div class="t m0 x15 hf y220b ff7 fs5 fca sc0 ls0 ws156">print<span class="ff8 fc0">(x,y,z)</span></div><div class="t m0 x0 h9 y220c ff1 fs3 fc0 sc0 ls3a ws153">一个可能的原因是如果使用了函数参数注解，那么就被限制了。如果注解被用来做</div><div class="t m0 x5 h9 y220d ff1 fs3 fc0 sc0 ls17 wsbe4">类型检查就不能做其他事情了。而且 <span class="ff6 ls0 wsbe5">@typeassert </span><span class="wsf6">不能再用于使用注解<span class="_ _1"></span>做其他事情的</span></div><div class="t m0 x5 h9 y220e ff1 fs3 fc0 sc0 ls0">函数了。而使用上面的装饰器参数灵活性大多了，也更加通用。</div><div class="t m0 x0 h7 y220f ff1 fs3 fc0 sc0 ls0 wsbe6">可以在 <span class="ff4 ws9be">PEP 362 </span><span class="wsbe7">以<span class="_ _6"></span>及 <span class="ff6 ws47b">inspect </span><span class="ls3d wsbe8">模块中找到更多关于函数参数对象的信息。在 </span><span class="ff4">9.16</span></span></div><div class="t m0 x5 h9 y1e50 ff1 fs3 fc0 sc0 ls0">小节还有另外一个例子。</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 ws9da">11.7.<span class="_ _5"> </span>9.7 <span class="ff1 ws243">利用装饰器强制函数上的类型检查 </span>315</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
