<div id="pf10c" class="pf w0 h0" data-page-no="10c"><div class="pc pc10c w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg10c.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 he y137 ff2 fs2 fc4 sc0 ls0 wsadf">10.11.3 <span class="ff1">讨论</span></div><div class="t m0 x0 h9 y236 ff1 fs3 fc0 sc0 ls0 wsaf6">当你需要使用大量很小的数据结构类的时候，<span class="_ _c"></span>相比手工一个个定义 <span class="ff6 wsaf7">init<span class="_ _e"> </span>() </span>方法</div><div class="t m0 x5 h9 y237 ff1 fs3 fc0 sc0 ls0">而已，使用这种方式可以大大简化代码。</div><div class="t m0 x0 h9 ya58 ff1 fs3 fc0 sc0 ls14 wsaf8">在上面的实现中我们使用了 <span class="ff6 ls0 ws33a">setattr() </span><span class="ws174">函数类设置属性值<span class="_ _1"></span>，你可能不想用这种方</span></div><div class="t m0 x5 h9 y278 ff1 fs3 fc0 sc0 ls0">式，而是想直接更新实例字典，就像下面这样：</div><div class="t m0 x5 hf y1cef ff7 fs5 fca sc0 ls0 ws16a">class <span class="fcc ws156">Structure<span class="ff8 fc0">:</span></span></div><div class="t m0 x15 h11 y1b44 ffa fs5 fcd sc0 ls0 ws4"># Class variable that specifies expected fields</div><div class="t m0 x15 hf y1cf0 ff8 fs5 fc0 sc0 ls0 ws13a">_fields<span class="fc6 ls32">=</span>[]</div><div class="t m0 x15 hf y1cf1 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">__init__<span class="fc0">(<span class="fca">self</span><span class="ls33">,</span><span class="fc6">*</span>args):</span></span></div><div class="t m0 x16 hf y1cf2 ff7 fs5 fca sc0 ls0 ws157">if <span class="ff8 ws13a">len<span class="fc0 ws145">(args) <span class="fc6 ws159">!= </span></span>len<span class="fc0">(</span>self<span class="fc6 ls34">.</span><span class="fc0">_fields):</span></span></div><div class="t m0 x17 hf y1cf3 ff7 fs5 fca sc0 ls0 ws16a">raise <span class="ff8 ws13a">TypeError<span class="fc0">(<span class="ff9 fc9 ls34">&apos;</span><span class="fc9 ws4">Expected {} arguments<span class="ff9 ls34">&apos;<span class="ff8 fc6">.</span></span></span>format(</span>len<span class="fc0 ls34">(</span>self<span class="fc6">.<span class="fc0">_fields)))</span></span></span></div><div class="t m0 x16 h11 y1cf4 ffa fs5 fcd sc0 ls0 ws4"># Set the arguments (alternate)</div><div class="t m0 x16 hf y1cf5 ff8 fs5 fca sc0 ls0 ws13a">self<span class="fc6">.<span class="fc0">__dict__</span><span class="ls34">.</span><span class="fc0">update(</span></span>zip<span class="fc0 ls34">(</span>self<span class="fc6 ls34">.</span><span class="fc0">_fields,args))</span></div><div class="t m0 x0 h9 y1cf6 ff1 fs3 fc0 sc0 ls56 ws1fa">尽管这也可以正常工作<span class="_ _c"></span>，但是当定义子类的时候问题就来了<span class="_ _1"></span>。当一个子类定义了<span class="_ _1"></span></div><div class="t m0 x32 h7 y1cf7 ff6 fs3 fc0 sc0 ls0 wsa03">slots <span class="ff1 ls42 wsaf9">或者通过 </span><span class="ff4 wsa5">prop<span class="_ _6"></span>ert<span class="_ _1"></span>y(<span class="ff1 wsa0">或描<span class="_ _6"></span>述器</span><span class="lsbc">)<span class="ff1 ls42 ws186">来包装某个属性，那么直接访问实例字典就不</span></span></span></div><div class="t m0 x5 h9 y1cf8 ff1 fs3 fc0 sc0 ls0 ws38">起作用了。我们上面使用 <span class="ff6 ws1d1">setattr() </span>会显得更通用些，因为它也适用于子类情况。</div><div class="t m0 x0 h7 y246 ff1 fs3 fc0 sc0 ls51 wsafa">这种方法唯一不好的地方就是对某些 <span class="ff4 ls0 wsafb">IDE </span><span class="ws1c8">而已，在显示帮助函数时可能不太友好。</span></div><div class="t m0 x5 h9 y1cf9 ff1 fs3 fc0 sc0 ls0">比如：</div><div class="t m0 x5 hf y1cfa ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0">help(Stock)</span></div><div class="t m0 x5 hf y1cfb ff8 fs5 fc8 sc0 ls0 ws4">Help on class Stock in module __main__:</div><div class="t m0 x5 hf y1cfc ff8 fs5 fc8 sc0 ls0 ws4">class Stock(Structure)</div><div class="t m0 x5 h10 yd29 ff7 fs5 fc5 sc0 ls0">...</div><div class="t m0 x5 hf y1cfd ffd fs5 fc8 sc0 lsbd">|<span class="ff8 ls0 ws4">Methods inherited from Structure:</span></div><div class="t m0 x5 h14 y1cfe ffd fs5 fc8 sc0 ls0">|</div><div class="t m0 x5 hf y1cff ffd fs5 fc8 sc0 lsbd">|<span class="ff8 ls0 ws13b">__init__(self, *args, **kwargs)</span></div><div class="t m0 x5 h14 y1d00 ffd fs5 fc8 sc0 ls0">|</div><div class="t m0 x5 h10 y1d01 ff7 fs5 fc5 sc0 ls0">...</div><div class="t m0 x5 hf y1d02 ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h7 y1243 ff1 fs3 fc0 sc0 ls0 wsc">可以参考 <span class="ff4 wsca">9.16 </span><span class="ws9d6">小节来强制在 <span class="ff6 ws308">init<span class="_ _e"> </span>() </span>方法中指定参数的类型签名。</span></div><div class="t m0 x5 hd y1962 ff2 fs4 fc4 sc0 ls0 ws211">10.12<span class="_ _e"> </span>8.12 <span class="ff1">定义接口或者抽象基类</span></div><div class="t m0 x5 he y1d03 ff2 fs2 fc4 sc0 ls0 wsadf">10.12.1 <span class="ff1">问题</span></div><div class="t m0 x0 h9 y1d04 ff1 fs3 fc0 sc0 ls3a ws153">你想定义一个接口或抽象类，并且通过执行类型检查来确保子类实现了某些特定的</div><div class="t m0 x5 h9 y1d05 ff1 fs3 fc0 sc0 ls0">方法</div><div class="t m0 x5 he y1d06 ff2 fs2 fc4 sc0 ls0 wsadf">10.12.2 <span class="ff1">解决方案</span></div><div class="t m0 x0 h9 y1d07 ff1 fs3 fc0 sc0 ls0 wsc">使用 <span class="ff6 ws15e">abc </span>模块可以很轻松的定义抽象基类：</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 wsae0">10.12.<span class="_ _5"> </span>8.12 <span class="ff1 wsaf4">定义接口或者抽象基类 </span>259</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
