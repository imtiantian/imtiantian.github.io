<div id="pf1f0" class="pf w0 h0" data-page-no="1f0"><div class="pc pc1f0 w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg1f0.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x18 hf y1ab ff7 fs5 fca sc0 ls0 ws156">print<span class="ff8 fc0 ls34">(<span class="ff9 fc9">&apos;<span class="ff8 ls0 ws13a">Got:<span class="ff9 ws13b">&apos;</span><span class="fc0 ws4">, item)</span></span></span></span></div><div class="t m0 x16 h11 y1ad ffa fs5 fcd sc0 ls0 ws4"># Sleep briefly to avoid 100% CPU</div><div class="t m0 x16 hf y1ae ff8 fs5 fc0 sc0 ls0 ws13a">time<span class="fc6">.</span>sleep(<span class="fc7">0.01</span>)</div><div class="t m0 x0 h9 y3104 ff1 fs3 fc0 sc0 ls0 wsa0">这样做其实不合理，还<span class="_ _6"></span>会引入其他的性能问题。例<span class="_ _6"></span>如，如果新的数据被加入<span class="_ _6"></span>到一个</div><div class="t m0 x5 h7 y3105 ff1 fs3 fc0 sc0 ls0 ws11b5">队列中，至少要花 <span class="ff4 ws143">10 </span><span class="ls35 ws144">毫秒才能<span class="_ _6"></span>被发现。如果你之前的轮询还要去轮询其他对象，比如</span></div><div class="t m0 x5 h9 y3106 ff1 fs3 fc0 sc0 ls0 wsa0">网<span class="_ _6"></span>络套<span class="_ _6"></span>接<span class="_ _6"></span>字<span class="_ _6"></span>那<span class="_ _6"></span>还<span class="_ _6"></span>会有<span class="_ _6"></span>更<span class="_ _6"></span>多<span class="_ _6"></span>问<span class="_ _6"></span>题。<span class="_ _6"></span>例如，<span class="_ _6"></span>如<span class="_ _6"></span>果<span class="_ _6"></span>你<span class="_ _6"></span>想<span class="_ _6"></span>同<span class="_ _6"></span>时轮<span class="_ _6"></span>询<span class="_ _6"></span>套<span class="_ _6"></span>接<span class="_ _6"></span>字<span class="_ _6"></span>和队<span class="_ _6"></span>列，<span class="_ _6"></span>你<span class="_ _6"></span>可<span class="_ _6"></span>能<span class="_ _6"></span>要像</div><div class="t m0 x5 h9 y3107 ff1 fs3 fc0 sc0 ls0">下面这样使用：</div><div class="t m0 x5 h10 y3108 ff7 fs5 fca sc0 ls0 ws146">import <span class="fcc">select</span></div><div class="t m0 x5 hf y3109 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">event_loop<span class="fc0 ws4">(sockets, queues):</span></span></div><div class="t m0 x15 hf y12dd ff7 fs5 fca sc0 ls0 ws16a">while <span class="ff8 ws13a">True<span class="fc0">:</span></span></div><div class="t m0 x16 h11 y310a ffa fs5 fcd sc0 ls0 ws4"># polling with a timeout</div><div class="t m0 x16 hf y310b ff8 fs5 fc0 sc0 ls0 ws13b">can_read, _, _ <span class="fc6 ls32">=</span><span class="ws13a">select<span class="fc6">.</span><span class="ws4">select(sockets, [], [], </span><span class="fc7">0.01</span>)</span></div><div class="t m0 x16 hf y310c ff7 fs5 fca sc0 ls0 ws139">for <span class="ff8 fc0 ls32">r</span><span class="ws157">in <span class="ff8 fc0">can_read:</span></span></div><div class="t m0 x17 hf y310d ff8 fs5 fc0 sc0 ls0">handle_read(r)</div><div class="t m0 x16 hf y310e ff7 fs5 fca sc0 ls0 ws139">for <span class="ff8 fc0 ls32">q</span><span class="ws157">in <span class="ff8 fc0">queues:</span></span></div><div class="t m0 x17 hf y310f ff7 fs5 fca sc0 ls0 ws157">if not <span class="ff8 fc0 ls34">q<span class="fc6 ls0 ws13a">.<span class="fc0">empty():</span></span></span></div><div class="t m0 x18 hf y3110 ff8 fs5 fc0 sc0 ls0 ws161">item <span class="fc6 ls33">=</span><span class="ws13a">q<span class="fc6 ls34">.</span>get()</span></div><div class="t m0 x18 hf y3111 ff7 fs5 fca sc0 ls0 ws156">print<span class="ff8 fc0 ls34">(<span class="ff9 fc9">&apos;<span class="ff8 ls0 ws13a">Got:<span class="ff9 ws13b">&apos;</span><span class="fc0 ws4">, item)</span></span></span></span></div><div class="t m0 x0 h9 ya5 ff1 fs3 fc0 sc0 ls6d ws2a0">这个方案通过将队列和套接字等同对待来解决了大部分的问题<span class="_ _8"></span>。一个单独的<span class="_ _8"></span></div><div class="t m0 x5 h9 y3112 ff6 fs3 fc0 sc0 ls0 ws11b6">select() <span class="ff1 ls1bd wsd48">调用可被同时用来轮询<span class="_ _8"></span>。使用超时或其他基于时间的机制来执行周期性<span class="_ _d"></span></span></div><div class="t m0 x5 h9 y3113 ff1 fs3 fc0 sc0 ls18 ws110">检查并没有必要。甚至，如果数据被加入到一个队列<span class="_ _1"></span>，消费者几乎可以实时的被通知。</div><div class="t m0 x5 h7 y3114 ff1 fs3 fc0 sc0 ls0 ws14">尽管会有一点点底层的 <span class="ff4 ws10d6">I/O </span>损耗，使用它通常会获得更好的响应时间并简化编程。</div><div class="t m0 x5 hd y3115 ff2 fs4 fc4 sc0 ls0 wsd91">14.14<span class="_ _e"> </span>12.14 <span class="ff1 ls7c">在</span><span class="ws11b7">Unix <span class="ff1">系统上面启动守护进程</span></span></div><div class="t m0 x5 he y3116 ff2 fs2 fc4 sc0 ls0 wsadf">14.14.1 <span class="ff1">问题</span></div><div class="t m0 x0 h7 y3117 ff1 fs3 fc0 sc0 ls0 ws38">你想编写一个作为一个在 <span class="ff4 ws30">Unix </span><span class="ws14">或类 <span class="ff4 ws11b8">Unix </span>系统上面运行的守护进程运行的程序。</span></div><div class="t m0 x5 he y3118 ff2 fs2 fc4 sc0 ls0 wsadf">14.14.2 <span class="ff1">解决方案</span></div><div class="t m0 x0 h9 y3119 ff1 fs3 fc0 sc0 ls3a ws153">创建一个正确的守护进程需要一个精确的系统调用序列以及对于细节的控制。下面</div><div class="t m0 x5 h9 y311a ff1 fs3 fc0 sc0 ls0">的代码展示了怎样定义一个守护进程，可以启动后很容易的停止它。</div><div class="t m0 x5 h11 y311b ffa fs5 fcd sc0 ls0 ws4">#!/usr/bin/env python3</div><div class="t m0 x5 h11 y311c ffa fs5 fcd sc0 ls0 ws4"># daemon.py</div><div class="t m0 x5 h10 y311d ff7 fs5 fca sc0 ls0 ws146">import <span class="fcc">os</span></div><div class="t m0 x5 h10 y311e ff7 fs5 fca sc0 ls0 ws146">import <span class="fcc">sys</span></div><div class="t m0 x5 h10 y1483 ff7 fs5 fca sc0 ls0 ws146">import <span class="fcc">atexit</span></div><div class="t m0 x5 h10 y311f ff7 fs5 fca sc0 ls0 ws146">import <span class="fcc">signal</span></div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 wsd97">14.14.<span class="_ _36"> </span>12.14 <span class="ff1 ls7f">在</span><span class="ws11b9">Unix <span class="ff1 ws11ba">系统上面启动守护进程 </span>487</span></div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
