<div id="pf1bf" class="pf w0 h0" data-page-no="1bf"><div class="pc pc1bf w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg1bf.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 h9 y2a ff1 fs3 fc0 sc0 ls0">它们中任何一个产生事件的。在循环中一次处理一个事件，并不需要其他的并发机制。</div><div class="t m0 x0 h7 y76 ff1 fs3 fc0 sc0 ls0 ws103d">事<span class="_ _6"></span>件驱<span class="_ _6"></span>动 <span class="ff4 ws39b">I/<span class="_ _6"></span>O </span><span class="ls40 ws180">的缺点是没有真正的同步机制。如果任何事件处理器方法阻塞或执<span class="_ _c"></span></span></div><div class="t m0 x5 h9 y8dd ff1 fs3 fc0 sc0 ls13 wse5">行一个耗时计算<span class="_ _1"></span>，它会阻塞所有的处理进程。调用那些并不是事件驱动风格的库函数<span class="_ _c"></span></div><div class="t m0 x5 h9 y99 ff1 fs3 fc0 sc0 ls0">也会有问题，同样要是某些库函数调用会阻塞，那么也会导致整个事件循环停止。</div><div class="t m0 x0 h9 y2f ff1 fs3 fc0 sc0 ls0 wsa0">对于<span class="_ _6"></span>阻<span class="_ _6"></span>塞或<span class="_ _6"></span>耗<span class="_ _6"></span>时<span class="_ _6"></span>计算<span class="_ _6"></span>的<span class="_ _6"></span>问题<span class="_ _6"></span>可<span class="_ _6"></span>以通<span class="_ _6"></span>过<span class="_ _6"></span>将事<span class="_ _6"></span>件<span class="_ _6"></span>发送<span class="_ _6"></span>个<span class="_ _6"></span>其<span class="_ _6"></span>他单<span class="_ _6"></span>独<span class="_ _6"></span>的现<span class="_ _6"></span>场<span class="_ _6"></span>或进<span class="_ _6"></span>程<span class="_ _6"></span>来处<span class="_ _6"></span>理。</div><div class="t m0 x5 h9 y30 ff1 fs3 fc0 sc0 ls13 wse5">不过<span class="_ _1"></span>，在事件循环中引入多线程和多进程是比较棘手的，下面的例子演示了如何使用<span class="_ _c"></span></div><div class="t m0 x5 h9 y31 ff6 fs3 fc0 sc0 ls0 ws59a">concurrent.futures <span class="ff1">模块来实现：</span></div><div class="t m0 x5 hf y22e1 ff7 fs5 fca sc0 ls0 ws15a">from <span class="fcc wscf2">concurrent.futures </span><span class="ws1ff">import <span class="ff8 fc0">ThreadPoolExecutor</span></span></div><div class="t m0 x5 h10 y22e2 ff7 fs5 fca sc0 ls0 ws146">import <span class="fcc">os</span></div><div class="t m0 x5 hf y22e4 ff7 fs5 fca sc0 ls0 ws16a">class <span class="fcc ws156">ThreadPoolHandler<span class="ff8 fc0">(EventHandler):</span></span></div><div class="t m0 x15 hf y22e5 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">__init__<span class="fc0">(<span class="fca">self</span><span class="ws4">, nworkers):</span></span></span></div><div class="t m0 x16 hf y22e6 ff7 fs5 fca sc0 ls0 ws157">if <span class="ff8 fc0 ws13a">os<span class="fc6 ls34">.</span><span class="ws13c">name <span class="fc6 ws159">== <span class="ff9 fc9 ls34">&apos;</span></span></span><span class="fc9">posix<span class="ff9 ls34">&apos;</span></span>:</span></div><div class="t m0 x17 hf y22e7 ff8 fs5 fca sc0 ls0 ws13a">self<span class="fc6">.<span class="fc0 ws23c">signal_done_sock, </span></span>self<span class="fc6 ls34">.</span><span class="fc0 ws16e">done_sock <span class="fc6 ls33">=</span><span class="ws13a">socket<span class="fc6 ls34">.</span>socketpair()</span></span></div><div class="t m0 x16 hf y22e8 ff7 fs5 fca sc0 ls0 ws156">else<span class="ff8 fc0">:</span></div><div class="t m0 x17 hf y2cb4 ff8 fs5 fc0 sc0 ls0 ws145">server <span class="fc6 ls32">=</span><span class="ws13a">socket<span class="fc6">.</span>socket(socket<span class="fc6 ls34">.</span><span class="ws13b">AF_INET, socket<span class="fc6 ls34">.</span>SOCK_STREAM)</span></span></div><div class="t m0 x17 hf y2cb5 ff8 fs5 fc0 sc0 ls0 ws13a">server<span class="fc6 ls34">.</span>bind((<span class="ff9 fc9 ls34">&apos;</span><span class="fc9">127.0.0.1<span class="ff9 ls34">&apos;</span></span><span class="ls33">,</span><span class="fc7">0</span>))</div><div class="t m0 x17 hf y2d13 ff8 fs5 fc0 sc0 ls0 ws13a">server<span class="fc6 ls34">.</span>listen(<span class="fc7 ls34">1</span>)</div><div class="t m0 x17 hf y2d14 ff8 fs5 fca sc0 ls0 ws13a">self<span class="fc6">.<span class="fc0 ws227">signal_done_sock </span><span class="ls32">=</span><span class="fc0">socket</span>.<span class="fc0">socket(socket</span>.<span class="fc0">AF_INET,</span></span></div><div class="t m0 x3f hf y2d15 ff8 fs5 fc0 sc0 ls0 ws13a">socket<span class="fc6">.</span>SOCK_STREAM)</div><div class="t m0 x17 hf y2d16 ff8 fs5 fca sc0 ls0 ws13a">self<span class="fc6">.<span class="fc0">signal_done_sock</span><span class="ls34">.</span><span class="fc0">connect(server</span><span class="ls34">.</span><span class="fc0">getsockname())</span></span></div><div class="t m0 x17 hf y2d17 ff8 fs5 fca sc0 ls0 ws13a">self<span class="fc6">.<span class="fc0 ws4">done_sock, _ </span><span class="ls32">=</span><span class="fc0">server</span>.<span class="fc0">accept()</span></span></div><div class="t m0 x17 hf y2d18 ff8 fs5 fc0 sc0 ls0 ws13a">server<span class="fc6 ls34">.</span>close()</div><div class="t m0 x16 hf y2d19 ff8 fs5 fca sc0 ls0 ws13a">self<span class="fc6">.<span class="fc0 ws155">pending </span><span class="ls33">=</span><span class="fc0">[]</span></span></div><div class="t m0 x16 hf y2d1a ff8 fs5 fca sc0 ls0 ws13a">self<span class="fc6">.<span class="fc0 ws13c">pool </span><span class="ls33">=</span><span class="fc0">ThreadPoolExecutor(nworkers)</span></span></div><div class="t m0 x15 hf y2d1b ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">fileno<span class="fc0 ls34">(</span><span class="fca">self<span class="fc0">):</span></span></span></div><div class="t m0 x16 hf y2cbf ff7 fs5 fca sc0 ls0 ws146">return <span class="ff8 ws13a">self<span class="fc6 ls34">.</span><span class="fc0">done_sock<span class="fc6 ls34">.</span>fileno()</span></span></div><div class="t m0 x15 h11 y2d1c ffa fs5 fcd sc0 ls0 ws4"># Callback that executes when the thread is done</div><div class="t m0 x15 hf y2d1d ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">_complete<span class="fc0 ls34">(</span><span class="fca">self<span class="fc0 ws13b">, callback, r):</span></span></span></div><div class="t m0 x16 hf y2d1e ff8 fs5 fca sc0 ls0 ws13a">self<span class="fc6">.<span class="fc0">pending</span>.<span class="fc0 ws4">append((callback, r</span><span class="ls34">.</span><span class="fc0">result()))</span></span></div><div class="t m0 x16 hf y2d1f ff8 fs5 fca sc0 ls0 ws13a">self<span class="fc6">.<span class="fc0">signal_done_sock</span><span class="ls34">.</span><span class="fc0">send(b<span class="ff9 fc9 ls34">&apos;<span class="ff8">x</span><span class="ls0 ws13b">&apos;</span></span>)</span></span></div><div class="t m0 x15 h11 y2d20 ffa fs5 fcd sc0 ls0 ws4"># Run a function in a thread pool</div><div class="t m0 x15 hf y2d21 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">run<span class="fc0 ls34">(</span><span class="fca">self<span class="fc0 ws13b">, func, args<span class="fc6 ls34">=</span><span class="ws4">(), kwargs<span class="fc6 ls34">=</span><span class="ws13a">{},<span class="fc6 ls34">*</span>,callback):</span></span></span></span></span></div><div class="t m0 x16 hf y2d22 ff8 fs5 fc0 sc0 ls32">r<span class="fc6 ls33">=<span class="fca ls0 ws13a">self<span class="fc6">.<span class="fc0">pool</span><span class="ls34">.</span></span></span></span><span class="ls0 ws150">submit(func, <span class="fc6 ls34">*</span><span class="ws458">args, <span class="fc6 ws13a">**</span>kwargs)</span></span></div><div class="t m0 x16 hf y2d23 ff8 fs5 fc0 sc0 ls34">r<span class="fc6 ls0 ws13a">.<span class="fc0">add_done_callback(<span class="ff7 fca ws146">lambda </span><span class="ws15c">r: </span><span class="fca">self</span></span>.</span><span class="ls0 ws4">_complete(callback, r))</span></div><div class="t m0 x15 hf y2d24 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">wants_to_receive<span class="fc0 ls34">(</span><span class="fca">self<span class="fc0">):</span></span></span></div><div class="t m0 x16 hf y13fc ff7 fs5 fca sc0 ls0 ws146">return <span class="ff8">True</span></div><div class="t m0 x15 h11 y2d25 ffa fs5 fcd sc0 ls0 ws4"># Run callback functions of completed work</div><div class="t m0 x15 hf y2d26 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">handle_receive<span class="fc0 ls34">(</span><span class="fca">self<span class="fc0">):</span></span></span></div><div class="t m0 x16 h11 y2d27 ffa fs5 fcd sc0 ls0 ws4"># Invoke all pending callback functions</div><div class="t m0 x16 hf y2d28 ff7 fs5 fca sc0 ls0 ws139">for <span class="ff8 fc0 ws13b">callback, result </span><span class="ws157">in <span class="ff8 ws13a">self<span class="fc6 ls34">.</span><span class="fc0">pending:</span></span></span></div><div class="t m0 x17 hf y2d29 ff8 fs5 fc0 sc0 ls0">callback(result)</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 wsd97">13.12.<span class="_ _36"> </span>11.12 <span class="ff1 ws36c">理解事件驱动的 </span><span class="ws102f">IO 438</span></div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
