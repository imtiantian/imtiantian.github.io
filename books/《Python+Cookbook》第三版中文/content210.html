<div id="pfd2" class="pf w0 h0" data-page-no="d2"><div class="pc pcd2 w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bgd2.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x17 h11 y181 ffa fs5 fcd sc0 ls0 ws4"># further recomputation of this step</div><div class="t m0 x17 hf y182 ff8 fs5 fca sc0 ls0 ws13a">setattr<span class="fc0 ws2a3">(instance, </span>self<span class="fc6">.<span class="fc0 ws4">name, result)</span></span></div><div class="t m0 x17 hf y183 ff7 fs5 fca sc0 ls0 ws146">return <span class="ff8 fc0">result</span></div><div class="t m0 x5 hf y185 ff7 fs5 fca sc0 ls0 ws16a">class <span class="fcc ws156">StructureMeta<span class="ff8 fc0 ls34">(</span></span><span class="ff8 ws13a">type<span class="fc0">):</span></span></div><div class="t m0 x15 h15 y186 ffb fs5 fc9 sc0 ls0">&apos;&apos;&apos;</div><div class="t m0 x15 h11 y187 ffa fs5 fc9 sc0 ls0 ws4">Metaclass that automatically creates StructField descriptors</div><div class="t m0 x15 h15 y188 ffb fs5 fc9 sc0 ls0">&apos;&apos;&apos;</div><div class="t m0 x15 hf y98e ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">__init__<span class="fc0">(<span class="fca">self</span><span class="ws4">, clsname, bases, clsdict):</span></span></span></div><div class="t m0 x16 hf y98f ff8 fs5 fc0 sc0 ls0 ws145">fields <span class="fc6 ls32">=</span><span class="fca ws13a">getattr</span><span class="ls34">(</span><span class="fca ws13a">self</span><span class="ls33">,</span><span class="ff9 fc9 ws13b">&apos;<span class="ff8 ws13a">_fields_</span><span class="ls34">&apos;</span></span><span class="ws13b">, [])</span></div><div class="t m0 x16 hf y990 ff8 fs5 fc0 sc0 ls0 ws2a3">byte_order <span class="fc6 ls32">=</span><span class="ff9 fc9 ws13b">&apos;&apos;</span></div><div class="t m0 x16 hf y991 ff8 fs5 fc0 sc0 ls0 ws145">offset <span class="fc6 ls32">=</span><span class="fc7">0</span></div><div class="t m0 x16 hf y992 ff7 fs5 fca sc0 ls0 ws139">for <span class="ff8 fc0 ws13b">format, fieldname </span><span class="ws157">in <span class="ff8 fc0">fields:</span></span></div><div class="t m0 x17 hf y993 ff7 fs5 fca sc0 ls0 ws157">if <span class="ff8 ws13a">isinstance<span class="fc0 ws4">(format, StructureMeta):</span></span></div><div class="t m0 x18 hf ya70 ff8 fs5 fca sc0 ls0 ws13a">setattr<span class="fc0">(</span>self<span class="fc0 ws4">, fieldname,</span></div><div class="t m0 x24 hf y994 ff8 fs5 fc0 sc0 ls0 ws4">NestedStruct(fieldname, format, offset))</div><div class="t m0 x18 hf y995 ff8 fs5 fc0 sc0 ls0 ws145">offset <span class="fc6 ws1a1">+= </span><span class="ws13a">format<span class="fc6 ls34">.</span>struct_size</span></div><div class="t m0 x17 hf y996 ff7 fs5 fca sc0 ls0 ws156">else<span class="ff8 fc0">:</span></div><div class="t m0 x18 hf y997 ff7 fs5 fca sc0 ls0 ws157">if <span class="ff8 fc0 ws13a">format<span class="fc6 ls34">.</span>startswith((<span class="ff9 fc9 ws13b">&apos;<span class="ff8 ls34">&lt;<span class="ff9">&apos;</span><span class="fc0">,</span></span>&apos;<span class="ff8 ls34">&gt;<span class="ff9">&apos;</span></span></span>,<span class="ff9 fc9 ls34">&apos;<span class="ff8">!</span>&apos;</span>,<span class="ff9 fc9 ls34">&apos;<span class="ff8">@</span>&apos;</span>)):</span></div><div class="t m0 x29 hf y998 ff8 fs5 fc0 sc0 ls0 ws2a3">byte_order <span class="fc6 ls32">=</span><span class="ws13a">format[<span class="fc7 ls34">0</span>]</span></div><div class="t m0 x29 hf ya71 ff8 fs5 fc0 sc0 ls0 ws145">format <span class="fc6 ls32">=</span><span class="ws13a">format[<span class="fc7 ls34">1</span>:]</span></div><div class="t m0 x18 hf y999 ff8 fs5 fc0 sc0 ls0 ws145">format <span class="fc6 ls32">=</span><span class="ws2a3">byte_order <span class="fc6 ls33">+</span>format</span></div><div class="t m0 x18 hf y99a ff8 fs5 fca sc0 ls0 ws13a">setattr<span class="fc0">(</span>self<span class="fc0 ws4">, fieldname, StructField(format, offset))</span></div><div class="t m0 x18 hf y99b ff8 fs5 fc0 sc0 ls0 ws145">offset <span class="fc6 ws1a1">+= </span><span class="ws13a">struct<span class="fc6 ls34">.</span>calcsize(format)</span></div><div class="t m0 x16 hf y99c ff8 fs5 fca sc0 ls0 ws13a">setattr<span class="fc0 ls34">(</span>self<span class="fc0 ls32">,<span class="ff9 fc9 ls34">&apos;</span></span><span class="fc9">struct_size<span class="ff9 ws13b">&apos;</span><span class="fc0 ws4">, offset)</span></span></div><div class="t m0 x0 h9 y16ef ff1 fs3 fc0 sc0 ls10 wsdf">在这段代码中<span class="_ _1"></span>，<span class="ff6 ls0 ws8dd">NestedStruct </span>描述器被用来叠加另外一个定义在某个内存区域上</div><div class="t m0 x5 h9 y16f0 ff1 fs3 fc0 sc0 ls13 wse5">的结构<span class="_ _1"></span>。它通过将原始内存缓冲进行切片操作后实例化给定的结构类型。由于底层的<span class="_ _c"></span></div><div class="t m0 x5 h9 y16f1 ff1 fs3 fc0 sc0 ls2d ws132">内存缓冲区是通过一个内存视图初始化的，所以这种切片操作不会引发任何的额外的<span class="_ _1"></span></div><div class="t m0 x5 h9 y16f2 ff1 fs3 fc0 sc0 ls1e ws111">内存复制<span class="_ _1"></span>。相反，它仅仅就是之前的内存的一个叠加而已<span class="_ _c"></span>。另外，为了防止重复实例<span class="_ _1"></span></div><div class="t m0 x5 h7 y16f3 ff1 fs3 fc0 sc0 ls0 ws38">化，通过使用和 <span class="ff4 wsca">8.10 </span>小节同样的技术，描述器保存了该实例中的内部结构对象。</div><div class="t m0 x0 h9 y14f ff1 fs3 fc0 sc0 ls0">使用这个新的修正版，你就可以像下面这样编写：</div><div class="t m0 x5 hf y16f4 ff7 fs5 fca sc0 ls0 ws16a">class <span class="fcc ws156">Point<span class="ff8 fc0">(Structure):</span></span></div><div class="t m0 x15 hf y16f5 ff8 fs5 fc0 sc0 ls0 ws1f5">_fields_ <span class="fc6 ls33">=</span>[</div><div class="t m0 x16 hf y16f6 ff8 fs5 fc0 sc0 ls34">(<span class="ff9 fc9 ls0 ws13b">&apos;<span class="ff8 ws13a">&lt;d</span>&apos;</span><span class="ls33">,</span><span class="ff9 fc9">&apos;<span class="ff8 ls0 ws13a">x</span>&apos;</span><span class="ls0">),</span></div><div class="t m0 x16 hf y16f7 ff8 fs5 fc0 sc0 ls34">(<span class="ff9 fc9 ls0 ws13b">&apos;</span><span class="fc9">d<span class="ff9">&apos;</span></span><span class="ls32">,</span><span class="ff9 fc9">&apos;<span class="ff8">y</span><span class="ls0 ws13b">&apos;</span></span><span class="ls0">)</span></div><div class="t m0 x15 hf y16f8 ff8 fs5 fc0 sc0 ls0">]</div><div class="t m0 x5 hf y16f9 ff7 fs5 fca sc0 ls0 ws16a">class <span class="fcc ws156">PolyHeader<span class="ff8 fc0">(Structure):</span></span></div><div class="t m0 x15 hf y16fa ff8 fs5 fc0 sc0 ls0 ws1f5">_fields_ <span class="fc6 ls33">=</span>[</div><div class="t m0 x16 hf y16fb ff8 fs5 fc0 sc0 ls34">(<span class="ff9 fc9 ls0 ws13b">&apos;<span class="ff8 ws13a">&lt;i</span>&apos;</span><span class="ls33">,</span><span class="ff9 fc9">&apos;<span class="ff8 ls0 ws13a">file_code</span>&apos;</span><span class="ls0">),</span></div><div class="t m0 x16 hf y16fc ff8 fs5 fc0 sc0 ls0 ws155">(Point, <span class="ff9 fc9 ws13b">&apos;<span class="ff8 ws13a">min</span>&apos;</span><span class="ws159">), <span class="ffa fcd ws4"># nested struct</span></span></div><div class="t m0 x16 hf y16fd ff8 fs5 fc0 sc0 ls0 ws155">(Point, <span class="ff9 fc9 ws13b">&apos;<span class="ff8 ws13a">max</span>&apos;</span><span class="ws159">), <span class="ffa fcd ws4"># nested struct</span></span></div><div class="t m0 x16 hf y1443 ff8 fs5 fc0 sc0 ls34">(<span class="ff9 fc9 ls0 ws13b">&apos;</span><span class="fc9">i<span class="ff9">&apos;</span></span><span class="ls32">,</span><span class="ff9 fc9">&apos;<span class="ff8 ls0 ws13a">num_polys</span>&apos;</span><span class="ls0">)</span></div><div class="t m0 x15 hf y16fe ff8 fs5 fc0 sc0 ls0">]</div><div class="t m0 x0 h9 y16ff ff1 fs3 fc0 sc0 ls0">令人惊讶的是，它也能按照预期的正常工作，我们实际操作下：</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 ws21d">8.12.<span class="_ _5"> </span>6.12 <span class="ff1 ws6e7">读取嵌套和可变长二进制数据 </span>201</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
