<div id="pf10d" class="pf w0 h0" data-page-no="10d"><div class="pc pc10d w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg10d.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 hf y432 ff7 fs5 fca sc0 ls0 ws15a">from <span class="fcc ws139">abc </span><span class="ws146">import <span class="ff8 fc0 ws13b">ABCMeta, abstractmethod</span></span></div><div class="t m0 x5 hf y434 ff7 fs5 fca sc0 ls0 ws16a">class <span class="fcc ws156">IStream<span class="ff8 fc0 ws13a">(metaclass<span class="fc6">=</span>ABCMeta):</span></span></div><div class="t m0 x15 h10 yde6 ff7 fs5 fc12 sc0 ls0">@abstractmethod</div><div class="t m0 x15 hf y1d08 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">read<span class="fc0">(<span class="fca">self</span><span class="ws4">, maxbytes</span><span class="fc6">=-<span class="fc7 ls34">1</span></span>):</span></span></div><div class="t m0 x16 h10 y1d09 ff7 fs5 fca sc0 ls0">pass</div><div class="t m0 x15 h10 y1d0a ff7 fs5 fc12 sc0 ls0">@abstractmethod</div><div class="t m0 x15 hf y1d0b ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">write<span class="fc0 ls34">(</span><span class="fca">self<span class="fc0 ws4">, data):</span></span></span></div><div class="t m0 x16 h10 y1d0c ff7 fs5 fca sc0 ls0">pass</div><div class="t m0 x0 h9 y1d0d ff1 fs3 fc0 sc0 ls0">抽象类的一个特点是它不能直接被实例化，比如你想像下面这样做是不行的：</div><div class="t m0 x5 hf y19b1 ff8 fs5 fc0 sc0 ls32">a<span class="fc6 ls33">=</span><span class="ls0 ws16e">IStream() <span class="ffa fcd ws4"># TypeError: Can<span class="ffb ls34">&apos;</span>t instantiate abstract class</span></span></div><div class="t m0 x18 h11 y19b2 ffa fs5 fcd sc0 ls0 ws4"># IStream with abstract methods read, write</div><div class="t m0 x0 h9 y1d0e ff1 fs3 fc0 sc0 ls0">抽象类的目的就是让别的类继承它并实现特定的抽象方法：</div><div class="t m0 x5 hf y1d0f ff7 fs5 fca sc0 ls0 ws16a">class <span class="fcc ws156">SocketStream<span class="ff8 fc0">(IStream):</span></span></div><div class="t m0 x15 hf y1d10 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">read<span class="fc0">(<span class="fca">self</span><span class="ws4">, maxbytes</span><span class="fc6">=-<span class="fc7 ls34">1</span></span>):</span></span></div><div class="t m0 x16 h10 y1d11 ff7 fs5 fca sc0 ls0">pass</div><div class="t m0 x15 hf y1d12 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">write<span class="fc0 ls34">(</span><span class="fca">self<span class="fc0 ws4">, data):</span></span></span></div><div class="t m0 x16 h10 y1d13 ff7 fs5 fca sc0 ls0">pass</div><div class="t m0 x0 h9 y1d14 ff1 fs3 fc0 sc0 ls63 ws21f">抽象基类的一个主要用途是在代码中检查某些类是否为特定类型<span class="_ _c"></span>，实现了特定接<span class="_ _1"></span></div><div class="t m0 x5 h9 y1d15 ff1 fs3 fc0 sc0 ls0">口：</div><div class="t m0 x5 hf y1d16 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">serialize<span class="fc0 ws4">(obj, stream):</span></span></div><div class="t m0 x15 hf y1d17 ff7 fs5 fca sc0 ls0 ws157">if not <span class="ff8 ws13a">isinstance<span class="fc0 ws4">(stream, IStream):</span></span></div><div class="t m0 x16 hf y1d18 ff7 fs5 fca sc0 ls0 ws16a">raise <span class="ff8 ws13a">TypeError<span class="fc0">(<span class="ff9 fc9 ls34">&apos;</span><span class="fc9 ws4">Expected an IStream<span class="ff9 ls34">&apos;</span></span>)</span></span></div><div class="t m0 x15 h10 y1d19 ff7 fs5 fca sc0 ls0">pass</div><div class="t m0 x0 h9 y1d1a ff1 fs3 fc0 sc0 ls0">除了继承这种方式外，还可以通过注册方式来让某个类实现抽象基类：</div><div class="t m0 x5 h10 y1aa1 ff7 fs5 fca sc0 ls0 ws146">import <span class="fcc">io</span></div><div class="t m0 x5 h11 y1d1b ffa fs5 fcd sc0 ls0 ws4"># Register the built-in I/O classes as supporting our interface</div><div class="t m0 x5 hf y1d1c ff8 fs5 fc0 sc0 ls0 ws13a">IStream<span class="fc6 ls34">.</span>register(io<span class="fc6 ls34">.</span>IOBase)</div><div class="t m0 x5 h11 y1d1d ffa fs5 fcd sc0 ls0 ws4"># Open a normal file and type check</div><div class="t m0 x5 hf y1d1e ff8 fs5 fc0 sc0 ls32">f<span class="fc6 ls33">=<span class="fca ls0 ws13a">open</span></span><span class="ls34">(<span class="ff9 fc9 ls0 ws13b">&apos;<span class="ff8 ws13a">foo.txt</span><span class="ls34">&apos;</span></span><span class="ls0">)</span></span></div><div class="t m0 x5 hf y1d1f ff8 fs5 fca sc0 ls0 ws13a">isinstance<span class="fc0 ws4">(f, IStream) <span class="ffa fcd ws13b"># Returns True</span></span></div><div class="t m0 x0 h9 y1d20 ff6 fs3 fc0 sc0 ls0 wsafc">@abstractmethod <span class="ff1 ls18 wsafd">还能注解静态方法、类方法和 </span><span class="ws141">properties <span class="ff1 wsa0">。你只<span class="_ _6"></span>需保证<span class="_ _6"></span>这个注</span></span></div><div class="t m0 x5 h9 y1d21 ff1 fs3 fc0 sc0 ls0">解紧靠在函数定义前即可：</div><div class="t m0 x5 hf y1d22 ff7 fs5 fca sc0 ls0 ws16a">class <span class="fcc ls34">A</span><span class="ff8 fc0 ws13a">(metaclass<span class="fc6 ls34">=</span>ABCMeta):</span></div><div class="t m0 x15 h10 y1d23 ff7 fs5 fc12 sc0 ls0">@property</div><div class="t m0 x15 h10 y1d24 ff7 fs5 fc12 sc0 ls0">@abstractmethod</div><div class="t m0 x15 hf y1d25 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">name<span class="fc0">(<span class="fca">self</span>):</span></span></div><div class="t m0 x16 h10 y1d26 ff7 fs5 fca sc0 ls0">pass</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 wsae0">10.12.<span class="_ _5"> </span>8.12 <span class="ff1 wsaf4">定义接口或者抽象基类 </span>260</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
