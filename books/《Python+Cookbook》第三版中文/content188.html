<div id="pfbc" class="pf w0 h0" data-page-no="bc"><div class="pc pcbc w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bgbc.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 h7 y2a ff4 fs3 fc0 sc0 ls0 ws7ed">XML <span class="ff1 ws7ee">元素<span class="_ _6"></span>了。这<span class="_ _6"></span>些<span class="_ _6"></span>函数<span class="_ _6"></span>的参<span class="_ _6"></span>数就<span class="_ _6"></span>是<span class="_ _6"></span>某个<span class="_ _6"></span>指定<span class="_ _6"></span>的<span class="_ _6"></span>标签<span class="_ _6"></span>名，例<span class="_ _6"></span>如 <span class="ff6 ws7ef">channel/item </span><span class="ls134">或</span><span class="ff6">title</span></span></div><div class="t m0 x5 h9 y2b ff1 fs3 fc0 sc0 ls0">。</div><div class="t m0 x0 h9 y8dd ff1 fs3 fc0 sc0 ls56 ws1fa">每次指定某个标签时<span class="_ _c"></span>，你需要遍历整个文档结构<span class="_ _1"></span>。每次搜索操作会从一个起始元<span class="_ _1"></span></div><div class="t m0 x5 h9 y99 ff1 fs3 fc0 sc0 ls1e ws111">素开始进行<span class="_ _1"></span>。同样，每次操作所指定的标签名也是起始元素的相对路径<span class="_ _c"></span>。<span class="_ _6"></span>例如<span class="_ _1"></span>，执行</div><div class="t m0 x5 h9 y9a ff6 fs3 fc0 sc0 ls0 ws7f0">doc.iterfind(&apos;channel/item&apos;) <span class="ff1 ls2b ws7f1">来搜索所有在 </span><span class="ws41c">channel <span class="ff1 ls2b ws419">元素下面的 </span><span class="ws7f2">item <span class="ff1 ws7f3">元素。 </span>doc</span></span></div><div class="t m0 x5 h7 y9b ff1 fs3 fc0 sc0 ls17 ws7f4">代表文档的最顶层 <span class="ff4 ls1b">(</span><span class="ws7f5">也就是第一级的 <span class="ff6 ls0 ws7f6">rss <span class="ff1 wsa0">元素<span class="ff4 ls1b">)</span></span></span><span class="ws7f7">。然后接下来的调用 <span class="ff6 ls0">item.findtext()</span></span></span></div><div class="t m0 x5 h9 y9c ff1 fs3 fc0 sc0 ls0 ws14">会从已找到的 <span class="ff6 ws17a">item </span>元素位置开始搜索。</div><div class="t m0 x0 h9 y32 ff6 fs3 fc0 sc0 ls0 ws18c">ElementTree <span class="ff1 lsd3 ws4b2">模块中的每个元素有一些重要的属性和方法<span class="_ _c"></span>，在解析的时候非常有<span class="_ _1"></span></span></div><div class="t m0 x5 h9 y33 ff1 fs3 fc0 sc0 ls0 ws4f4">用。 <span class="ff6 ws7f8">tag </span><span class="wsa0">属性包含了标签的名字，<span class="ff6 ws7f9">text </span><span class="ws7fa">属性包含了内部的文本，而 <span class="ff6 ws7fb">get() </span>方法能获取</span></span></div><div class="t m0 x5 h9 y34 ff1 fs3 fc0 sc0 ls0">属性值。例如：</div><div class="t m0 x5 hf y1484 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0">doc</span></div><div class="t m0 x5 hf y1485 ff8 fs5 fc8 sc0 ls0 ws4">&lt;xml.etree.ElementTree.ElementTree object at 0x101339510&gt;</div><div class="t m0 x5 hf y1486 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls32">e<span class="fc6 ls33">=</span><span class="ls0 ws13a">doc<span class="fc6 ls34">.</span>find(<span class="ff9 fc9 ls34">&apos;</span><span class="fc9">channel/title<span class="ff9 ws13b">&apos;</span></span>)</span></span></div><div class="t m0 x5 hf y1487 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0">e</span></div><div class="t m0 x5 hf y1488 ff8 fs5 fc8 sc0 ls0 ws16d">&lt;Element <span class="ff9 ws13b">&apos;</span><span class="ws13a">title<span class="ff9 ls32">&apos;</span><span class="ws4">at 0x10135b310&gt;</span></span></div><div class="t m0 x5 hf y2d6 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls34">e<span class="fc6 ls0 ws13a">.<span class="fc0">tag</span></span></span></div><div class="t m0 x5 hf y1489 ff9 fs5 fc8 sc0 ls34">&apos;<span class="ff8 ls0 ws13a">title<span class="ff9">&apos;</span></span></div><div class="t m0 x5 hf y148a ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls34">e<span class="fc6 ls0 ws13a">.<span class="fc0">text</span></span></span></div><div class="t m0 x5 hf y148b ff9 fs5 fc8 sc0 ls34">&apos;<span class="ff8 ls0 ws13b">Planet Python<span class="ff9">&apos;</span></span></div><div class="t m0 x5 hf y148c ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls34">e<span class="fc6 ls0 ws13a">.<span class="fc0">get(</span></span><span class="ff9 fc9">&apos;<span class="ff8 ls0 ws13a">some_attribute</span>&apos;</span><span class="ls0">)</span></span></div><div class="t m0 x5 hf y148d ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h7 y148e ff1 fs3 fc0 sc0 ls0 ws7fc">有<span class="_ _6"></span>一<span class="_ _6"></span>点<span class="_ _6"></span>要<span class="_ _6"></span>强<span class="_ _6"></span>调<span class="_ _6"></span>的<span class="_ _0"></span>是 <span class="ff6 ws7d5">xml.etree.ElementTree </span><span class="ls6c ws632">并不是 </span><span class="ff4 ws7d7">XML </span><span class="ls6c ws29d">解析的唯一方法<span class="_ _c"></span>。对于<span class="_ _1"></span></span></div><div class="t m0 x5 h7 y148f ff1 fs3 fc0 sc0 lsf ws7fd">更高级的应用程序<span class="_ _c"></span>，你需要考虑使用 <span class="ff6 ls0 ws26a">lxml <span class="ff1 ws7fe">。<span class="_ _0"></span>它使<span class="_ _0"></span>用了<span class="_ _0"></span>和 <span class="ff4 ws7ff">Elemen<span class="_ _c"></span>tT<span class="_ _d"></span>ree <span class="ff1 lsf wsdb">同样的编程接<span class="_ _1"></span></span></span></span></span></div><div class="t m0 x5 h7 y1490 ff1 fs3 fc0 sc0 ls30 ws800">口，因此上面的<span class="_ _1"></span>例子同样也适用于 <span class="ff4 ls0 wsa5">lxml</span><span class="ws801">。你只需要将刚开始的 <span class="ff4 ls0 ws802">imp<span class="_ _6"></span>ort <span class="ff1 ws803">语<span class="_ _6"></span>句换<span class="_ _6"></span>成 <span class="ff6">from</span></span></span></span></div><div class="t m0 x5 h7 y1491 ff6 fs3 fc0 sc0 ls0 ws804">lxml.etree import parse<span class="_ _16"> </span><span class="ff1 ws805">就<span class="_ _6"></span>行<span class="_ _6"></span>了。 </span><span class="ws806">lxml <span class="ff1 ls6b ws807">完全遵循 </span><span class="ff4 ws808">XML <span class="ff1 ls6b ws28f">标准，并且速度也非常快<span class="_ _c"></span>，</span></span></span></div><div class="t m0 x5 h7 y1492 ff1 fs3 fc0 sc0 ls0 wsa0">同时还支持验证，<span class="ff4 wsa5">XSL<span class="_ _8"></span>T<span class="ff1 ws14">，和 </span><span class="ws809">XPath <span class="ff1">等特性。</span></span></span></div><div class="t m0 x5 hd y1493 ff2 fs4 fc4 sc0 ls0 ws134">8.4<span class="_ _e"> </span>6.4 <span class="ff1 ws7d2">增量式解析大型 </span><span class="ws7d3">XML <span class="ff1">文件</span></span></div><div class="t m0 x5 he y1494 ff2 fs2 fc4 sc0 ls0 ws135">8.4.1 <span class="ff1">问题</span></div><div class="t m0 x0 h7 y1495 ff1 fs3 fc0 sc0 ls0 ws38">你想使用尽可能少的内存从一个超大的 <span class="ff4 ws64">XML </span>文档中提取数据。</div><div class="t m0 x5 he y1496 ff2 fs2 fc4 sc0 ls0 ws135">8.4.2 <span class="ff1">解决方案</span></div><div class="t m0 x0 h9 y1497 ff1 fs3 fc0 sc0 ls30 ws138">任何时候只要你遇到增量式的数据处理时，第一时间就应该想到迭代器和生成器<span class="_ _c"></span>。</div><div class="t m0 x5 h7 y1498 ff1 fs3 fc0 sc0 ls0 ws14">下面是一个很简单的函数，只使用很少的内存就能增量式的处理一个大型 <span class="ff4 ws61">XML </span>文件：</div><div class="t m0 x5 hf y1499 ff7 fs5 fca sc0 ls0 ws15a">from <span class="fcc ws7d9">xml.etree.ElementTree </span><span class="ws146">import <span class="ff8 fc0">iterparse</span></span></div><div class="t m0 x5 hf y149a ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">parse_and_remove<span class="fc0 ws13b">(filename, path):</span></span></div><div class="t m0 x15 hf y149b ff8 fs5 fc0 sc0 ls0 ws2a3">path_parts <span class="fc6 ls32">=</span><span class="ws13a">path<span class="fc6 ls34">.</span>split(<span class="ff9 fc9 ls34">&apos;<span class="ff8">/</span>&apos;</span>)</span></div><div class="t m0 x15 hf y149c ff8 fs5 fc0 sc0 ls0 ws158">doc <span class="fc6 ls32">=</span><span class="ws4">iterparse(filename, (<span class="ff9 fc9 ws13b">&apos;<span class="ff8 ws13a">start</span><span class="ls34">&apos;</span></span><span class="ls32">,<span class="ff9 fc9 ls34">&apos;</span></span><span class="fc9 ws13a">end<span class="ff9 ls34">&apos;</span></span>))</span></div><div class="t m0 x15 h11 y149d ffa fs5 fcd sc0 ls0 ws4"># Skip the root element</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 ws13e">8.4.<span class="_ _5"> </span>6.4 <span class="ff1 ws36c">增量式解析大型 </span><span class="ws80a">XML <span class="ff1 ws80b">文件 </span>179</span></div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
