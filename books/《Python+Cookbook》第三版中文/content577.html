<div id="pf241" class="pf w0 h0" data-page-no="241"><div class="pc pc241 w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg241.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x19 hf y3746 ff8 fs5 fc0 sc0 ls0">...</div><div class="t m0 x19 hf y3786 ff8 fs5 fc0 sc0 ls0 ws4">/* Build arguments */</div><div class="t m0 x19 hf y3747 ff8 fs5 fc0 sc0 ls0 ws4">args = Py_BuildValue(&quot;(dd)&quot;, x, y);</div><div class="t m0 x19 hf y3748 ff8 fs5 fc0 sc0 ls0 ws4">kwargs = NULL;</div><div class="t m0 x19 hf y374a ff8 fs5 fc0 sc0 ls0 ws4">/* Call the function */</div><div class="t m0 x19 hf y374b ff8 fs5 fc0 sc0 ls0 ws4">result = PyObject_Call(func, args, kwargs);</div><div class="t m0 x19 hf y374c ff8 fs5 fc0 sc0 ls0">Py_DECREF(args);</div><div class="t m0 x19 hf y374d ff8 fs5 fc0 sc0 ls0">Py_XDECREF(kwargs);</div><div class="t m0 x19 hf y374e ff8 fs5 fc0 sc0 ls0">...</div><div class="t m0 x0 h7 yaa2 ff1 fs3 fc0 sc0 ls149 ws1427">如果没有关键字参数<span class="_ _c"></span>，你可以传递 <span class="ff4 ls0 wsa5">NULL</span><span class="ws937">。当你要调用函数时<span class="_ _1"></span>，需要确保使用了<span class="_ _c"></span></span></div><div class="t m0 x5 h9 y3787 ff6 fs3 fc0 sc0 ls0 wsf74">Py DECREF() <span class="ff1 ws1428">或<span class="_ _6"></span>者 </span><span class="ws1429">Py XDECREF() <span class="ff1 ls18 ws110">清理参数。第二个函数相对安全点，因为它允许传递</span></span></div><div class="t m0 x5 h7 y3788 ff4 fs3 fc0 sc0 ls0 wsbe">NULL <span class="ff1 wsa0">指针（直接忽略它）<span class="_ _f"></span>，这也是为什么我们使用它来清理可选的关键字参数。</span></div><div class="t m0 x0 h7 y3789 ff1 fs3 fc0 sc0 ls0 ws142a">调用<span class="_ _6"></span>万 <span class="ff4 ws4c8">Python </span><span class="ws142b">函<span class="_ _6"></span>数<span class="_ _6"></span>之<span class="_ _6"></span>后，你<span class="_ _6"></span>必<span class="_ _6"></span>须<span class="_ _6"></span>检<span class="_ _6"></span>查是<span class="_ _6"></span>否<span class="_ _6"></span>有<span class="_ _6"></span>异<span class="_ _6"></span>常发<span class="_ _6"></span>生。 <span class="ff6 ws27d">PyErr Occurred() </span><span class="wsa0">函<span class="_ _6"></span>数</span></span></div><div class="t m0 x5 h7 y378a ff1 fs3 fc0 sc0 lse ws142c">可被用来做这件事。对对于异常的处理就有点麻烦了，由于是用 <span class="ff4 ls265">C</span><span class="ls0 wsa0">语言写的，<span class="_ _6"></span>你没<span class="_ _6"></span>有</span></div><div class="t m0 x5 h7 y378b ff1 fs3 fc0 sc0 ls26d">像<span class="ff4 ls0 ws108">Python </span><span class="ls0 wsa0">那么的异常机制。因此，你必须要设置一个异常状态码，<span class="_ _1"></span>打印异常信息或其</span></div><div class="t m0 x5 h7 y378c ff1 fs3 fc0 sc0 ls82 ws142d">他相应处理。在这里，我们选择了简单的 <span class="ff6 ls0 ws3f6">abort() </span><span class="wsba3">来处理。另外，传统 <span class="ff4 ls206">C</span><span class="ws2f9">程序员可能</span></span></div><div class="t m0 x5 h9 y378d ff1 fs3 fc0 sc0 ls0">会直接让程序奔溃。</div><div class="t m0 x5 hf y152a ff8 fs5 fc0 sc0 ls0">...</div><div class="t m0 x5 hf y152b ff8 fs5 fc0 sc0 ls0 ws4">/* Check for Python exceptions (if any) */</div><div class="t m0 x5 hf y152c ff8 fs5 fc0 sc0 ls0 ws4">if (PyErr_Occurred()) {</div><div class="t m0 x19 hf y152d ff8 fs5 fc0 sc0 ls0">PyErr_Print();</div><div class="t m0 x19 hf y152e ff8 fs5 fc0 sc0 ls0 ws4">goto fail;</div><div class="t m0 x5 hf y378e ff8 fs5 fc0 sc0 ls0">}</div><div class="t m0 x5 hf y378f ff8 fs5 fc0 sc0 ls0">...</div><div class="t m0 x5 hf y3790 ff8 fs5 fc0 sc0 ls0">fail:</div><div class="t m0 x19 hf y3791 ff8 fs5 fc0 sc0 ls0">PyGILState_Release(state);</div><div class="t m0 x19 hf y830 ff8 fs5 fc0 sc0 ls0">abort();</div><div class="t m0 x0 h7 y3792 ff1 fs3 fc0 sc0 ls0 ws142e">从调用 <span class="ff4 ws453">Python </span><span class="ls18 ws110">函数的返回值中提取信息通常要进行类型检查和提取值。要这样做</span></div><div class="t m0 x5 h7 y31c6 ff1 fs3 fc0 sc0 ls0 ws142f">的<span class="_ _6"></span>话，<span class="_ _6"></span>你<span class="_ _6"></span>必<span class="_ _6"></span>须<span class="_ _6"></span>使<span class="_ _6"></span>用 <span class="ff4 ws1430">Python </span><span class="ws1431">对<span class="_ _6"></span>象<span class="_ _6"></span>层<span class="_ _6"></span>中<span class="_ _6"></span>的<span class="_ _6"></span>函<span class="_ _6"></span>数。<span class="_ _6"></span>在<span class="_ _6"></span>这<span class="_ _6"></span>里<span class="_ _6"></span>我<span class="_ _6"></span>们<span class="_ _6"></span>使<span class="_ _6"></span>用<span class="_ _6"></span>了 <span class="ff6 ws470">PyFloat Check() </span>和</span></div><div class="t m0 x5 h7 y3793 ff6 fs3 fc0 sc0 ls0 ws17c">PyFloat<span class="_ _7"> </span>AsDouble() <span class="ff1 ws14">来检查和提取 <span class="ff4 ws5c">Python </span>浮点数。</span></div><div class="t m0 x0 h7 y3794 ff1 fs3 fc0 sc0 ls82 ws32c">最后一个问题是对于 <span class="ff4 ls0 wsd77">Python <span class="ff1 ws1432">全局锁的管<span class="_ _6"></span>理。在 </span><span class="ls206">C</span></span><span class="ws1433">语言中访问 <span class="ff4 ls0 wsd77">Python <span class="ff1 wsa0">的时候，你</span></span></span></div><div class="t m0 x5 h7 y3795 ff1 fs3 fc0 sc0 ls0 ws64d">需要<span class="_ _6"></span>确保 <span class="ff4 ws113a">GIL </span><span class="wsa0">被正<span class="_ _6"></span>确的获<span class="_ _6"></span>取和<span class="_ _6"></span>释放了。<span class="_ _6"></span>不然<span class="_ _6"></span>的话，可<span class="_ _6"></span>能会<span class="_ _6"></span>导致解<span class="_ _6"></span>释器返<span class="_ _6"></span>回错<span class="_ _6"></span>误数据<span class="_ _6"></span>或</span></div><div class="t m0 x5 h9 y3796 ff1 fs3 fc0 sc0 ls0 ws1434">者<span class="_ _6"></span>直<span class="_ _6"></span>接<span class="_ _0"></span>奔<span class="_ _6"></span>溃。<span class="_ _6"></span>调<span class="_ _6"></span>用 <span class="ff6 ws1435">PyGILState Ensure()<span class="_ _18"> </span></span><span class="ls1a5">和</span><span class="ff6 ws65d">PyGILState Release() </span><span class="wsa0">可<span class="_ _0"></span>以<span class="_ _6"></span>确<span class="_ _6"></span>保<span class="_ _6"></span>一<span class="_ _0"></span>切<span class="_ _6"></span>都</span></div><div class="t m0 x5 h9 y17fe ff1 fs3 fc0 sc0 ls0">能正常。</div><div class="t m0 x5 hf y3797 ff8 fs5 fc0 sc0 ls0 ws4">double call_func(PyObject *func, double x, double y) {</div><div class="t m0 x19 hf y3798 ff8 fs5 fc0 sc0 ls0">...</div><div class="t m0 x19 hf y3799 ff8 fs5 fc0 sc0 ls0 ws4">double retval;</div><div class="t m0 x19 hf y379a ff8 fs5 fc0 sc0 ls0 ws4">/* Make sure we own the GIL */</div><div class="t m0 x19 hf y379b ff8 fs5 fc0 sc0 ls0 ws4">PyGILState_STATE state = PyGILState_Ensure();</div><div class="t m0 x19 hf y379c ff8 fs5 fc0 sc0 ls0">...</div><div class="t m0 x19 hf y379d ff8 fs5 fc0 sc0 ls0 ws4">/* Code that uses Python C API functions */</div><div class="t m0 x19 hf y379e ff8 fs5 fc0 sc0 ls0">...</div><div class="t m0 x19 hf y379f ff8 fs5 fc0 sc0 ls0 ws4">/* Restore previous GIL state and return */</div><div class="t m0 x19 hf y37a0 ff8 fs5 fc0 sc0 ls0">PyGILState_Release(state);</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 ws21d">17.6.<span class="_ _36"> </span>15.6 <span class="ff1 ls81">从</span><span class="ls260">C</span><span class="ff1 ws7da">语言中调用 </span><span class="wscda">Python <span class="ff1 ws42c">代码 </span>568</span></div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
