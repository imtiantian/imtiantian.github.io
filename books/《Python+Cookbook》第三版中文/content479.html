<div id="pf1df" class="pf w0 h0" data-page-no="1df"><div class="pc pc1df w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg1df.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x0 h7 y20bf ff1 fs3 fc0 sc0 ls6b ws113f">如果你使用其他工具访问 <span class="ff4 ls207">C</span><span class="ws1140">语言，比如对于 <span class="ff4 ls0 ws1141">Cython </span><span class="ls124">的<span class="ff4 ls0 ws1142">ct<span class="_ _c"></span>yp<span class="_ _6"></span>es <span class="ff1 wsa0">库，<span class="_ _6"></span>你不<span class="_ _6"></span>需<span class="_ _6"></span>要做<span class="_ _6"></span>任</span></span></span></span></div><div class="t m0 x5 h7 y2a19 ff1 fs3 fc0 sc0 ls0 wsa0">何事。例如，<span class="ff4 ws1143">ct<span class="_ _1"></span>yp<span class="_ _6"></span>es <span class="ff1 ws63">在调用 </span><span class="ls8">C</span><span class="ff1 wsc">时会自动释放 </span><span class="wsa5">GIL<span class="ff1">。</span></span></span></div><div class="t m0 x5 he y2fc6 ff2 fs2 fc4 sc0 ls0 ws212">14.9.3 <span class="ff1">讨论</span></div><div class="t m0 x0 h7 y2fc7 ff1 fs3 fc0 sc0 ls22 ws1144">许多程序员在面对线程性能问题的时候，马上就会怪罪 <span class="ff4 ls0 wsa5">GIL</span><span class="ws119">，什么都是它的问题<span class="_ _c"></span>。</span></div><div class="t m0 x5 h9 y2fc8 ff1 fs3 fc0 sc0 ls13 wse5">其实这样子太不厚道也太天真了点<span class="_ _1"></span>。作为一个真实的例子，在多线程的网络编程中神<span class="_ _c"></span></div><div class="t m0 x5 h7 y2fc9 ff1 fs3 fc0 sc0 ls0 ws2c8">秘的 <span class="ff6 ws2cb">stalls </span><span class="wsde5">可能是因为其他原因比如一个 <span class="ff4 ws1145">DNS </span><span class="ws1146">查找延时，而跟 <span class="ff4 ws1147">GIL </span><span class="wsa0">毫无关系。最后</span></span></span></div><div class="t m0 x5 h7 y2fca ff1 fs3 fc0 sc0 ls0 wsd8c">你真的需要先去搞懂你的代码是否真的被 <span class="ff4 ws1148">GIL </span><span class="ws915">影响到。同时还要明白 <span class="ff4 ws1148">GIL </span>大部分都应</span></div><div class="t m0 x5 h7 y2fcb ff1 fs3 fc0 sc0 ls0 ws14">该只关注 <span class="ff4 ws1149">CPU </span>的处理而不是 <span class="ff4">I/O.</span></div><div class="t m0 x0 h9 y2fcc ff1 fs3 fc0 sc0 ls6d ws2a0">如果你准备使用一个处理器池<span class="_ _19"></span>，<span class="_ _6"></span>注意的是这样做涉及到数据序列化和在不同<span class="_ _19"></span></div><div class="t m0 x5 h7 y2fcd ff4 fs3 fc0 sc0 ls0 ws114a">Python <span class="ff1 ws114b">解<span class="_ _0"></span>释<span class="_ _6"></span>器<span class="_ _0"></span>通<span class="_ _6"></span>信。<span class="_ _0"></span>被<span class="_ _0"></span>执<span class="_ _6"></span>行<span class="_ _0"></span>的<span class="_ _6"></span>操<span class="_ _0"></span>作<span class="_ _0"></span>需<span class="_ _6"></span>要<span class="_ _0"></span>放<span class="_ _0"></span>在<span class="_ _6"></span>一<span class="_ _0"></span>个<span class="_ _6"></span>通<span class="_ _0"></span>过 </span><span class="ws114c">def <span class="ff1 ws114d">语<span class="_ _0"></span>句<span class="_ _6"></span>定<span class="_ _0"></span>义<span class="_ _6"></span>的 </span><span class="ws114e">Python <span class="ff1 wsa0">函<span class="_ _0"></span>数</span></span></span></div><div class="t m0 x5 h7 y2fce ff1 fs3 fc0 sc0 ls0 ws114f">中，<span class="_ _6"></span>不<span class="_ _6"></span>能<span class="_ _0"></span>是 <span class="ff4 wsa5">lam<span class="_ _c"></span>b<span class="_ _6"></span>da<span class="ff1 ls24 ws1150">、闭包可调用实例等，并且函数参数和返回值必须要兼容 </span>pic<span class="_ _c"></span>kle<span class="ff1">。</span></span></div><div class="t m0 x5 h9 y14bc ff1 fs3 fc0 sc0 ls0">同样，要执行的任务量必须足够大以弥补额外的通宵开销。</div><div class="t m0 x0 h9 y2fcf ff1 fs3 fc0 sc0 ls3a ws153">另外一个难点是当混合使用线程和进程池的时候会让你很头疼。如果你要同时使用</div><div class="t m0 x5 h9 y2fd0 ff1 fs3 fc0 sc0 ls0 wsa0">两<span class="_ _6"></span>者，最<span class="_ _6"></span>好<span class="_ _6"></span>在<span class="_ _6"></span>程<span class="_ _6"></span>序<span class="_ _6"></span>启动<span class="_ _6"></span>时，<span class="_ _6"></span>创<span class="_ _6"></span>建<span class="_ _6"></span>任<span class="_ _6"></span>何线<span class="_ _6"></span>程<span class="_ _6"></span>之<span class="_ _6"></span>前<span class="_ _6"></span>先<span class="_ _6"></span>创<span class="_ _6"></span>建一<span class="_ _6"></span>个<span class="_ _6"></span>单<span class="_ _6"></span>例<span class="_ _6"></span>的<span class="_ _6"></span>进程<span class="_ _6"></span>池。<span class="_ _6"></span>然<span class="_ _6"></span>后<span class="_ _6"></span>线<span class="_ _6"></span>程使</div><div class="t m0 x5 h9 y2fd1 ff1 fs3 fc0 sc0 ls0">用同样的进程池来进行它们的计算密集型工作。</div><div class="t m0 x0 h7 y2fd2 ff4 fs3 fc0 sc0 ls208">C<span class="ff1 ls2c ws1151">扩展最重要的特征是它们和 </span><span class="ls0 ws1152">Python </span><span class="ff1 ls2c ws12f">解释器是保持独立的。也就是说，如果你准<span class="_ _1"></span></span></div><div class="t m0 x5 h7 y2fd3 ff1 fs3 fc0 sc0 ls0 ws43c">备将 <span class="ff4 ws4e5">Python </span><span class="ls42 ws1153">中的任务分配到 <span class="ff4 ls108">C</span><span class="ws1154">中去执行，你需要确保 <span class="ff4 ls209">C</span><span class="ws1155">代码的操作跟 </span></span></span><span class="ff4 ws4e5">Python </span><span class="wsa0">保持</span></div><div class="t m0 x5 h7 y2c7c ff1 fs3 fc0 sc0 ls0 ws925">独立，这就意味着不要使用 <span class="ff4 ws1cf">Python </span><span class="ls1f ws1156">数据结构以及不要调用 </span><span class="ff4 ws1cf">Python </span><span class="ls10e">的</span><span class="ff4 ws122">C API</span><span class="wsa0">。另外<span class="_ _6"></span>一</span></div><div class="t m0 x5 h7 y2fd4 ff1 fs3 fc0 sc0 ls1f ws85d">个就是你要确保 <span class="ff4 ls20a">C</span><span class="ws949">扩展所做的工作是足够的，值得你这样做。也就是说 <span class="ff4 ls20a">C</span><span class="ws113">扩展担负起</span></span></div><div class="t m0 x5 h9 y344 ff1 fs3 fc0 sc0 ls0">了大量的计算任务，而不是少数几个计算。</div><div class="t m0 x0 h7 y2fd5 ff1 fs3 fc0 sc0 ls2d ws1157">这些解决 <span class="ff4 ls0 ws1158">GIL <span class="ff1 wsa0">的<span class="_ _6"></span>方案<span class="_ _6"></span>并<span class="_ _6"></span>不<span class="_ _6"></span>能适<span class="_ _6"></span>用<span class="_ _6"></span>于<span class="_ _6"></span>所<span class="_ _6"></span>有问<span class="_ _6"></span>题。<span class="_ _6"></span>例<span class="_ _6"></span>如，<span class="_ _6"></span>某些<span class="_ _6"></span>类<span class="_ _6"></span>型<span class="_ _6"></span>的<span class="_ _6"></span>应用<span class="_ _6"></span>程<span class="_ _6"></span>序<span class="_ _6"></span>如<span class="_ _6"></span>果被</span></span></div><div class="t m0 x5 h7 y2fd6 ff1 fs3 fc0 sc0 ls0 ws1159">分解为多个进程处理的话并不能很好的工作，也不能将它的部分代码改成 <span class="ff4 ls20b">C</span>语言执行。</div><div class="t m0 x5 h9 y214b ff1 fs3 fc0 sc0 ls1e ws111">对于这些应用程序<span class="_ _1"></span>，你就要自己需求解决方案了（<span class="_ _1"></span>比如多进程访问共享内存区<span class="_ _1"></span>，多解</div><div class="t m0 x5 h7 y2a6 ff1 fs3 fc0 sc0 ls0 ws115a">析器运行于同一个进程等）<span class="_ _f"></span>。或者，你还可以考虑下其他的解释器实现，比如 <span class="ff4 wsa5">PyPy</span>。</div><div class="t m0 x0 h7 y2e3 ff1 fs3 fc0 sc0 ls0 ws38">了解更多关于在 <span class="ff4 ls8">C</span>扩展中释放 <span class="ff4 wsa5">GIL</span><span class="ws14">，请参考 <span class="ff4 ws1d0">15.7 </span><span class="ls4">和</span><span class="ff4 ws608">15.10 </span>小节。</span></div><div class="t m0 x5 hd y2fd7 ff2 fs4 fc4 sc0 ls0 wsd91">14.10<span class="_ _e"> </span>12.10 <span class="ff1 ws165">定义一个 </span><span class="ws115b">A<span class="_ _c"></span>cto<span class="_ _c"></span>r <span class="ff1">任务</span></span></div><div class="t m0 x5 he y2fd8 ff2 fs2 fc4 sc0 ls0 wsadf">14.10.1 <span class="ff1">问题</span></div><div class="t m0 x0 h7 y2fd9 ff1 fs3 fc0 sc0 ls0 ws38">你想定义跟 <span class="ff4 wsb61">actor </span><span class="wsa0">模式中类似“<span class="ff4 wsa5">actors</span>”角色的任务</span></div><div class="t m0 x5 he y2fda ff2 fs2 fc4 sc0 ls0 wsadf">14.10.2 <span class="ff1">解决方案</span></div><div class="t m0 x0 h7 y2fdb ff4 fs3 fc0 sc0 ls0 ws115c">actore <span class="ff1 wsa0">模式是一种<span class="_ _6"></span>最古老的也是<span class="_ _6"></span>最简单的并行<span class="_ _6"></span>和分布式计算<span class="_ _6"></span>解决方案。事实<span class="_ _6"></span>上，它</span></div><div class="t m0 x5 h7 y1163 ff1 fs3 fc0 sc0 ls0 ws115d">天生的简单性是它如此受欢迎的重要原因之一。简单来讲，<span class="_ _c"></span>一个 <span class="ff4 ws115e">actor </span>就是一个并发执</div><div class="t m0 x5 h9 y2fdc ff1 fs3 fc0 sc0 ls0 wsa0">行<span class="_ _6"></span>的任<span class="_ _6"></span>务，<span class="_ _6"></span>只<span class="_ _6"></span>是<span class="_ _6"></span>简<span class="_ _6"></span>单的<span class="_ _6"></span>执<span class="_ _6"></span>行<span class="_ _6"></span>发<span class="_ _6"></span>送<span class="_ _6"></span>给它<span class="_ _6"></span>的<span class="_ _6"></span>消<span class="_ _6"></span>息<span class="_ _6"></span>任<span class="_ _6"></span>务。<span class="_ _6"></span>响应<span class="_ _6"></span>这<span class="_ _6"></span>些<span class="_ _6"></span>消<span class="_ _6"></span>息<span class="_ _6"></span>时，它<span class="_ _6"></span>可<span class="_ _6"></span>能<span class="_ _6"></span>还<span class="_ _6"></span>会<span class="_ _6"></span>给其</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 wsd97">14.10.<span class="_ _36"> </span>12.10 <span class="ff1 ws16b">定义一个 </span><span class="ws115f">Acto<span class="_ _c"></span>r <span class="ff1 ws1160">任务 </span>470</span></div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
