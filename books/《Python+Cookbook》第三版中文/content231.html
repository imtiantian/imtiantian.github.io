<div id="pfe7" class="pf w0 h0" data-page-no="e7"><div class="pc pce7 w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bge7.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 h7 y2a ff1 fs3 fc0 sc0 ls0 ws38">可以在 <span class="ff4 ws985">op<span class="_ _6"></span>en() </span>方法中使用。</div><div class="t m0 x0 h9 y76 ff1 fs3 fc0 sc0 ls3a ws153">使用一个内部函数或者闭包的方案通常会更优雅一些。简单来讲，一个闭包就是一</div><div class="t m0 x5 h9 y8dd ff1 fs3 fc0 sc0 ls13 wse5">个函数<span class="_ _1"></span>，只不过在函数内部带上了一个额外的变量环境。闭包关键特点就是它会记住<span class="_ _c"></span></div><div class="t m0 x5 h9 y99 ff1 fs3 fc0 sc0 ls36 ws14a">自己被定义时的环境<span class="_ _1"></span>。因此<span class="_ _1"></span>，在我们的解决方案中<span class="_ _1"></span>，<span class="ff6 ls0 ws83c">opener() </span><span class="ws986">函数记住了 <span class="ff6 ls0">template</span></span></div><div class="t m0 x5 h9 y9a ff1 fs3 fc0 sc0 ls0">参数的值，并在接下来的调用中使用它。</div><div class="t m0 x0 h9 y30 ff1 fs3 fc0 sc0 ls3a ws153">任何时候只要你碰到需要给某个函数增加额外的状态信息的问题，都可以考虑使用</div><div class="t m0 x5 h9 y31 ff1 fs3 fc0 sc0 ls0">闭包。相比将你的函数转换成一个类而言，闭包通常是一种更加简洁和优雅的方案。</div><div class="t m0 x5 hd y192e ff2 fs4 fc4 sc0 ls0 ws211">9.10<span class="_ _e"> </span>7.10 <span class="ff1">带额外状态信息的回调函数</span></div><div class="t m0 x5 he y192f ff2 fs2 fc4 sc0 ls0 ws212">9.10.1 <span class="ff1">问题</span></div><div class="t m0 x0 h7 y1930 ff1 fs3 fc0 sc0 lse ws987">你的代码中需要依赖到回调函数的使用 <span class="ff4 ls1b">(</span><span class="wsd8">比如事件处理器、等待后台任务完成后的<span class="_ _1"></span></span></div><div class="t m0 x5 h7 y1931 ff1 fs3 fc0 sc0 ls0 wsa0">回调等<span class="ff4 wsa5">)</span>，并且你还需要让回调函数拥有额外的状态值，以便在它的内部使用到。</div><div class="t m0 x5 he y1932 ff2 fs2 fc4 sc0 ls0 ws212">9.10.2 <span class="ff1">解决方案</span></div><div class="t m0 x0 h9 y1933 ff1 fs3 fc0 sc0 ls68 ws23f">这一小节主要讨论的是那些出现在很多函数库和框架中的回调函数的使用—<span class="_ _8"></span>—特别</div><div class="t m0 x5 h9 yf5b ff1 fs3 fc0 sc0 ls13 wse5">是跟异步处理有关的<span class="_ _1"></span>。为了演示与测试，我们先定义如下一个需要调用回调函数的函<span class="_ _c"></span></div><div class="t m0 x5 h9 y1934 ff1 fs3 fc0 sc0 ls0">数：</div><div class="t m0 x5 hf y1935 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">apply_async<span class="fc0 ws13b">(func, args, <span class="fc6 ls34">*</span><span class="ws4">, callback):</span></span></span></div><div class="t m0 x15 h11 y1936 ffa fs5 fcd sc0 ls0 ws4"># Compute the result</div><div class="t m0 x15 hf y1937 ff8 fs5 fc0 sc0 ls0 ws145">result <span class="fc6 ls32">=</span><span class="ws13a">func(<span class="fc6 ls34">*</span>args)</span></div><div class="t m0 x15 h11 y1938 ffa fs5 fcd sc0 ls0 ws4"># Invoke the callback with the result</div><div class="t m0 x15 hf y1939 ff8 fs5 fc0 sc0 ls0">callback(result)</div><div class="t m0 x0 h9 y193a ff1 fs3 fc0 sc0 ls0 wsa0">实际上，这段代码可以<span class="_ _6"></span>做任何更高级的处理，包<span class="_ _6"></span>括线程、进程和定时器，但<span class="_ _6"></span>是这些</div><div class="t m0 x5 h9 y193b ff1 fs3 fc0 sc0 ls13 wse5">都不是我们要关心的<span class="_ _1"></span>。我们仅仅只需要关注回调函数的调用。下面是一个演示怎样使<span class="_ _c"></span></div><div class="t m0 x5 h9 y193c ff1 fs3 fc0 sc0 ls0">用上述代码的例子：</div><div class="t m0 x5 hf y193d ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="fca">def <span class="ff8 fcb ws13a">print_result<span class="fc0">(result):</span></span></span></div><div class="t m0 x5 hf y193e ff7 fs5 fc5 sc0 ls0 ws1a2">... <span class="fca ws156">print<span class="ff8 fc0 ls34">(<span class="ff9 fc9">&apos;<span class="ff8 ls0 ws13a">Got:</span>&apos;</span><span class="ls0 ws13b">, result)</span></span></span></div><div class="t m0 x5 h10 y193f ff7 fs5 fc5 sc0 ls0">...</div><div class="t m0 x5 hf y1940 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="fca">def <span class="ff8 fcb ws13a">add<span class="fc0 ws4">(x, y):</span></span></span></div><div class="t m0 x5 hf y1941 ff7 fs5 fc5 sc0 ls0 ws1a2">... <span class="fca ws146">return <span class="ff8 fc0 ls32">x<span class="fc6 ls33">+</span><span class="ls0">y</span></span></span></div><div class="t m0 x5 h10 y1942 ff7 fs5 fc5 sc0 ls0">...</div><div class="t m0 x5 hf y1943 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws13b">apply_async(add, (<span class="fc7 ls34">2</span><span class="ls32">,<span class="fc7 ls34">3</span></span>), callback<span class="fc6 ls34">=</span>print_result)</span></div><div class="t m0 x5 hf y1944 ff8 fs5 fc8 sc0 ls0 ws4">Got: 5</div><div class="t m0 x5 hf y1499 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws13b">apply_async(add, (<span class="ff9 fc9 ls34">&apos;</span><span class="fc9 ws13a">hello<span class="ff9 ls34">&apos;</span></span><span class="ls33">,</span><span class="ff9 fc9">&apos;<span class="ff8 ws13a">world</span><span class="ls34">&apos;</span></span>), callback<span class="fc6 ws13a">=</span>print_result)</span></div><div class="t m0 x5 hf y1945 ff8 fs5 fc8 sc0 ls0 ws4">Got: helloworld</div><div class="t m0 x5 hf y1946 ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h9 y1947 ff1 fs3 fc0 sc0 ls51 ws988">注意到 <span class="ff6 ls0 ws21c">print<span class="_ _7"> </span>result() <span class="ff1 ws989">函数仅仅只<span class="_ _6"></span>接受一个<span class="_ _6"></span>参数 </span><span class="ws4cc">result <span class="ff1 wsa0">。不能<span class="_ _6"></span>再传入其他<span class="_ _6"></span>信息。</span></span></span></div><div class="t m0 x5 h9 y1948 ff1 fs3 fc0 sc0 ls0">而当你想让回调函数访问其他变量或者特定环境的变量值的时候就会遇到麻烦。</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 ws21d">9.10.<span class="_ _5"> </span>7.10 <span class="ff1 ws98a">带额外状态信息的回调函数 </span>222</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
