<div id="pf18b" class="pf w0 h0" data-page-no="18b"><div class="pc pc18b w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg18b.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 hf y765 ff9 fs5 fc8 sc0 ls34">&apos;<span class="ff8 ls0 ws13a">spam<span class="ff9">&apos;</span></span></div><div class="t m0 x5 hf y766 ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h9 y2856 ff1 fs3 fc0 sc0 ls0 wsdba">模<span class="_ _6"></span>块<span class="_ _6"></span>对<span class="_ _6"></span>象<span class="_ _6"></span>通<span class="_ _6"></span>常<span class="_ _6"></span>有<span class="_ _0"></span>一些<span class="_ _6"></span>期<span class="_ _0"></span>望属<span class="_ _0"></span>性，包<span class="_ _6"></span>括 <span class="ff6 wsdbb">file </span><span class="wsa0">（运<span class="_ _0"></span>行模<span class="_ _6"></span>块<span class="_ _0"></span>加载<span class="_ _0"></span>语句<span class="_ _6"></span>的<span class="_ _0"></span>文件<span class="_ _6"></span>名）<span class="_ _0"></span>和</span></div><div class="t m0 x32 h7 y2857 ff6 fs3 fc0 sc0 ls0 wsbae">package <span class="ff4 ls1b">(</span><span class="ff1 wsa0">包名<span class="ff4 wsa5">)</span>。</span></div><div class="t m0 x0 h9 y2858 ff1 fs3 fc0 sc0 ls0 wsdbc">其次，<span class="_ _c"></span>模块会被解释器缓存起来。<span class="_ _c"></span>模块缓存可以在字典 <span class="ff6 wsdbd">sys.modules </span><span class="wsa0">中被找到。<span class="_ _c"></span>因</span></div><div class="t m0 x5 h9 y2859 ff1 fs3 fc0 sc0 ls0">为有了这个缓存机制，通常可以将缓存和模块的创建通过一个步骤完成：</div><div class="t m0 x5 h10 y20c5 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="fca ws146">import <span class="fcc">sys</span></span></div><div class="t m0 x5 h10 y20c6 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="fca ws146">import <span class="fcc">imp</span></span></div><div class="t m0 x5 hf y20c7 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls32">m<span class="fc6 ls33">=</span><span class="ls0 ws13a">sys<span class="fc6 ls34">.</span>modules<span class="fc6 ls34">.</span>setdefault(<span class="ff9 fc9 ws13b">&apos;</span><span class="fc9">spam<span class="ff9 ls34">&apos;</span></span><span class="ws13b">, imp</span><span class="fc6">.</span>new_module(<span class="ff9 fc9 ls34">&apos;</span><span class="fc9">spam<span class="ff9 ls34">&apos;</span></span>))</span></span></div><div class="t m0 x5 hf y20c8 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0">m</span></div><div class="t m0 x5 hf y20c9 ff8 fs5 fc8 sc0 ls0 ws155">&lt;module <span class="ff9 ls34">&apos;</span><span class="ws13a">spam<span class="ff9 ls34">&apos;</span>&gt;</span></div><div class="t m0 x5 hf y20ca ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h9 y285a ff1 fs3 fc0 sc0 ls0">如果给定模块已经存在那么就会直接获得已经被创建过的模块，例如：</div><div class="t m0 x5 h10 y27d9 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="fca ws146">import <span class="fcc">math</span></span></div><div class="t m0 x5 hf y285b ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls32">m<span class="fc6 ls33">=</span><span class="ls0 ws13a">sys<span class="fc6 ls34">.</span>modules<span class="fc6 ls34">.</span>setdefault(<span class="ff9 fc9 ws13b">&apos;</span><span class="fc9">math<span class="ff9 ls34">&apos;</span></span><span class="ws13b">, imp</span><span class="fc6">.</span>new_module(<span class="ff9 fc9 ls34">&apos;</span><span class="fc9">math<span class="ff9 ls34">&apos;</span></span>))</span></span></div><div class="t m0 x5 hf y285c ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0">m</span></div><div class="t m0 x5 hf y1fbd ff8 fs5 fc8 sc0 ls0 ws155">&lt;module <span class="ff9 ls34">&apos;</span><span class="ws13a">math<span class="ff9 ls33">&apos;</span><span class="ws13c">from <span class="ff9 ws13b">&apos;</span></span>/usr/local/lib/python3.3/lib-dynload/math.so<span class="ff9 ls34">&apos;</span>&gt;</span></div><div class="t m0 x5 hf y285d ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls34">m<span class="fc6 ls0 ws13a">.<span class="fc0">sin(</span></span><span class="fc7">2</span><span class="ls0">)</span></span></div><div class="t m0 x5 hf y1fbe ff8 fs5 fc8 sc0 ls0">0.9092974268256817</div><div class="t m0 x5 hf y285e ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls34">m<span class="fc6 ls0 ws13a">.<span class="fc0">cos(</span></span><span class="fc7">2</span><span class="ls0">)</span></span></div><div class="t m0 x5 hf y285f ff8 fs5 fc8 sc0 ls0">-0.4161468365471424</div><div class="t m0 x5 hf y2860 ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h9 y2861 ff1 fs3 fc0 sc0 lsa8 wsdbe">由于创建模块很简单，很容易编写简单函数比如第一部分的 <span class="ff6 ls0 wsdbf">load module() <span class="ff1 wsa0">函数。</span></span></div><div class="t m0 x5 h9 y2862 ff1 fs3 fc0 sc0 ls13 wse5">这个方案的一个缺点是很难处理复杂情况比如包的导入<span class="_ _1"></span>。为了处理一个包，你要重新<span class="_ _c"></span></div><div class="t m0 x5 h7 y2863 ff1 fs3 fc0 sc0 ls0 ws723">实<span class="_ _6"></span>现普<span class="_ _6"></span>通 <span class="ff4 wsdc0">imp<span class="_ _6"></span>ort </span><span class="ls1e wsdc1">语句的底层逻辑（比如检查目录<span class="_ _c"></span>，查找 <span class="ff4 ls0 wsdc2">init<span class="_ _e"> </span>.py <span class="ff1 wsa0">文件，<span class="_ _6"></span>执<span class="_ _6"></span>行<span class="_ _6"></span>那<span class="_ _6"></span>些文</span></span></span></div><div class="t m0 x5 h7 y6e1 ff1 fs3 fc0 sc0 ls42 wsdc3">件，设置路径等<span class="_ _1"></span>）<span class="_ _f"></span>。这个复杂性就是为什么最好直接扩展 <span class="ff4 ls0 wsdc4">import </span><span class="ws186">语句而不是自定义函</span></div><div class="t m0 x5 h9 y2864 ff1 fs3 fc0 sc0 ls0">数的一个原因。</div><div class="t m0 x0 h7 y2865 ff1 fs3 fc0 sc0 ls0 ws869">扩展 <span class="ff4 wsdc5">imp<span class="_ _6"></span>ort </span><span class="ls6b ws28f">语句很简单，但是会有很多移动操作。最高层上<span class="_ _c"></span>，导入操作被一个位</span></div><div class="t m0 x5 h7 y2866 ff1 fs3 fc0 sc0 ls13e">于<span class="ff4 ls0 wsdc6">sys.meta<span class="_ _7"> </span>path </span><span class="ls35 ws144">列表中的“元路径”查找器处理。如果你输出它的值，会看到下面这</span></div><div class="t m0 x5 h9 y2867 ff1 fs3 fc0 sc0 ls0">样：</div><div class="t m0 x5 hf y2868 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="fca ws15a">from <span class="fcc ws146">pprint <span class="fca">import <span class="ff8 fc0">pprint</span></span></span></span></div><div class="t m0 x5 hf y2869 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws13a">pprint(sys<span class="fc6 ls34">.</span>meta_path)</span></div><div class="t m0 x5 hf y286a ff8 fs5 fc8 sc0 ls0 ws155">[&lt;class <span class="ff9 ls34">&apos;</span><span class="ws13a">_frozen_importlib.BuiltinImporter<span class="ff9 ws13b">&apos;</span>&gt;,</span></div><div class="t m0 x5 hf y286b ff8 fs5 fc8 sc0 ls0 ws145">&lt;class <span class="ff9 ls34">&apos;</span><span class="ws13a">_frozen_importlib.FrozenImporter<span class="ff9 ls34">&apos;</span>&gt;,</span></div><div class="t m0 x5 hf y286c ff8 fs5 fc8 sc0 ls0 ws145">&lt;class <span class="ff9 ls34">&apos;</span><span class="ws13a">_frozen_importlib.PathFinder<span class="ff9 ls34">&apos;</span>&gt;]</span></div><div class="t m0 x5 hf y286d ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h7 y286e ff1 fs3 fc0 sc0 ls10 wsdc7">当执行一个语句比如 <span class="ff6 ls0 wsdc8">import<span class="_ _23"> </span>fib </span><span class="wsdc9">时，解释器会遍历 <span class="ff4 ls0 wsdca">sys.mata path </span><span class="wsdf">中的查找器对<span class="_ _1"></span></span></span></div><div class="t m0 x5 h9 y286f ff1 fs3 fc0 sc0 ls0 ws38">象，调用它们的 <span class="ff6 ws1f3">find<span class="_ _7"> </span>module() </span>方法定位正确的模块加载器。可以通过实验来看看：</div><div class="t m0 x5 hf y2870 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="fca ws16a">class <span class="fcc ws156">Finder<span class="ff8 fc0">:</span></span></span></div><div class="t m0 x5 hf y2871 ff7 fs5 fc5 sc0 ls0 ws1a2">... <span class="fca ws139">def <span class="ff8 fcb ws13a">find_module<span class="fc0">(<span class="fca">self</span><span class="ws4">, fullname, path):</span></span></span></span></div><div class="t m0 x5 hf y2872 ff7 fs5 fc5 sc0 ls0 ws1a3">... <span class="fca ws156">print<span class="ff8 fc0 ls34">(<span class="ff9 fc9">&apos;<span class="ff8 ls0 ws13b">Looking for</span>&apos;</span><span class="ls0 ws13b">, fullname, path)</span></span></span></div><div class="t m0 x5 hf y2873 ff7 fs5 fc5 sc0 ls0 ws1a3">... <span class="fca ws146">return <span class="ff8">None</span></span></div><div class="t m0 x5 h10 y2874 ff7 fs5 fc5 sc0 ls0">...</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 wsd97">12.11.<span class="_ _5"> </span>10.11 <span class="ff1 wsd98">通过钩子远程加载模块 </span>386</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
