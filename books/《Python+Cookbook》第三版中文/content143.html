<div id="pf8f" class="pf w0 h0" data-page-no="8f"><div class="pc pc8f w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg8f.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 he y137 ff2 fs2 fc4 sc0 ls0 ws212">6.15.3 <span class="ff1">讨论</span></div><div class="t m0 x0 h9 y675 ff6 fs3 fc0 sc0 ls0 ws1e8">heapq.merge <span class="ff1 ls35 ws144">可迭代特性意味着它不会立马读取所有序列。这就意味着你可以在非</span></div><div class="t m0 x5 h9 y676 ff1 fs3 fc0 sc0 ls1e ws111">常长的序列中使用它<span class="_ _1"></span>，而不会有太大的开销<span class="_ _1"></span>。比如，下面是一个例子来演示如何<span class="_ _1"></span>合并</div><div class="t m0 x5 h9 y677 ff1 fs3 fc0 sc0 ls0">两个排序文件：</div><div class="t m0 x5 hf yfc4 ff7 fs5 fca sc0 ls0 ws15a">with <span class="ff8 ws13a">open<span class="fc0">(<span class="ff9 fc9 ls34">&apos;</span><span class="fc9">sorted_file_1<span class="ff9 ls34">&apos;</span></span><span class="ls33">,</span><span class="ff9 fc9 ws13b">&apos;</span><span class="fc9">rt<span class="ff9 ls34">&apos;</span></span><span class="ls32">)</span></span></span><span class="ws157">as <span class="ff8 fc0 ws4">file1, \</span></span></div><div class="t m0 x15 hf yfc5 ff8 fs5 fca sc0 ls0 ws13a">open<span class="fc0 ls34">(</span><span class="ff9 fc9 ws13b">&apos;</span><span class="fc9">sorted_file_2<span class="ff9 ws13b">&apos;</span><span class="fc0 ls33">,</span><span class="ff9 ls34">&apos;</span>rt<span class="ff9 ls34">&apos;</span><span class="fc0 ls32">)</span></span><span class="ff7 ws157">as </span><span class="fc0 ws4">file2, \</span></div><div class="t m0 x15 hf yfc6 ff8 fs5 fca sc0 ls0 ws13a">open<span class="fc0 ls34">(</span><span class="ff9 fc9 ws13b">&apos;</span><span class="fc9">merged_file<span class="ff9 ls34">&apos;</span><span class="fc0 ls32">,</span><span class="ff9 ls34">&apos;</span>wt<span class="ff9 ws13b">&apos;</span><span class="fc0 ls33">)</span></span><span class="ff7 ws157">as </span><span class="fc0">outf:</span></div><div class="t m0 x15 hf yfc7 ff7 fs5 fca sc0 ls0 ws139">for <span class="ff8 fc0 ws161">line </span><span class="ws160">in <span class="ff8 fc0 ws13a">heapq<span class="fc6 ls34">.</span><span class="ws4">merge(file1, file2):</span></span></span></div><div class="t m0 x16 hf yfc8 ff8 fs5 fc0 sc0 ls0 ws13a">outf<span class="fc6">.</span>write(line)</div><div class="t m0 x0 h9 yfc9 ff1 fs3 fc0 sc0 ls0 ws60a">有<span class="_ _6"></span>一<span class="_ _0"></span>点<span class="_ _6"></span>要<span class="_ _0"></span>强<span class="_ _6"></span>调<span class="_ _0"></span>的<span class="_ _6"></span>是 <span class="ff6 ws60b">heapq.merge() </span><span class="lsfa ws60c">需要所有输入序列必须是排过序的<span class="_ _1"></span>。特别的<span class="_ _c"></span>，<span class="_ _c"></span></span></div><div class="t m0 x5 h9 yfca ff1 fs3 fc0 sc0 ls0 wsa0">它并不<span class="_ _6"></span>会预先<span class="_ _6"></span>读取所<span class="_ _6"></span>有数据到<span class="_ _6"></span>堆栈中<span class="_ _6"></span>或者预<span class="_ _6"></span>先排序，<span class="_ _6"></span>也不会<span class="_ _6"></span>对输入<span class="_ _6"></span>做任何的<span class="_ _6"></span>排序检<span class="_ _6"></span>测。</div><div class="t m0 x5 h9 yfcb ff1 fs3 fc0 sc0 ls2d ws132">它仅仅是检查所有序列的开始部分并返回最小的那个，这个过程一直会持续直到所有<span class="_ _1"></span></div><div class="t m0 x5 h9 yfcc ff1 fs3 fc0 sc0 ls0">输入序列中的元素都被遍历完。</div><div class="t m0 x5 hd yfcd ff2 fs4 fc4 sc0 ls0 ws211">6.16<span class="_ _e"> </span>4.16 <span class="ff1 ws357">迭代器代替 </span><span class="ws60d">while <span class="ff1">无限循环</span></span></div><div class="t m0 x5 he yfce ff2 fs2 fc4 sc0 ls0 ws212">6.16.1 <span class="ff1">问题</span></div><div class="t m0 x0 h9 yfcf ff1 fs3 fc0 sc0 ls0 ws60e">你<span class="_ _6"></span>在<span class="_ _6"></span>代<span class="_ _6"></span>码<span class="_ _6"></span>中<span class="_ _6"></span>使<span class="_ _6"></span>用 <span class="ff6 ws177">while </span><span class="ls14 ws174">循环来迭代处理数据<span class="_ _1"></span>，因为它需要调用某个函数或者和一</span></div><div class="t m0 x5 h9 yfd0 ff1 fs3 fc0 sc0 ls0">般迭代模式不同的测试条件。能不能用迭代器来重写这个循环呢？</div><div class="t m0 x5 he yfd1 ff2 fs2 fc4 sc0 ls0 ws212">6.16.2 <span class="ff1">解决方案</span></div><div class="t m0 x0 h7 yfd2 ff1 fs3 fc0 sc0 ls0 ws38">一个常见的 <span class="ff4 ws60f">IO </span>操作程序可能会想下面这样：</div><div class="t m0 x5 hf ydfb ff8 fs5 fc0 sc0 ls0 ws16e">CHUNKSIZE <span class="fc6 ls33">=</span><span class="fc7">8192</span></div><div class="t m0 x5 hf ydfc ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">reader<span class="fc0">(s):</span></span></div><div class="t m0 x15 hf ydfd ff7 fs5 fca sc0 ls0 ws16a">while <span class="ff8 ws13a">True<span class="fc0">:</span></span></div><div class="t m0 x16 hf ydfe ff8 fs5 fc0 sc0 ls0 ws161">data <span class="fc6 ls33">=</span><span class="ls34">s</span><span class="fc6 ws13a">.</span>recv(CHUNKSIZE)</div><div class="t m0 x16 hf ydff ff7 fs5 fca sc0 ls0 ws157">if <span class="ff8 fc0 ws13c">data <span class="fc6 ws159">== </span><span class="ls34">b</span><span class="ff9 fc9 ws13b">&apos;&apos;</span>:</span></div><div class="t m0 x17 h10 yfd3 ff7 fs5 fca sc0 ls0">break</div><div class="t m0 x16 hf ye00 ff8 fs5 fc0 sc0 ls0">process_data(data)</div><div class="t m0 x0 h9 yfd4 ff1 fs3 fc0 sc0 ls0 wsc">这种代码通常可以使用 <span class="ff6 ws25d">iter() </span>来代替，如下所示：</div><div class="t m0 x5 hf yfd5 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">reader2<span class="fc0">(s):</span></span></div><div class="t m0 x15 hf yfd6 ff7 fs5 fca sc0 ls0 ws139">for <span class="ff8 fc0 ws15f">chunk </span><span class="ws157">in <span class="ff8 ws13a">iter<span class="fc0 ls34">(</span></span><span class="ws156">lambda<span class="ff8 fc0 ws4">: s<span class="fc6 ws13a">.</span>recv(CHUNKSIZE), b<span class="ff9 fc9 ls34">&apos;&apos;</span>):</span></span></span></div><div class="t m0 x16 h10 yfd7 ff7 fs5 fca sc0 ls0">pass</div><div class="t m0 x16 h11 yfd8 ffa fs5 fcd sc0 ls0 ws13b"># process_data(data)</div><div class="t m0 x0 h9 yfd9 ff1 fs3 fc0 sc0 ls0">如果你怀疑它到底能不能正常工作，可以试验下一个简单的例子。比如：</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 ws21d">6.16.<span class="_ _5"> </span>4.16 <span class="ff1 ws36c">迭代器代替 </span><span class="ws610">while <span class="ff1 ws611">无限循环 </span>134</span></div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
