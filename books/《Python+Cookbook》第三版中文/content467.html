<div id="pf1d3" class="pf w0 h0" data-page-no="1d3"><div class="pc pc1d3 w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg1d3.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 hf y1ab ff8 fs5 fc0 sc0 ls0 ws13a">t2<span class="fc6 ls34">.</span>start()</div><div class="t m0 x0 h9 y2ecb ff1 fs3 fc0 sc0 ls0">如果你运行这个版本的代码，必定会有一个线程发生崩溃，异常信息可能像这样：</div><div class="t m0 x5 hf y2ecc ff8 fs5 fca sc0 ls0 ws16e">Exception <span class="ff7 ws157">in </span><span class="fc0 ws4">thread Thread<span class="fc6 ls34">-</span><span class="fc7 ws13a">1</span>:</span></div><div class="t m0 x5 hf y2ecd ff8 fs5 fc0 sc0 ls0 ws4">Traceback (most recent call last):</div><div class="t m0 x19 hf y2ece ff8 fs5 fc0 sc0 ls0 ws13c">File <span class="fc9 ws13a">&quot;/usr/local/lib/python3.3/threading.py&quot;</span><span class="ws4">, line <span class="fc7 ws13a">639</span><span class="ls32">,</span><span class="ff7 fca ws157">in </span>_bootstrap_inner</span></div><div class="t m0 x15 hf y2ecf ff8 fs5 fca sc0 ls0 ws13a">self<span class="fc6 ls34">.</span><span class="fc0">run()</span></div><div class="t m0 x19 hf y2ed0 ff8 fs5 fc0 sc0 ls0 ws13c">File <span class="fc9 ws13a">&quot;/usr/local/lib/python3.3/threading.py&quot;</span><span class="ws4">, line <span class="fc7 ws13a">596</span><span class="ls32">,</span><span class="ff7 fca ws157">in </span>run</span></div><div class="t m0 x15 hf y166 ff8 fs5 fca sc0 ls0 ws13a">self<span class="fc6 ls34">.</span><span class="fc0">_target(<span class="fc6 ls34">*</span></span>self<span class="fc6 ls34">.</span><span class="fc0 ws145">_args, </span><span class="fc6">**</span>self<span class="fc6 ls34">.</span><span class="fc0">_kwargs)</span></div><div class="t m0 x19 hf y167 ff8 fs5 fc0 sc0 ls0 ws13c">File <span class="fc9 ws13a">&quot;deadlock.py&quot;</span><span class="ws13b">, line <span class="fc7 ws13a">49</span><span class="ls33">,</span><span class="ff7 fca ws157">in </span>thread_1</span></div><div class="t m0 x15 hf y168 ff7 fs5 fca sc0 ls0 ws15a">with <span class="ff8 fc0">acquire(y_lock):</span></div><div class="t m0 x19 hf y169 ff8 fs5 fc0 sc0 ls0 ws13c">File <span class="fc9 ws13a">&quot;/usr/local/lib/python3.3/contextlib.py&quot;</span><span class="ws145">, line <span class="fc7 ws13a">48</span><span class="ls32">,</span><span class="ff7 fca ws157">in </span>__enter__</span></div><div class="t m0 x15 hf y2ed1 ff7 fs5 fca sc0 ls0 ws146">return <span class="ff8 ws13a">next<span class="fc0 ls34">(</span>self<span class="fc6">.<span class="fc0">gen)</span></span></span></div><div class="t m0 x19 hf y2ed2 ff8 fs5 fc0 sc0 ls0 ws13c">File <span class="fc9 ws13a">&quot;deadlock.py&quot;</span><span class="ws13b">, line <span class="fc7 ws13a">15</span><span class="ls33">,</span><span class="ff7 fca ws157">in </span>acquire</span></div><div class="t m0 x15 hf y114c ff7 fs5 fca sc0 ls0 ws16a">raise <span class="ff8 ws13a">RuntimeError<span class="fc0 ls34">(</span><span class="fc9 ws4">&quot;Lock Order Violation&quot;<span class="fc0">)</span></span></span></div><div class="t m0 x5 hf y114d ff8 fs5 fca sc0 ls0 ws13a">RuntimeError<span class="fc0 ws4">: Lock Order Violation</span></div><div class="t m0 x5 hf y114e ff8 fs5 fc6 sc0 ls0 ws13a">&gt;&gt;&gt;</div><div class="t m0 x0 h9 y2ed3 ff1 fs3 fc0 sc0 ls14 ws10b7">发生崩溃的原因在于<span class="_ _1"></span>，每个线程都记录着自己已经获取到的锁。 <span class="ff6 ls0 ws28c">acquire() <span class="ff1 wsa0">函数</span></span></div><div class="t m0 x5 h9 yae9 ff1 fs3 fc0 sc0 ls13 wse5">会检查之前已经获取的锁列表<span class="_ _1"></span>，由于锁是按照升序排列获取的，所以函数会认为之前<span class="_ _c"></span></div><div class="t m0 x5 h7 y2ed4 ff1 fs3 fc0 sc0 ls0 ws14">已获取的锁的 <span class="ff4 ws10b8">id </span>必定小于新申请到的锁，这时就会触发异常。</div><div class="t m0 x5 he y152e ff2 fs2 fc4 sc0 ls0 ws212">14.5.3 <span class="ff1">讨论</span></div><div class="t m0 x0 h9 y2ed5 ff1 fs3 fc0 sc0 ls3a ws153">死锁是每一个多线程程序都会面临的一个问题（就像它是每一本操作系统课本的共</div><div class="t m0 x5 h9 y2ed6 ff1 fs3 fc0 sc0 ls0 wsa0">同话题一样）<span class="_ _f"></span>。根据经验来讲，尽可能保证每一个线程只能同时保持一个锁，<span class="_ _1"></span>这样程序</div><div class="t m0 x5 h9 y2ed7 ff1 fs3 fc0 sc0 ls0">就不会被死锁问题所困扰。一旦有线程同时申请多个锁，一切就不可预料了。</div><div class="t m0 x0 h9 y2ed8 ff1 fs3 fc0 sc0 ls3a ws153">死锁的检测与恢复是一个几乎没有优雅的解决方案的扩展话题。一个比较常用的死</div><div class="t m0 x5 h9 y2ed9 ff1 fs3 fc0 sc0 ls2d ws132">锁检测与恢复的方案是引入看门狗计数器。当线程正常运行的时候会每隔一段时间重<span class="_ _1"></span></div><div class="t m0 x5 h9 y107f ff1 fs3 fc0 sc0 ls1e ws111">置计数器<span class="_ _1"></span>，在没有发生死锁的情况下，一切都正常进行<span class="_ _c"></span>。一旦发生<span class="_ _6"></span>死锁<span class="_ _1"></span>，由于无法重</div><div class="t m0 x5 h9 y2eda ff1 fs3 fc0 sc0 ls0">置计数器导致定时器超时，这时程序会通过重启自身恢复到正常状态。</div><div class="t m0 x0 h7 y2edb ff1 fs3 fc0 sc0 ls0 ws10b9">避免死锁是另外一种解决死锁问题的方式，<span class="_ _1"></span>在进程获取锁的时候会严格按照对象 <span class="ff4">id</span></div><div class="t m0 x5 h9 y2edc ff1 fs3 fc0 sc0 ls0 wsa0">升<span class="_ _6"></span>序排<span class="_ _6"></span>列<span class="_ _6"></span>获<span class="_ _6"></span>取，<span class="_ _6"></span>经<span class="_ _6"></span>过数<span class="_ _6"></span>学<span class="_ _6"></span>证<span class="_ _6"></span>明，<span class="_ _6"></span>这<span class="_ _6"></span>样保<span class="_ _6"></span>证<span class="_ _6"></span>程<span class="_ _6"></span>序<span class="_ _6"></span>不<span class="_ _6"></span>会<span class="_ _6"></span>进入<span class="_ _6"></span>死<span class="_ _6"></span>锁<span class="_ _6"></span>状<span class="_ _6"></span>态。<span class="_ _6"></span>证明<span class="_ _6"></span>就<span class="_ _6"></span>留<span class="_ _6"></span>给<span class="_ _6"></span>读<span class="_ _6"></span>者作</div><div class="t m0 x5 h7 y2edd ff1 fs3 fc0 sc0 ls2c ws10ba">为练习了。避免死锁的主要思想是，单纯地按照对象 <span class="ff4 ls0 ws10bb">id </span><span class="ws12f">递增的顺序加锁不会产生循环<span class="_ _1"></span></span></div><div class="t m0 x5 h9 y2ede ff1 fs3 fc0 sc0 ls0">依赖，而循环依赖是死锁的一个必要条件，从而避免程序进入死锁状态。</div><div class="t m0 x0 h9 y2edf ff1 fs3 fc0 sc0 ls0 wsa0">下<span class="_ _6"></span>面<span class="_ _6"></span>以<span class="_ _6"></span>一<span class="_ _0"></span>个<span class="_ _6"></span>关<span class="_ _6"></span>于<span class="_ _6"></span>线<span class="_ _6"></span>程<span class="_ _6"></span>死<span class="_ _0"></span>锁<span class="_ _6"></span>的<span class="_ _6"></span>经<span class="_ _6"></span>典<span class="_ _6"></span>问<span class="_ _6"></span>题：<span class="_ _15"></span>“哲<span class="_ _6"></span>学<span class="_ _6"></span>家<span class="_ _6"></span>就<span class="_ _0"></span>餐<span class="_ _6"></span>问<span class="_ _6"></span>题”<span class="_ _31"></span>，<span class="_ _6"></span>作<span class="_ _0"></span>为本<span class="_ _0"></span>节<span class="_ _6"></span>最<span class="_ _6"></span>后<span class="_ _6"></span>一<span class="_ _6"></span>个<span class="_ _6"></span>例</div><div class="t m0 x5 h9 y2ee0 ff1 fs3 fc0 sc0 ls18 ws110">子。题目是这样的：五位哲学家围坐在一张桌子前<span class="_ _1"></span>，每个人面前有一碗饭和一只筷子。</div><div class="t m0 x5 h9 y2ee1 ff1 fs3 fc0 sc0 ls13 wse5">在这里每个哲学家可以看做是一个独立的线程<span class="_ _1"></span>，而每只筷子可以看做是一个锁。每个<span class="_ _c"></span></div><div class="t m0 x5 h9 y1b7d ff1 fs3 fc0 sc0 ls1e ws111">哲学家可以处在静坐<span class="_ _1"></span>、思考、吃饭三种状态中的一个<span class="_ _c"></span>。需要注意的<span class="_ _6"></span>是<span class="_ _1"></span>，每个哲学家吃</div><div class="t m0 x5 h9 y2ee2 ff1 fs3 fc0 sc0 ls1e ws111">饭是需要两只筷子的<span class="_ _1"></span>，这样问题就来了<span class="_ _1"></span>：如果每个哲学家都拿起自己左边的筷子<span class="_ _1"></span>，那</div><div class="t m0 x5 h9 y2a51 ff1 fs3 fc0 sc0 ls16 wsf3">么他们五个都只能拿着一只筷子坐在那儿<span class="_ _c"></span>，直到饿死<span class="_ _1"></span>。此时他们就进入了死锁状态<span class="_ _1"></span>。<span class="_ _c"></span></div><div class="t m0 x5 h9 y2ee3 ff1 fs3 fc0 sc0 ls0">下面是一个简单的使用死锁避免机制解决“哲学家就餐问题”的实现：</div><div class="t m0 x5 h10 y8a1 ff7 fs5 fca sc0 ls0 ws146">import <span class="fcc">threading</span></div><div class="t m0 x5 h11 y8a3 ffa fs5 fcd sc0 ls0 ws4"># The philosopher thread</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 ws21d">14.5.<span class="_ _36"> </span>12.5 <span class="ff1 ws544">防止死锁的加锁机制 </span>458</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
