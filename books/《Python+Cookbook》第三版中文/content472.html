<div id="pf1d8" class="pf w0 h0" data-page-no="1d8"><div class="pc pc1d8 w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg1d8.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 hf y1ab ff8 fs5 fc0 sc0 ls32">y<span class="fc6 ls33">=</span><span class="ls34">b<span class="fc6 ls0 ws13a">.<span class="fc0">result()</span></span></span></div><div class="t m0 x0 h7 y1e76 ff1 fs3 fc0 sc0 ls0 ws10d2">例子<span class="_ _6"></span>中<span class="_ _6"></span>返回<span class="_ _6"></span>的 <span class="ff4 ws10d3">handle </span><span class="wsa0">对<span class="_ _6"></span>象<span class="_ _6"></span>会帮<span class="_ _6"></span>你<span class="_ _6"></span>处理<span class="_ _6"></span>所<span class="_ _6"></span>有的<span class="_ _6"></span>阻<span class="_ _6"></span>塞与<span class="_ _6"></span>协<span class="_ _6"></span>作，然<span class="_ _6"></span>后<span class="_ _6"></span>从<span class="_ _6"></span>工作<span class="_ _6"></span>线<span class="_ _6"></span>程中<span class="_ _6"></span>返<span class="_ _6"></span>回</span></div><div class="t m0 x5 h9 y2f2c ff1 fs3 fc0 sc0 ls18 ws110">数据给你。特别的，<span class="ff6 ls0 ws141">a.result() </span>操作会阻塞进程直到对<span class="_ _1"></span>应的函数执行完成并返回一个</div><div class="t m0 x5 h9 y2f2d ff1 fs3 fc0 sc0 ls0">结果。</div><div class="t m0 x5 he y2f2e ff2 fs2 fc4 sc0 ls0 ws212">14.7.3 <span class="ff1">讨论</span></div><div class="t m0 x0 h9 y2f2f ff1 fs3 fc0 sc0 ls0 wsa0">通常来讲，你应该避免<span class="_ _6"></span>编写线程数量可以无限制<span class="_ _6"></span>增长的程序。例如，看看下<span class="_ _6"></span>面这个</div><div class="t m0 x5 h9 y2f30 ff1 fs3 fc0 sc0 ls0">服务器：</div><div class="t m0 x5 hf y2f31 ff7 fs5 fca sc0 ls0 ws15a">from <span class="fcc ws285">threading </span><span class="ws146">import <span class="ff8 fc0">Thread</span></span></div><div class="t m0 x5 hf y2f32 ff7 fs5 fca sc0 ls0 ws15a">from <span class="fcc ws146">socket <span class="fca">import <span class="ff8 fc0 ws13b">socket, AF_INET, SOCK_STREAM</span></span></span></div><div class="t m0 x5 hf y2f33 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">echo_client<span class="fc0 ws13b">(sock, client_addr):</span></span></div><div class="t m0 x15 h15 y117f ffb fs5 fc9 sc0 ls0">&apos;&apos;&apos;</div><div class="t m0 x15 h11 y2f34 ffa fs5 fc9 sc0 ls0 ws4">Handle a client connection</div><div class="t m0 x15 h15 y2f35 ffb fs5 fc9 sc0 ls0">&apos;&apos;&apos;</div><div class="t m0 x15 hf y2f36 ff7 fs5 fca sc0 ls0 ws156">print<span class="ff8 fc0 ws13a">(<span class="ff9 fc9 ls34">&apos;</span><span class="fc9 ws4">Got connection from<span class="ff9 ls34">&apos;</span></span><span class="ws13b">, client_addr)</span></span></div><div class="t m0 x15 hf y2f37 ff7 fs5 fca sc0 ls0 ws16a">while <span class="ff8 ws13a">True<span class="fc0">:</span></span></div><div class="t m0 x16 hf y2f38 ff8 fs5 fc0 sc0 ls0 ws158">msg <span class="fc6 ls32">=</span><span class="ws13a">sock<span class="fc6 ls34">.</span>recv(<span class="fc7">65536</span>)</span></div><div class="t m0 x16 hf y2f39 ff7 fs5 fca sc0 ls0 ws157">if not <span class="ff8 fc0">msg:</span></div><div class="t m0 x17 h10 ybdd ff7 fs5 fca sc0 ls0">break</div><div class="t m0 x16 hf y2f3a ff8 fs5 fc0 sc0 ls0 ws13a">sock<span class="fc6">.</span>sendall(msg)</div><div class="t m0 x15 hf y2f3b ff7 fs5 fca sc0 ls0 ws156">print<span class="ff8 fc0 ws13a">(<span class="ff9 fc9 ls34">&apos;</span><span class="fc9 ws4">Client closed connection<span class="ff9 ls34">&apos;</span></span>)</span></div><div class="t m0 x15 hf y2f3c ff8 fs5 fc0 sc0 ls0 ws13a">sock<span class="fc6 ls34">.</span>close()</div><div class="t m0 x5 hf y2f3d ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">echo_server<span class="fc0 ws13b">(addr, nworkers):</span></span></div><div class="t m0 x15 h11 y12cd ffa fs5 fcd sc0 ls0 ws4"># Run the server</div><div class="t m0 x15 hf y2f3e ff8 fs5 fc0 sc0 ls0 ws13c">sock <span class="fc6 ls32">=</span><span class="ws4">socket(AF_INET, SOCK_STREAM)</span></div><div class="t m0 x15 hf y2f3f ff8 fs5 fc0 sc0 ls0 ws13a">sock<span class="fc6 ls34">.</span>bind(addr)</div><div class="t m0 x15 hf y2f40 ff8 fs5 fc0 sc0 ls0 ws13a">sock<span class="fc6 ls34">.</span>listen(<span class="fc7">5</span>)</div><div class="t m0 x15 hf y2f41 ff7 fs5 fca sc0 ls0 ws16a">while <span class="ff8 ws13a">True<span class="fc0">:</span></span></div><div class="t m0 x16 hf y2f42 ff8 fs5 fc0 sc0 ls0 ws13b">client_sock, client_addr <span class="fc6 ls32">=</span><span class="ws13a">sock<span class="fc6 ls34">.</span>accept()</span></div><div class="t m0 x16 hf y2f43 ff8 fs5 fc0 sc0 ls32">t<span class="fc6 ls33">=</span><span class="ls0 ws13a">Thread(target<span class="fc6 ls34">=</span><span class="ws13b">echo_client, args<span class="fc6 ls34">=</span><span class="ws4">(client_sock, client_addr))</span></span></span></div><div class="t m0 x16 hf y2f44 ff8 fs5 fc0 sc0 ls34">t<span class="fc6 ls0 ws13a">.</span><span class="ls0 ws145">daemon <span class="fc6 ls33">=</span><span class="fca">True</span></span></div><div class="t m0 x16 hf y2f45 ff8 fs5 fc0 sc0 ls34">t<span class="fc6 ls0 ws13a">.<span class="fc0">start()</span></span></div><div class="t m0 x5 hf y2edf ff8 fs5 fc0 sc0 ls0 ws13a">echo_server((<span class="ff9 fc9 ls34">&apos;&apos;</span><span class="ls34">,</span><span class="fc7">15000</span>))</div><div class="t m0 x0 h9 y2f46 ff1 fs3 fc0 sc0 ls3a ws153">尽管这个也可以工作，但是它不能抵御有人试图通过创建大量线程让你服务器资源</div><div class="t m0 x5 h9 y4a7 ff1 fs3 fc0 sc0 ls13 wse5">枯竭而崩溃的攻击行为<span class="_ _1"></span>。通过使用预先初始化的线程池，你可以设置同时运行线程的<span class="_ _c"></span></div><div class="t m0 x5 h9 y2f47 ff1 fs3 fc0 sc0 ls0">上限数量。</div><div class="t m0 x0 h9 y292 ff1 fs3 fc0 sc0 ls3a ws153">你可能会关心创建大量线程会有什么后果。现代操作系统可以很轻松的创建几千个</div><div class="t m0 x5 h9 y2f48 ff1 fs3 fc0 sc0 ls0 wsa0">线<span class="_ _6"></span>程的<span class="_ _6"></span>线<span class="_ _6"></span>程<span class="_ _6"></span>池。<span class="_ _6"></span>甚<span class="_ _6"></span>至，同<span class="_ _6"></span>时<span class="_ _6"></span>几<span class="_ _6"></span>千<span class="_ _6"></span>个<span class="_ _6"></span>线程<span class="_ _6"></span>等<span class="_ _6"></span>待<span class="_ _6"></span>工<span class="_ _6"></span>作<span class="_ _6"></span>并<span class="_ _6"></span>不会<span class="_ _6"></span>对<span class="_ _6"></span>其<span class="_ _6"></span>他<span class="_ _6"></span>代<span class="_ _6"></span>码产<span class="_ _6"></span>生<span class="_ _6"></span>性<span class="_ _6"></span>能<span class="_ _6"></span>影<span class="_ _6"></span>响。当</div><div class="t m0 x5 h7 y2f49 ff1 fs3 fc0 sc0 ls3a ws10d4">然了，如果所有线程同时被唤醒并立即在 <span class="ff4 ls0 ws10d5">CPU </span><span class="ws153">上执行，那就不同了—<span class="_ _8"></span>—特别是有了全</span></div><div class="t m0 x5 h7 y2f4a ff1 fs3 fc0 sc0 ls0 ws38">局解释器锁 <span class="ff4 wsa5">GIL</span><span class="ws63">。通常，你应该只在 <span class="ff4 ws10d6">I/O </span>处理相关代码中使用线程池。</span></div><div class="t m0 x0 h7 y2f4b ff1 fs3 fc0 sc0 ls19 ws10d7">创建大的线程池的一个可能需要关注的问题是内存的使用<span class="_ _1"></span>。例如，如果你在 <span class="ff4 ls0 wsfa">OS X</span></div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 ws21d">14.7.<span class="_ _36"> </span>12.7 <span class="ff1 ws600">创建一个线程池 </span>463</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
