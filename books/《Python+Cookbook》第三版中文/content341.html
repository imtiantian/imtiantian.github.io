<div id="pf155" class="pf w0 h0" data-page-no="155"><div class="pc pc155 w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg155.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 h9 y2a ff1 fs3 fc0 sc0 ls12 wsc27">管类使用了另外一个字典来定义<span class="_ _1"></span>，在构造最终的 <span class="ff6 ls0 ws224">class <span class="ff1 wsa0">对<span class="_ _6"></span>象的<span class="_ _6"></span>时候，<span class="_ _6"></span>我们<span class="_ _6"></span>仍<span class="_ _6"></span>然需<span class="_ _6"></span>要将</span></span></div><div class="t m0 x5 h9 y2b ff1 fs3 fc0 sc0 ls30 wsc28">这个字典转换为一个正确的 <span class="ff6 ls0 ws24a">dict <span class="ff1 wsc29">实例。<span class="_ _6"></span>通<span class="_ _6"></span>过<span class="_ _6"></span>语句 </span><span class="wsc2a">d<span class="_ _1c"> </span>=<span class="_ _23"> </span>dict(clsdict) </span></span><span class="ws138">来完成这个效</span></div><div class="t m0 x5 h9 y2c ff1 fs3 fc0 sc0 ls0">果。</div><div class="t m0 x0 h9 y99 ff1 fs3 fc0 sc0 ls3a ws153">对于很多应用程序而已，能够捕获类定义的顺序是一个看似不起眼却又非常重要的</div><div class="t m0 x5 h9 y9a ff1 fs3 fc0 sc0 ls0">特性。例如，在对象关系映射中，我们通常会看到下面这种方式定义的类：</div><div class="t m0 x5 hf y396 ff7 fs5 fca sc0 ls0 ws16a">class <span class="fcc ws156">Stock<span class="ff8 fc0">(Model):</span></span></div><div class="t m0 x15 hf y397 ff8 fs5 fc0 sc0 ls0 ws13c">name <span class="fc6 ls32">=</span>String()</div><div class="t m0 x15 hf y23c0 ff8 fs5 fc0 sc0 ls0 ws145">shares <span class="fc6 ls32">=</span>Integer()</div><div class="t m0 x15 hf y23c1 ff8 fs5 fc0 sc0 ls0 ws15f">price <span class="fc6 ls33">=</span>Float()</div><div class="t m0 x0 h9 y23c2 ff1 fs3 fc0 sc0 ls3a ws153">在框架底层，我们必须捕获定义的顺序来将对象映射到元组或数据库表中的行（就</div><div class="t m0 x5 h9 y23c3 ff1 fs3 fc0 sc0 lse wsc2b">类似于上面例子中的 <span class="ff6 ls0 ws1ca">as csv() <span class="ff1 wsa0">的<span class="_ _6"></span>功能）<span class="_ _f"></span>。<span class="_ _6"></span>这节演<span class="_ _6"></span>示的<span class="_ _6"></span>技术<span class="_ _6"></span>非常简<span class="_ _6"></span>单，并<span class="_ _6"></span>且通<span class="_ _6"></span>常会比<span class="_ _6"></span>其</span></span></div><div class="t m0 x5 h9 y23c4 ff1 fs3 fc0 sc0 ls0">他类似方法（通常都要在描述器类中维护一个隐藏的计数器）要简单的多。</div><div class="t m0 x5 hd y23c5 ff2 fs4 fc4 sc0 ls0 ws211">11.15<span class="_ _e"> </span>9.15 <span class="ff1">定义有可选参数的元类</span></div><div class="t m0 x5 he y23c6 ff2 fs2 fc4 sc0 ls0 wsadf">11.15.1 <span class="ff1">问题</span></div><div class="t m0 x0 h9 y23c7 ff1 fs3 fc0 sc0 ls3a ws153">你想定义一个元类，允许类定义时提供可选参数，这样可以控制或配置类型的创建</div><div class="t m0 x5 h9 y23c8 ff1 fs3 fc0 sc0 ls0">过程。</div><div class="t m0 x5 he y23c9 ff2 fs2 fc4 sc0 ls0 wsadf">11.15.2 <span class="ff1">解决方案</span></div><div class="t m0 x0 h7 y23ca ff1 fs3 fc0 sc0 ls0 wsa0">在定义类的时候，<span class="_ _c"></span><span class="ff4 wsc2c">Python <span class="ff1 wsa0">允许我们使用<span class="ff5 fc2 ws75">‘‘</span></span><span class="wsa5">metaclass‘‘<span class="ff1">关键字参数来指定特定的元类。</span></span></span></div><div class="t m0 x5 h9 y642 ff1 fs3 fc0 sc0 ls0">例如使用抽象基类：</div><div class="t m0 x5 hf y2183 ff7 fs5 fca sc0 ls0 ws15a">from <span class="fcc ws139">abc </span><span class="ws146">import <span class="ff8 fc0 ws13b">ABCMeta, abstractmethod</span></span></div><div class="t m0 x5 hf y23cb ff7 fs5 fca sc0 ls0 ws16a">class <span class="fcc ws156">IStream<span class="ff8 fc0 ws13a">(metaclass<span class="fc6">=</span>ABCMeta):</span></span></div><div class="t m0 x15 h10 y1e2d ff7 fs5 fc12 sc0 ls0">@abstractmethod</div><div class="t m0 x15 hf y23cc ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">read<span class="fc0">(<span class="fca">self</span><span class="ws4">, maxsize<span class="fc6 ls34">=</span></span><span class="fca">None</span>):</span></span></div><div class="t m0 x16 h10 y23cd ff7 fs5 fca sc0 ls0">pass</div><div class="t m0 x15 h10 y23ce ff7 fs5 fc12 sc0 ls0">@abstractmethod</div><div class="t m0 x15 hf y23cf ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">write<span class="fc0 ls34">(</span><span class="fca">self<span class="fc0 ws4">, data):</span></span></span></div><div class="t m0 x16 h10 y23d0 ff7 fs5 fca sc0 ls0">pass</div><div class="t m0 x0 h9 y23d1 ff1 fs3 fc0 sc0 ls0">然而，在自定义元类中我们还可以提供其他的关键字参数，如下所示：</div><div class="t m0 x5 hf y23d2 ff7 fs5 fca sc0 ls0 ws16a">class <span class="fcc ws156">Spam<span class="ff8 fc0 ws13a">(metaclass<span class="fc6">=</span><span class="ws4">MyMeta, debug</span><span class="fc6">=<span class="fca">True</span></span><span class="ws4">, synchronize<span class="fc6 ls34">=</span></span><span class="fca">True</span>):</span></span></div><div class="t m0 x15 h10 y23d3 ff7 fs5 fca sc0 ls0">pass</div><div class="t m0 x0 h7 y23d4 ff1 fs3 fc0 sc0 ls196 wsc2d">为了使元类支持这些关键字参数<span class="_ _8"></span>，你必须确保在 <span class="ff6 ls0 wsc2e">prepare<span class="_ _e"> </span>() <span class="ff4 ls197">,</span>new<span class="_ _e"> </span>() <span class="ff1">和</span></span></div><div class="t m0 x32 h9 y23d5 ff6 fs3 fc0 sc0 ls0 ws308">init<span class="_ _e"> </span>() <span class="ff1">方法中都使用强制关键字参数。就像下面这样：</span></div><div class="t m0 x5 hf y23d6 ff7 fs5 fca sc0 ls0 ws16a">class <span class="fcc ws156">MyMeta<span class="ff8 fc0 ws13a">(<span class="fca">type</span>):</span></span></div><div class="t m0 x15 h11 y23d7 ffa fs5 fcd sc0 ls0 ws13b"># Optional</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 wsae0">11.15.<span class="_ _5"> </span>9.15 <span class="ff1 wsaf4">定义有可选参数的元类 </span>332</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
