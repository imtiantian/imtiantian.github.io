<div id="pf13" class="pf w0 h0" data-page-no="13"><div class="pc pc13 w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg13.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 hf y15f ff8 fs5 fc8 sc0 ls0">2012</div><div class="t m0 x5 hf y160 ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h9 y161 ff1 fs3 fc0 sc0 ls0 wsa0">在很多函数式语言中，<span class="_ _6"></span>星号解压语法跟列表处理<span class="_ _6"></span>有许多相似之处。比如，如<span class="_ _6"></span>果你有</div><div class="t m0 x5 h9 y162 ff1 fs3 fc0 sc0 ls0">一个列表，你可以很容易的将它分割成前后两部分：</div><div class="t m0 x5 hf y163 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws15f">items <span class="fc6 ls33">=</span><span class="ws13a">[<span class="fc7 ls34">1</span><span class="ls33">,</span><span class="fc7">10</span><span class="ls33">,</span><span class="fc7">7</span><span class="ls33">,</span><span class="fc7">4</span><span class="ls33">,<span class="fc7 ls34">5</span><span class="ls32">,<span class="fc7 ls34">9</span></span></span>]</span></span></div><div class="t m0 x5 hf y164 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws15f">head, <span class="fc6 ls34">*</span><span class="ws13c">tail <span class="fc6 ls32">=</span>items</span></span></div><div class="t m0 x5 hf y165 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0">head</span></div><div class="t m0 x5 hf y166 ff8 fs5 fc8 sc0 ls0">1</div><div class="t m0 x5 hf y167 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0">tail</span></div><div class="t m0 x5 hf y168 ff8 fs5 fc8 sc0 ls0 ws4">[10, 7, 4, 5, 9]</div><div class="t m0 x5 hf y169 ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h9 y16a ff1 fs3 fc0 sc0 ls0">如果你够聪明的话，还能用这种分割语法去巧妙的实现递归算法。比如：</div><div class="t m0 x5 hf y16b ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="fca">def <span class="ff8 fcb ws13a">sum<span class="fc0">(items):</span></span></span></div><div class="t m0 x5 hf y16c ff7 fs5 fc5 sc0 ls0 ws139">... <span class="ff8 fc0 ws15f">head, <span class="fc6 ls34">*</span><span class="ws13c">tail <span class="fc6 ls32">=</span>items</span></span></div><div class="t m0 x5 hf y16d ff7 fs5 fc5 sc0 ls0 ws139">... <span class="fca ws146">return <span class="ff8 fc0 ws13c">head <span class="fc6 ls32">+</span><span class="fca ws13a">sum</span><span class="ws145">(tail) </span></span><span class="ws160">if <span class="ff8 fc0 ws161">tail </span><span class="ws15a">else <span class="ff8 fc0">head</span></span></span></span></div><div class="t m0 x5 h10 y16e ff7 fs5 fc5 sc0 ls0">...</div><div class="t m0 x5 hf y16f ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fca ws13a">sum<span class="fc0">(items)</span></span></div><div class="t m0 x5 hf y170 ff8 fs5 fc8 sc0 ls0">36</div><div class="t m0 x5 hf y171 ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h7 y172 ff1 fs3 fc0 sc0 ls3d ws162">然后，由于语言层面的限制<span class="_ _1"></span>，递归并不是 <span class="ff4 ls0 ws163">Python </span><span class="ws164">擅长的。因此，最后那个递归演<span class="_ _1"></span></span></div><div class="t m0 x5 h9 y173 ff1 fs3 fc0 sc0 ls0">示仅仅是个好奇的探索罢了，对这个不要太认真了。</div><div class="t m0 x5 hd y174 ff2 fs4 fc4 sc0 ls0 ws134">3.3<span class="_ _e"> </span>1.3 <span class="ff1 ws165">保留最后 </span><span class="ls3e">N</span><span class="ff1">个元素</span></div><div class="t m0 x5 he y175 ff2 fs2 fc4 sc0 ls0 ws135">3.3.1 <span class="ff1">问题</span></div><div class="t m0 x0 h9 y176 ff1 fs3 fc0 sc0 ls0">在迭代操作或者其他操作的时候，怎样只保留最后有限几个元素的历史记录？</div><div class="t m0 x5 he y177 ff2 fs2 fc4 sc0 ls0 ws135">3.3.2 <span class="ff1">解决方案</span></div><div class="t m0 x0 h9 y178 ff1 fs3 fc0 sc0 ls14 ws166">保留有限历史记录正是 <span class="ff6 ls0 ws167">collections.deque <span class="ff1 wsa0">大<span class="_ _6"></span>显<span class="_ _6"></span>身<span class="_ _6"></span>手<span class="_ _6"></span>的<span class="_ _6"></span>时<span class="_ _6"></span>候。<span class="_ _6"></span>比<span class="_ _6"></span>如，<span class="_ _6"></span>下<span class="_ _6"></span>面<span class="_ _6"></span>的<span class="_ _6"></span>代<span class="_ _6"></span>码</span></span></div><div class="t m0 x5 h7 y179 ff1 fs3 fc0 sc0 ls0 ws14">在多行上面做简单的文本匹配，并返回匹配所在行的前 <span class="ff4 ls3">N</span>行：</div><div class="t m0 x5 hf y17a ff7 fs5 fca sc0 ls0 ws15a">from <span class="fcc ws168">collections </span><span class="ws146">import <span class="ff8 fc0">deque</span></span></div><div class="t m0 x5 hf y17b ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">search<span class="fc0 ws4">(lines, pattern, history</span><span class="fc6">=<span class="fc7 ls34">5</span><span class="fc0">):</span></span></span></div><div class="t m0 x15 hf y17c ff8 fs5 fc0 sc0 ls0 ws169">previous_lines <span class="fc6 ls32">=</span><span class="ws13a">deque(maxlen<span class="fc6 ls34">=</span>history)</span></div><div class="t m0 x15 hf y17d ff7 fs5 fca sc0 ls0 ws139">for <span class="ff8 fc0 ws159">li </span><span class="ws157">in <span class="ff8 fc0">lines:</span></span></div><div class="t m0 x16 hf y17e ff7 fs5 fca sc0 ls0 ws157">if <span class="ff8 fc0 ws155">pattern </span>in <span class="ff8 fc0">li:</span></div><div class="t m0 x17 hf y17f ff7 fs5 fca sc0 ls0 ws16a">yield <span class="ff8 fc0 ws4">li, previous_lines</span></div><div class="t m0 x16 hf y180 ff8 fs5 fc0 sc0 ls0 ws13a">previous_lines<span class="fc6 ls34">.</span>append(li)</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 ws13e">3.3.<span class="_ _5"> </span>1.3 <span class="ff1 ws16b">保留最后 </span><span class="ls3f">N</span><span class="ff1 ws16c">个元素 </span>10</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
