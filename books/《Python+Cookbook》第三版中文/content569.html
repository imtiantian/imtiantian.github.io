<div id="pf239" class="pf w0 h0" data-page-no="239"><div class="pc pc239 w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg239.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 hd y112 ff2 fs4 fc4 sc0 ls0 ws211">17.5<span class="_ _e"> </span>15.5 <span class="ff1 ws357">从扩张模块中定义和导出 </span><span class="ls23d">C<span class="ff1 ls7c">的</span></span>API</div><div class="t m0 x5 he y113 ff2 fs2 fc4 sc0 ls0 ws212">17.5.1 <span class="ff1">问题</span></div><div class="t m0 x0 h7 y658 ff1 fs3 fc0 sc0 ls0 ws112f">你<span class="_ _6"></span>有一<span class="_ _6"></span>个 <span class="ff4 ls263">C</span><span class="wsa0">扩<span class="_ _6"></span>展<span class="_ _6"></span>模块，<span class="_ _6"></span>在<span class="_ _6"></span>内<span class="_ _6"></span>部<span class="_ _6"></span>定<span class="_ _6"></span>义了<span class="_ _6"></span>很<span class="_ _6"></span>多<span class="_ _6"></span>有<span class="_ _6"></span>用的<span class="_ _6"></span>函<span class="_ _6"></span>数，<span class="_ _6"></span>你<span class="_ _6"></span>想将<span class="_ _6"></span>它<span class="_ _6"></span>们<span class="_ _6"></span>导<span class="_ _6"></span>出为<span class="_ _6"></span>一<span class="_ _6"></span>个<span class="_ _6"></span>公</span></div><div class="t m0 x5 h7 y659 ff1 fs3 fc0 sc0 ls0 ws13f7">共<span class="_ _6"></span>的 <span class="ff4 ws13f8">C API </span><span class="lsd3 ws4b2">供其他地方使用<span class="_ _1"></span>。你想在其他扩展模块中使用这些函数<span class="_ _1"></span>，但是不知道怎<span class="_ _1"></span></span></div><div class="t m0 x5 h7 y36ec ff1 fs3 fc0 sc0 ls49 ws13f9">样将它们链接起来<span class="_ _1"></span>，并且通过 <span class="ff4 ls264">C</span><span class="ls0 wsa0">编<span class="_ _6"></span>译<span class="_ _6"></span>器<span class="ff4 ls6">/</span></span><span class="ws1a6">链接器来做看上去特别复杂（<span class="_ _1"></span>或者不可能做<span class="_ _1"></span></span></div><div class="t m0 x5 h9 y36ed ff1 fs3 fc0 sc0 ls0 wsa0">到）<span class="_ _f"></span>。</div><div class="t m0 x5 he y36ee ff2 fs2 fc4 sc0 ls0 ws212">17.5.2 <span class="ff1">解决方案</span></div><div class="t m0 x0 h7 y119 ff1 fs3 fc0 sc0 ls0 ws13fa">本节<span class="_ _6"></span>主要问<span class="_ _6"></span>题是<span class="_ _6"></span>如何处<span class="_ _6"></span>理 <span class="ff4 ws13fb">15.4 </span><span class="lse ws13fc">小节中提到的 </span><span class="ff4 ws13fd">Poin<span class="_ _c"></span>t <span class="ff1 ws13fe">对象。<span class="_ _6"></span>仔细<span class="_ _6"></span>回一下，<span class="_ _6"></span>在 </span><span class="ls265">C</span><span class="ff1 wsa0">代码</span></span></div><div class="t m0 x5 h9 y11a ff1 fs3 fc0 sc0 ls0">中包含了如下这些工具函数：</div><div class="t m0 x5 hf y11b ff8 fs5 fc0 sc0 ls0 ws4">/* Destructor function for points */</div><div class="t m0 x5 hf y11c ff8 fs5 fc0 sc0 ls0 ws4">static void del_Point(PyObject *obj) {</div><div class="t m0 x19 hf y36ef ff8 fs5 fc0 sc0 ls0">free(PyCapsule_GetPointer(obj,&quot;Point&quot;));</div><div class="t m0 x5 hf y36f0 ff8 fs5 fc0 sc0 ls0">}</div><div class="t m0 x5 hf y36f1 ff8 fs5 fc0 sc0 ls0 ws4">/* Utility functions */</div><div class="t m0 x5 hf y85 ff8 fs5 fc0 sc0 ls0 ws4">static Point *PyPoint_AsPoint(PyObject *obj) {</div><div class="t m0 x19 hf y36f2 ff8 fs5 fc0 sc0 ls0 ws4">return (Point *) PyCapsule_GetPointer(obj, &quot;Point&quot;);</div><div class="t m0 x5 hf y36f3 ff8 fs5 fc0 sc0 ls0">}</div><div class="t m0 x5 hf y36f4 ff8 fs5 fc0 sc0 ls0 ws4">static PyObject *PyPoint_FromPoint(Point *p, int must_free) {</div><div class="t m0 x19 hf y36f5 ff8 fs5 fc0 sc0 ls0 ws4">return PyCapsule_New(p, &quot;Point&quot;, must_free ? del_Point : NULL);</div><div class="t m0 x5 hf y36f6 ff8 fs5 fc0 sc0 ls0">}</div><div class="t m0 x0 h7 y36f7 ff1 fs3 fc0 sc0 ls2c ws13ff">现在的问题是怎样将 <span class="ff6 ls0 ws1400">PyPoint AsPoint() </span><span class="lsd6">和<span class="ff6 ls0 ws1401">Point<span class="_ _7"> </span>FromPoint() <span class="ff1 ws1402">函数<span class="_ _6"></span>作为 <span class="ff4 ws1403">API </span>导</span></span></span></div><div class="t m0 x5 h9 y36f8 ff1 fs3 fc0 sc0 ls139 ws859">出<span class="_ _d"></span>，这样其他扩展模块能使用并链接它们<span class="_ _c"></span>，比如如果你有其他扩展也想使用包装的<span class="_ _c"></span></div><div class="t m0 x5 h7 y36f9 ff4 fs3 fc0 sc0 ls0 ws1404">P<span class="_ _1"></span>oin<span class="_ _1"></span>t <span class="ff1">对象。</span></div><div class="t m0 x0 h9 y36fa ff1 fs3 fc0 sc0 ls0 wsc">要解决这个问题，首先要为 <span class="ff6 ws25d">sample </span><span class="ws63">扩展写个新的头文件名叫 <span class="ff6 ws2d1">pysample.h </span>，如下：</span></div><div class="t m0 x5 hf y182a ff8 fs5 fc0 sc0 ls0 ws4">/* pysample.h */</div><div class="t m0 x5 hf y1a43 ff8 fs5 fc0 sc0 ls0 ws4">#include &quot;Python.h&quot;</div><div class="t m0 x5 hf y1a44 ff8 fs5 fc0 sc0 ls0 ws4">#include &quot;sample.h&quot;</div><div class="t m0 x5 hf y1a45 ff8 fs5 fc0 sc0 ls0 ws4">#ifdef __cplusplus</div><div class="t m0 x5 hf y36fb ff8 fs5 fc0 sc0 ls0 ws4">extern &quot;C&quot; {</div><div class="t m0 x5 hf y36fc ff8 fs5 fc0 sc0 ls0">#endif</div><div class="t m0 x5 hf y13fc ff8 fs5 fc0 sc0 ls0 ws4">/* Public API Table */</div><div class="t m0 x5 hf y36fd ff8 fs5 fc0 sc0 ls0 ws4">typedef struct {</div><div class="t m0 x19 hf y2d25 ff8 fs5 fc0 sc0 ls0 ws4">Point *(*aspoint)(PyObject *);</div><div class="t m0 x19 hf y2d26 ff8 fs5 fc0 sc0 ls0 ws4">PyObject *(*frompoint)(Point *, int);</div><div class="t m0 x5 hf y2d27 ff8 fs5 fc0 sc0 ls0 ws4">} _PointAPIMethods;</div><div class="t m0 x5 hf y36fe ff8 fs5 fc0 sc0 ls0 ws4">#ifndef PYSAMPLE_MODULE</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 ws21d">17.5.<span class="_ _36"> </span>15.5 <span class="ff1 ws36c">从扩张模块中定义和导出 </span><span class="ls246">C<span class="ff1 ls81">的</span></span><span class="ws1405">API 560</span></div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
