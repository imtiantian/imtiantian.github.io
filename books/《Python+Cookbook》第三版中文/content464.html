<div id="pf1d0" class="pf w0 h0" data-page-no="1d0"><div class="pc pc1d0 w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg1d0.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x15 hf y1ab ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">__init__<span class="fc0">(<span class="fca">self</span><span class="ws4">, initial_value <span class="fc6 ls32">=<span class="fc7 ls34">0</span></span>):</span></span></span></div><div class="t m0 x16 hf y1ac ff8 fs5 fca sc0 ls0 ws13a">self<span class="fc6">.<span class="fc0 ws19f">_value </span><span class="ls32">=</span><span class="fc0">initial_value</span></span></div><div class="t m0 x15 hf y1ae ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">incr<span class="fc0">(<span class="fca">self</span>,delta<span class="fc6">=<span class="fc7 ls34">1</span></span>):</span></span></div><div class="t m0 x16 h15 y1af ffb fs5 fc9 sc0 ls0">&apos;&apos;&apos;</div><div class="t m0 x16 h11 y1b0 ffa fs5 fc9 sc0 ls0 ws4">Increment the counter with locking</div><div class="t m0 x16 h15 y355 ffb fs5 fc9 sc0 ls0">&apos;&apos;&apos;</div><div class="t m0 x16 hf y410 ff7 fs5 fca sc0 ls0 ws218">with <span class="ff8 fc0 ws13a">SharedCounter<span class="fc6 ls34">.</span>_lock:</span></div><div class="t m0 x17 hf y411 ff8 fs5 fca sc0 ls0 ws13a">self<span class="fc6">.<span class="fc0 ws145">_value </span><span class="ws1a1">+= <span class="fc0">delta</span></span></span></div><div class="t m0 x15 hf y8c6 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">decr<span class="fc0">(<span class="fca">self</span>,delta<span class="fc6">=<span class="fc7 ls34">1</span></span>):</span></span></div><div class="t m0 x16 h15 ybed ffb fs5 fc9 sc0 ls0">&apos;&apos;&apos;</div><div class="t m0 x16 h11 ybee ffa fs5 fc9 sc0 ls0 ws4">Decrement the counter with locking</div><div class="t m0 x16 h15 ybef ffb fs5 fc9 sc0 ls0">&apos;&apos;&apos;</div><div class="t m0 x16 hf ybf0 ff7 fs5 fca sc0 ls0 ws218">with <span class="ff8 fc0 ws13a">SharedCounter<span class="fc6 ls34">.</span>_lock:</span></div><div class="t m0 x3d hf yd7d ff8 fs5 fca sc0 ls0 ws13a">self<span class="fc6 ls34">.</span><span class="fc0">incr(<span class="fc6">-</span>delta)</span></div><div class="t m0 x0 h9 y2e91 ff1 fs3 fc0 sc0 ls3a ws153">在上边这个例子中，没有对每一个实例中的可变对象加锁，取而代之的是一个被所</div><div class="t m0 x5 h9 y2e92 ff1 fs3 fc0 sc0 ls1e ws111">有实例共享的类级锁<span class="_ _1"></span>。这个锁用来同步类方法<span class="_ _1"></span>，具体来说就是，这个锁可以保证<span class="_ _1"></span>一次</div><div class="t m0 x5 h9 y2e93 ff1 fs3 fc0 sc0 ls1e ws111">只有一个线程可以调用这个类方法<span class="_ _1"></span>。不过<span class="_ _1"></span>，与一个标准的锁不同的是，已经持有<span class="_ _1"></span>这个</div><div class="t m0 x5 h7 y2e94 ff1 fs3 fc0 sc0 ls18 ws10b0">锁的方法在调用同样使用这个锁的方法时，无需再次获取锁。比如 <span class="ff4 ls0 ws10b1">decr </span><span class="ws110">方法<span class="_ _1"></span>。这种实</span></div><div class="t m0 x5 h9 y2e95 ff1 fs3 fc0 sc0 ls13 wse5">现方式的一个特点是<span class="_ _1"></span>，无论这个类有多少个实例都只用一个锁。因此在需要大量使用<span class="_ _c"></span></div><div class="t m0 x5 h9 yfce ff1 fs3 fc0 sc0 ls13 wse5">计数器的情况下内存效率更高<span class="_ _1"></span>。不过这样做也有缺点，就是在程序中使用大量线程并<span class="_ _c"></span></div><div class="t m0 x5 h9 y2e96 ff1 fs3 fc0 sc0 ls2d ws132">频繁更新计数器时会有争用锁的问题。信号量对象是一个建立在共享计数器基础上的<span class="_ _1"></span></div><div class="t m0 x5 h7 y2e97 ff1 fs3 fc0 sc0 ls10 ws10b2">同步原语<span class="_ _1"></span>。如果计数器不为 <span class="ff4 ls6">0</span><span class="ls11">，<span class="ff4 ls0 ws10b3">with </span></span><span class="ws10b4">语句将计数器减 <span class="ff4 ls6">1</span><span class="wsdf">，线程被允许执行。<span class="ff4 ls0 ws10b3">with <span class="ff1 wsa0">语句</span></span></span></span></div><div class="t m0 x5 h7 y2e98 ff1 fs3 fc0 sc0 ls0 ws10b5">执行结束后，计数器加１。<span class="_ _1"></span>如果计数器为 <span class="ff4 ls6">0</span><span class="wsa0">，线程将被阻塞，<span class="_ _1"></span>直到其他线程结束将计数</span></div><div class="t m0 x5 h7 y2e99 ff1 fs3 fc0 sc0 ls0 ws5cf">器加 <span class="ff4 ls6">1</span><span class="wsa0">。<span class="_ _1"></span>尽管你可以在程序中像标准锁一样使用信号量来做线程同步，但是这种方式并</span></div><div class="t m0 x5 h9 y2e9a ff1 fs3 fc0 sc0 ls13 wse5">不被推荐<span class="_ _1"></span>，因为使用信号量为程序增加的复杂性会影响程序性能。相对于简单地作为<span class="_ _c"></span></div><div class="t m0 x5 h9 y5e5 ff1 fs3 fc0 sc0 ls1e ws111">锁使用<span class="_ _1"></span>，信号量更适用于那些需要在线程之间引入信号或者限制的程序<span class="_ _1"></span>。比如<span class="_ _1"></span>，你需</div><div class="t m0 x5 h9 y2e9b ff1 fs3 fc0 sc0 ls0">要限制一段代码的并发访问量，你就可以像下面这样使用信号量完成：</div><div class="t m0 x5 hf y2e9c ff7 fs5 fca sc0 ls0 ws15a">from <span class="fcc ws285">threading </span><span class="ws146">import <span class="ff8 fc0">Semaphore</span></span></div><div class="t m0 x5 h10 y2e9d ff7 fs5 fca sc0 ls0 ws146">import <span class="fcc">urllib.request</span></div><div class="t m0 x5 h11 y2e9e ffa fs5 fcd sc0 ls0 ws4"># At most, five threads allowed to run at once</div><div class="t m0 x5 hf y2e9f ff8 fs5 fc0 sc0 ls0 ws151">_fetch_url_sema <span class="fc6 ls32">=</span><span class="ws13a">Semaphore(<span class="fc7 ls34">5</span>)</span></div><div class="t m0 x5 hf y2ea0 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">fetch_url<span class="fc0">(url):</span></span></div><div class="t m0 x15 hf y2ea1 ff7 fs5 fca sc0 ls0 ws15a">with <span class="ff8 fc0">_fetch_url_sema:</span></div><div class="t m0 x16 hf y2ea2 ff7 fs5 fca sc0 ls0 ws146">return <span class="ff8 fc0 ws13a">urllib<span class="fc6 ls34">.</span>request<span class="fc6 ls34">.</span>urlopen(url)</span></div><div class="t m0 x0 h9 y294d ff1 fs3 fc0 sc0 ls3a ws153">如果你对线程同步原语的底层理论和实现感兴趣，可以参考操作系统相关书籍，绝</div><div class="t m0 x5 h9 y294e ff1 fs3 fc0 sc0 ls0">大多数都有提及。</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 ws21d">14.4.<span class="_ _36"> </span>12.4 <span class="ff1 ws600">给关键部分加锁 </span>455</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
