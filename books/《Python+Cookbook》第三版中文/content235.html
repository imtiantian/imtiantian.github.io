<div id="pfeb" class="pf w0 h0" data-page-no="eb"><div class="pc pceb w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bgeb.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x16 hf y1ab ff7 fs5 fca sc0 ls0 ws156">print<span class="ff8 fc0">(r)</span></div><div class="t m0 x15 hf y1ac ff7 fs5 fca sc0 ls0 ws156">print<span class="ff8 fc0 ws13a">(<span class="ff9 fc9 ls34">&apos;</span><span class="fc9">Goodbye<span class="ff9 ls34">&apos;</span></span>)</span></div><div class="t m0 x0 h9 y19a8 ff1 fs3 fc0 sc0 ls0 ws38">如果你调用 <span class="ff6 ws25d">test() </span>，你会得到类似如下的输出：</div><div class="t m0 x5 hf y19a9 ff8 fs5 fc7 sc0 ls0">5</div><div class="t m0 x5 hf y19aa ff8 fs5 fc0 sc0 ls0">helloworld</div><div class="t m0 x5 hf y19ab ff8 fs5 fc7 sc0 ls0">0</div><div class="t m0 x5 hf y19ac ff8 fs5 fc7 sc0 ls0">2</div><div class="t m0 x5 hf y19ad ff8 fs5 fc7 sc0 ls0">4</div><div class="t m0 x5 hf y19ae ff8 fs5 fc7 sc0 ls0">6</div><div class="t m0 x5 hf y19af ff8 fs5 fc7 sc0 ls0">8</div><div class="t m0 x5 hf y19b0 ff8 fs5 fc7 sc0 ls0">10</div><div class="t m0 x5 hf y19b1 ff8 fs5 fc7 sc0 ls0">12</div><div class="t m0 x5 hf y19b2 ff8 fs5 fc7 sc0 ls0">14</div><div class="t m0 x5 hf y19b3 ff8 fs5 fc7 sc0 ls0">16</div><div class="t m0 x5 hf y19b4 ff8 fs5 fc7 sc0 ls0">18</div><div class="t m0 x5 hf y19b5 ff8 fs5 fc0 sc0 ls0">Goodbye</div><div class="t m0 x0 h9 y19b6 ff1 fs3 fc0 sc0 ls49 ws99f">你会发现<span class="_ _1"></span>，除了那个特别的装饰器和 <span class="ff6 ls0 ws1a5">yield </span><span class="ws1a6">语句外<span class="_ _1"></span>，其他地方并没有出现任何的</span></div><div class="t m0 x5 h7 y18a4 ff1 fs3 fc0 sc0 ls0 ws14">回调函数 <span class="ff4 wsa5">(</span><span class="wsa0">其实是在后台定义的<span class="ff4 wsa5">)</span>。</span></div><div class="t m0 x5 he ya3f ff2 fs2 fc4 sc0 ls0 ws212">9.11.3 <span class="ff1">讨论</span></div><div class="t m0 x0 h9 y19b7 ff1 fs3 fc0 sc0 ls0">本小节会实实在在的测试你关于回调函数、生成器和控制流的知识。</div><div class="t m0 x0 h9 y19b8 ff1 fs3 fc0 sc0 ls14f ws91d">首先<span class="_ _d"></span>，在需要使用到回调的代码中<span class="_ _d"></span>，关键点在于当前计算工作会挂起并在将来<span class="_ _d"></span></div><div class="t m0 x5 h7 y19b9 ff1 fs3 fc0 sc0 ls1d ws9a0">的某个时候重启 <span class="ff4 ls0 wsa5">(</span><span class="ws1c3">比如异步执行<span class="_ _c"></span><span class="ff4 ls0 wsa5">)<span class="ff1 ls1d ws1c3">。当计算重启时<span class="_ _1"></span>，回调函数被调用来继续处理结果<span class="_ _c"></span>。</span></span></span></div><div class="t m0 x5 h9 y19ba ff6 fs3 fc0 sc0 ls0 ws149">apply async() <span class="ff1 ls6c ws29d">函数演示了执行回调的实际逻辑，尽管实际情况中<span class="_ _1"></span>它可能会更加复杂<span class="_ _1"></span></span></div><div class="t m0 x5 h7 y19bb ff4 fs3 fc0 sc0 ls0 wsa5">(<span class="ff1 wsa0">包括线程、进程、事件处理器等等</span><span class="ls1b">)</span><span class="ff1">。</span></div><div class="t m0 x0 h9 y19bc ff1 fs3 fc0 sc0 ls51 ws1c8">计算的暂停与重启思路跟生成器函数的执行模型不谋而合。具体来讲<span class="_ _1"></span>，<span class="ff6 ls0 ws9a1">yield <span class="ff1 wsa0">操作</span></span></div><div class="t m0 x5 h9 y19bd ff1 fs3 fc0 sc0 ls0 ws9a2">会使一个生成器函数产生一个值并暂停。<span class="_ _c"></span>接下来调用生成器的 <span class="ff6 ws9a3">next<span class="_ _e"> </span>() </span><span class="ls15a">或</span><span class="ff6 ws9a4">send() </span>方</div><div class="t m0 x5 h9 y19be ff1 fs3 fc0 sc0 ls0">法又会让它从暂停处继续执行。</div><div class="t m0 x0 h9 y19bf ff1 fs3 fc0 sc0 ls0 ws9a5">根据<span class="_ _6"></span>这个<span class="_ _6"></span>思路，<span class="_ _6"></span>这一<span class="_ _6"></span>小节<span class="_ _6"></span>的核<span class="_ _6"></span>心就<span class="_ _6"></span>在 <span class="ff6 ws20d">inline async() </span><span class="wsa0">装<span class="_ _6"></span>饰器<span class="_ _6"></span>函数<span class="_ _6"></span>中了。<span class="_ _6"></span>关键<span class="_ _6"></span>点就</span></div><div class="t m0 x5 h9 yc21 ff1 fs3 fc0 sc0 ls0 ws9a6">是，装<span class="_ _6"></span>饰<span class="_ _6"></span>器会<span class="_ _6"></span>逐步<span class="_ _6"></span>遍<span class="_ _6"></span>历生<span class="_ _6"></span>成器<span class="_ _6"></span>函<span class="_ _6"></span>数的<span class="_ _6"></span>所<span class="_ _6"></span>有 <span class="ff6 ws9a7">yield </span><span class="wsa0">语句，<span class="_ _6"></span>每一<span class="_ _6"></span>次<span class="_ _6"></span>一个。<span class="_ _6"></span>为了<span class="_ _6"></span>这<span class="_ _6"></span>样做，<span class="_ _6"></span>刚</span></div><div class="t m0 x5 h9 y19c0 ff1 fs3 fc0 sc0 ls0 ws9a8">开<span class="_ _6"></span>始<span class="_ _0"></span>的<span class="_ _6"></span>时<span class="_ _6"></span>候<span class="_ _0"></span>创<span class="_ _6"></span>建<span class="_ _6"></span>了<span class="_ _0"></span>一<span class="_ _6"></span>个 <span class="ff6 ws9a9">result </span>队<span class="_ _6"></span>列<span class="_ _0"></span>并<span class="_ _6"></span>向<span class="_ _6"></span>里<span class="_ _0"></span>面<span class="_ _6"></span>放<span class="_ _6"></span>入<span class="_ _0"></span>一<span class="_ _6"></span>个 <span class="ff6 ws9aa">None </span><span class="wsa0">值。<span class="_ _6"></span>然<span class="_ _0"></span>后<span class="_ _6"></span>开<span class="_ _6"></span>始<span class="_ _0"></span>一<span class="_ _6"></span>个<span class="_ _6"></span>循<span class="_ _0"></span>环</span></div><div class="t m0 x5 h9 y19c1 ff1 fs3 fc0 sc0 ls12 ws9ab">操作，从队列中取出结果值并发送给生成器<span class="_ _c"></span>，它会持续到下一个 <span class="ff6 ls0 ws224">yield </span><span class="wse4">语句，在这里</span></div><div class="t m0 x5 h9 y19c2 ff1 fs3 fc0 sc0 ls0 ws9ac">一<span class="_ _6"></span>个 <span class="ff6 ws9ad">Async </span><span class="ls15b ws9ae">的实例被接受到<span class="_ _1"></span>。然后循环开始检查函数和参数<span class="_ _c"></span>，并开始进行异步计算<span class="_ _c"></span></span></div><div class="t m0 x5 h9 y19c3 ff6 fs3 fc0 sc0 ls0 ws149">apply async() <span class="ff1 ls6c ws29d">。然而，这个计算有个最诡异部分是它并没有使用一<span class="_ _1"></span>个普通的回调函<span class="_ _1"></span></span></div><div class="t m0 x5 h9 y19c4 ff1 fs3 fc0 sc0 ls0 ws14">数，而是用队列的 <span class="ff6 ws17d">put() </span>方法来回调。</div><div class="t m0 x0 h9 y19c5 ff1 fs3 fc0 sc0 ls3a ws153">这时候，是时候详细解释下到底发生了什么了。主循环立即返回顶部并在队列上执</div><div class="t m0 x5 h9 y19c6 ff1 fs3 fc0 sc0 ls5d">行<span class="ff6 ls0 ws203">get() </span><span class="ls0 ws9af">操作。如<span class="_ _6"></span>果数据<span class="_ _6"></span>存在，<span class="_ _6"></span>它一定<span class="_ _6"></span>是 <span class="ff6 ws9b0">put() </span><span class="wsa0">回调存<span class="_ _6"></span>放的结<span class="_ _6"></span>果。如果<span class="_ _6"></span>没有数<span class="_ _6"></span>据，那</span></span></div><div class="t m0 x5 h9 y19c7 ff1 fs3 fc0 sc0 ls22 ws9b1">么先暂停操作并等待结果的到来。这个具体怎样实现是由 <span class="ff6 ls0 ws9b2">apply async() <span class="ff1 wsa0">函数<span class="_ _6"></span>来决<span class="_ _6"></span>定</span></span></div><div class="t m0 x5 h9 y19c8 ff1 fs3 fc0 sc0 ls0 ws9b3">的。<span class="_ _6"></span>如<span class="_ _6"></span>果<span class="_ _6"></span>你<span class="_ _0"></span>不相<span class="_ _0"></span>信会<span class="_ _0"></span>有<span class="_ _6"></span>这<span class="_ _6"></span>么<span class="_ _6"></span>神<span class="_ _6"></span>奇<span class="_ _6"></span>的<span class="_ _0"></span>事情，<span class="_ _0"></span>你可<span class="_ _0"></span>以使<span class="_ _0"></span>用 <span class="ff6 ws9b4">multiprocessing </span><span class="wsa0">库<span class="_ _6"></span>来<span class="_ _6"></span>试<span class="_ _6"></span>一<span class="_ _6"></span>下，</span></div><div class="t m0 x5 h9 y19c9 ff1 fs3 fc0 sc0 ls0">在单独的进程中执行异步计算操作，如下所示：</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 ws21d">9.11.<span class="_ _5"> </span>7.11 <span class="ff1 ws999">内联回调函数 </span>226</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
