<div id="pf16" class="pf w0 h0" data-page-no="16"><div class="pc pc16 w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg16.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 hf y1ab ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws13c">nums <span class="fc6 ls32">=</span><span class="ls34">[</span><span class="fc7 ws13a">1</span><span class="ls33">,<span class="fc7 ls34">8</span><span class="ls32">,<span class="fc7 ls34">2</span>,</span></span><span class="fc7 ws13a">23</span><span class="ls32">,<span class="fc7 ls34">7</span>,<span class="fc6 ls34">-<span class="fc7">4</span></span>,</span><span class="fc7 ws13a">18</span><span class="ls32">,</span><span class="fc7 ws13a">23</span><span class="ls32">,</span><span class="fc7 ws13a">42</span><span class="ls32">,</span><span class="fc7 ws13a">37</span><span class="ls33">,<span class="fc7 ls34">2</span></span>]</span></div><div class="t m0 x5 h10 y1ac ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="fca ws146">import <span class="fcc">heapq</span></span></div><div class="t m0 x5 hf y1ad ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws13a">heapq<span class="fc6">.</span>heapify(nums)</span></div><div class="t m0 x5 hf y1ae ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0">nums</span></div><div class="t m0 x5 hf y1af ff8 fs5 fc8 sc0 ls0 ws4">[-4, 2, 1, 23, 7, 2, 18, 23, 42, 37, 8]</div><div class="t m0 x5 hf y1b0 ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h9 y1b1 ff1 fs3 fc0 sc0 ls14 ws182">堆数据结构最重要的特征是 <span class="ff6 ls0 ws183">heap[0] </span><span class="ws174">永远是最小的元素<span class="_ _1"></span>。并且剩余的元素可以很</span></div><div class="t m0 x5 h9 y1b2 ff1 fs3 fc0 sc0 ls42 ws184">容易的通过调用 <span class="ff6 ls0 ws185">heapq.heappop() </span><span class="ws186">方法得到，该方法会先将第一个元素弹出来<span class="_ _1"></span>，然后</span></div><div class="t m0 x5 h7 y1cc ff1 fs3 fc0 sc0 ls0 ws187">用<span class="_ _6"></span>下一<span class="_ _6"></span>个<span class="_ _6"></span>最<span class="_ _6"></span>小<span class="_ _6"></span>的<span class="_ _6"></span>元<span class="_ _6"></span>素<span class="_ _6"></span>来取<span class="_ _6"></span>代<span class="_ _6"></span>被<span class="_ _6"></span>弹<span class="_ _6"></span>出<span class="_ _6"></span>元<span class="_ _6"></span>素 <span class="ff4 ls1b">(</span><span class="ws188">这<span class="_ _6"></span>种操<span class="_ _6"></span>作<span class="_ _6"></span>时<span class="_ _6"></span>间<span class="_ _6"></span>复<span class="_ _6"></span>杂<span class="_ _6"></span>度仅<span class="_ _6"></span>仅<span class="_ _6"></span>是 <span class="ff4 ws189">O(log N)</span><span class="ls43">，<span class="ff4 ls41">N</span></span>是</span></div><div class="t m0 x5 h7 y1cd ff1 fs3 fc0 sc0 ls0 wsa0">堆大小<span class="ff4 wsa5">)</span><span class="ws38">。比如，如果想要查找最小的 <span class="ff4 ls39">3</span>个元素，你可以这样做：</span></div><div class="t m0 x5 hf y1ce ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws13a">heapq<span class="fc6">.</span>heappop(nums)</span></div><div class="t m0 x5 hf y1cf ff8 fs5 fc8 sc0 ls0">-4</div><div class="t m0 x5 hf y1d0 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws13a">heapq<span class="fc6">.</span>heappop(nums)</span></div><div class="t m0 x5 hf y1d1 ff8 fs5 fc8 sc0 ls0">1</div><div class="t m0 x5 hf y1d2 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws13a">heapq<span class="fc6">.</span>heappop(nums)</span></div><div class="t m0 x5 hf y1d3 ff8 fs5 fc8 sc0 ls0">2</div><div class="t m0 x0 h9 y1d4 ff1 fs3 fc0 sc0 ls1d ws18a">当要查找的元素个数相对比较小的时候<span class="_ _c"></span>，函数 <span class="ff6 ls0 ws18b">nlargest() </span><span class="ls44">和<span class="ff6 ls0 ws18c">nsmallest() <span class="ff1 wsa0">是<span class="_ _0"></span>很</span></span></span></div><div class="t m0 x5 h7 y1d5 ff1 fs3 fc0 sc0 ls18 ws18d">合适的。如果你仅仅想查找唯一的最小或最大 <span class="ff4 ls0 ws18e">(N=1) </span><span class="ws18f">的元素的话，那么使用 <span class="ff4 ls0 ws190">min() <span class="ff1">和</span></span></span></div><div class="t m0 x5 h7 y1d6 ff4 fs3 fc0 sc0 ls0 ws191">max() <span class="ff1 ws192">函数<span class="_ _6"></span>会更<span class="_ _6"></span>快些。<span class="_ _6"></span>类似<span class="_ _6"></span>的，如<span class="_ _6"></span>果 </span><span class="ls45">N<span class="ff1 ls17 wsf6">的大小和集合大小接近的时候，通常先排序这<span class="_ _c"></span></span></span></div><div class="t m0 x5 h7 y1d7 ff1 fs3 fc0 sc0 ls0 ws193">个<span class="_ _6"></span>集<span class="_ _6"></span>合然<span class="_ _6"></span>后<span class="_ _6"></span>再<span class="_ _6"></span>使<span class="_ _6"></span>用<span class="_ _6"></span>切<span class="_ _6"></span>片<span class="_ _6"></span>操<span class="_ _6"></span>作<span class="_ _6"></span>会<span class="_ _6"></span>更快<span class="_ _6"></span>点 <span class="ff4 ls46">(</span><span class="ff6 ws194">sorted(items)[:N] </span><span class="ls40 ws195">或者是 </span><span class="ff6">sorted(items)[-</span></div><div class="t m0 x5 h7 y1d8 ff6 fs3 fc0 sc0 ls0 ws196">N:] <span class="ff4 wsa5">)<span class="ff1 ls10 ws197">。需要在正确场合使用函数 </span><span class="ws198">nlargest() <span class="ff1 ls47">和</span><span class="ws199">nsmallest() <span class="ff1 ls10 ws19a">才能发挥它们的优势 </span><span class="ls1b">(</span><span class="ff1 wsa0">如果</span></span></span></span></div><div class="t m0 x5 h7 y1d9 ff4 fs3 fc0 sc0 ls3">N<span class="ff1 ls0 wsa0">快接近集合大小了，那么使用排序操作会更好些</span><span class="ls1b">)<span class="ff1 ls0">。</span></span></div><div class="t m0 x0 h9 y1da ff1 fs3 fc0 sc0 ls3a ws153">尽管你没有必要一定使用这里的方法，但是堆数据结构的实现是一个很有趣并且值</div><div class="t m0 x5 h9 y1db ff1 fs3 fc0 sc0 ls48 ws19b">得你深入学习的东西<span class="_ _1"></span>。基本上只要是数据结构和算法书籍里面都会有提及到。 <span class="ff6 ls0">heapq</span></div><div class="t m0 x5 h9 y1dc ff1 fs3 fc0 sc0 ls0">模块的官方文档里面也详细的介绍了堆数据结构底层的实现细节。</div><div class="t m0 x5 hd y1dd ff2 fs4 fc4 sc0 ls0 ws134">3.5<span class="_ _e"> </span>1.5 <span class="ff1">实现一个优先级队列</span></div><div class="t m0 x5 he y1de ff2 fs2 fc4 sc0 ls0 ws135">3.5.1 <span class="ff1">问题</span></div><div class="t m0 x0 h7 y1df ff1 fs3 fc0 sc0 ls48 ws19c">怎样实现一个按优先级排序的队列<span class="_ _c"></span>？<span class="_ _6"></span>并且在这个队列上面每次 <span class="ff4 ls0 ws19d">pop <span class="ff1 wsa0">操<span class="_ _6"></span>作<span class="_ _6"></span>总<span class="_ _6"></span>是<span class="_ _6"></span>返<span class="_ _6"></span>回</span></span></div><div class="t m0 x5 h9 y1e0 ff1 fs3 fc0 sc0 ls0">优先级最高的那个元素</div><div class="t m0 x5 he y1e1 ff2 fs2 fc4 sc0 ls0 ws135">3.5.2 <span class="ff1">解决方案</span></div><div class="t m0 x0 h9 y1e2 ff1 fs3 fc0 sc0 ls0 wsc">下面的类利用 <span class="ff6 ws19e">heapq </span>模块实现了一个简单的优先级队列：</div><div class="t m0 x5 h10 y1e3 ff7 fs5 fca sc0 ls0 ws146">import <span class="fcc">heapq</span></div><div class="t m0 x5 hf y1e4 ff7 fs5 fca sc0 ls0 ws16a">class <span class="fcc ws156">PriorityQueue<span class="ff8 fc0">:</span></span></div><div class="t m0 x15 hf y1e5 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">__init__<span class="fc0">(<span class="fca">self</span>):</span></span></div><div class="t m0 x16 hf y1e6 ff8 fs5 fca sc0 ls0 ws13a">self<span class="fc6">.<span class="fc0 ws19f">_queue </span><span class="ls32">=</span><span class="fc0">[]</span></span></div><div class="t m0 x16 hf y1e7 ff8 fs5 fca sc0 ls0 ws13a">self<span class="fc6">.<span class="fc0 ws19f">_index </span><span class="ls32">=</span><span class="fc7">0</span></span></div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 ws13e">3.5.<span class="_ _5"> </span>1.5 <span class="ff1 ws1a0">实现一个优先级队列 </span>13</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
