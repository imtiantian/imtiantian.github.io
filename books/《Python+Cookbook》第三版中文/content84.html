<div id="pf54" class="pf w0 h0" data-page-no="54"><div class="pc pc54 w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg54.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x1f h7 y2a ffe fs3 fc0 sc0 lsbf">•<span class="ff1 lsa8 ws446">如果规则中下一个符号是个特殊符号 </span><span class="ff4 ls0 wsa5">(<span class="ff1 ws447">比如 </span>()</span><span class="ff1 lsa8 ws3de">，你得查找下一个令牌并确认是一</span></div><div class="t m0 x20 h7 y2b ff1 fs3 fc0 sc0 ls0 wsa0">个<span class="_ _6"></span>精<span class="_ _6"></span>确<span class="_ _6"></span>匹<span class="_ _6"></span>配<span class="ff4 wsa5">)</span><span class="lsa5 ws448">。如果不匹配<span class="_ _1"></span>，就产生一个语法错误<span class="_ _1"></span>。这一节中的 <span class="ff6 ls0 ws449">expect() <span class="ff1 wsa0">方<span class="_ _6"></span>法</span></span></span></div><div class="t m0 x20 h9 y2c ff1 fs3 fc0 sc0 ls0">就是用来做这一步的。</div><div class="t m0 x1f h7 y99 ffe fs3 fc0 sc0 lsbf">•<span class="ff1 ls56 ws44a">如果规则中下一个符号为一些可能的选择项 <span class="ff4 ls1b">(</span><span class="ls0 ws44b">比<span class="_ _6"></span>如 <span class="ff4 lsc4">+</span><span class="lsc5">或</span><span class="ff4 wsa5">-)</span></span><span class="ws1fa">，你必须对每一种可<span class="_ _c"></span></span></span></div><div class="t m0 x20 h9 y9a ff1 fs3 fc0 sc0 ls18 ws110">能情况检查下一个令牌，只有当它匹配一个的时候才能继续。这也是本节示例中</div><div class="t m0 x21 h7 y9b ff6 fs3 fc0 sc0 ls0 ws44c">accept() <span class="ff1 ls42 ws44d">方法的目的。它相当于 </span><span class="ff4 ws44e">expect() <span class="ff1 ls42 ws186">方法的弱化版本，因为如果一个匹配</span></span></div><div class="t m0 x20 h7 y9c ff1 fs3 fc0 sc0 ls30 ws44f">找到了它会继续<span class="_ _1"></span>，但是如果没找到，它不会产生错误而是回滚 <span class="ff4 ls0 wsa5">(</span><span class="ws138">允许后续的检查<span class="_ _c"></span></span></div><div class="t m0 x20 h7 y9d ff1 fs3 fc0 sc0 ls0 wsa0">继续进行<span class="ff4 wsa5">)</span>。</div><div class="t m0 x1f h7 y33 ffe fs3 fc0 sc0 lsbf">•<span class="ff1 ls0 ws91">对于有重复部分的规则 <span class="ff4 ls1b">(</span>比如在规则表达式 <span class="ff6 ws450">::= term <span class="ffd lsc6">{</span><span class="ws303">(&apos;+&apos;<span class="ffd ws305">|</span></span>&apos;-&apos;) term <span class="ffd ws305">}</span><span class="lsc7">*</span></span><span class="wsa0">中<span class="ff4 ls1b">)</span>，</span></span></div><div class="t m0 x20 h7 y34 ff1 fs3 fc0 sc0 ls42 ws451">重复动作通过一个 <span class="ff4 ls0 ws452">while </span><span class="ws186">循环来实现。循环主体会收集或处理所有的重复元素直<span class="_ _1"></span></span></div><div class="t m0 x20 h9 y35 ff1 fs3 fc0 sc0 ls0">到没有其他元素可以找到。</div><div class="t m0 x1f h9 y978 ffe fs3 fc0 sc0 lsbf">•<span class="ff1 ls18 ws110">一旦整个语法规则处理完成，每个方法会返回某种结果给调用者。这就是在解析</span></div><div class="t m0 x20 h9 y9f ff1 fs3 fc0 sc0 ls3d ws164">过程中值是怎样累加的原理。比如<span class="_ _1"></span>，在表达式求值程序中，返回值代表表达式解<span class="_ _1"></span></div><div class="t m0 x20 h9 ya0 ff1 fs3 fc0 sc0 ls0">析后的部分结果。最后所有值会在最顶层的语法规则方法中合并起来。</div><div class="t m0 x0 h9 y3a ff1 fs3 fc0 sc0 ls63 ws21f">尽管向你演示的是一个简单的例子<span class="_ _c"></span>，递归下降解析器可以用来实现非常复杂的解<span class="_ _1"></span></div><div class="t m0 x5 h7 y70 ff1 fs3 fc0 sc0 ls0 wsa0">析。比如，<span class="_ _6"></span><span class="ff4 ws453">Python </span><span class="ls18 ws110">语言本身就是通过一个递归下降解析器去解释的。如果你对此感兴<span class="_ _1"></span></span></div><div class="t m0 x5 h7 y71 ff1 fs3 fc0 sc0 ls0 ws454">趣，<span class="_ _6"></span>你<span class="_ _0"></span>可<span class="_ _6"></span>以<span class="_ _6"></span>通<span class="_ _0"></span>过<span class="_ _6"></span>查<span class="_ _0"></span>看 <span class="ff4 ws455">Python </span><span class="lsc8 ws456">源码文件 </span><span class="ff4 ws457">Grammar/Grammar </span><span class="wsa0">来<span class="_ _0"></span>研<span class="_ _6"></span>究<span class="_ _0"></span>下<span class="_ _6"></span>底<span class="_ _6"></span>层<span class="_ _0"></span>语<span class="_ _6"></span>法<span class="_ _6"></span>机<span class="_ _0"></span>制。</span></div><div class="t m0 x5 h9 y72 ff1 fs3 fc0 sc0 ls0">看完你会发现，通过手动方式去实现一个解析器其实会有很多的局限和不足之处。</div><div class="t m0 x0 h9 y979 ff1 fs3 fc0 sc0 ls3a ws153">其中一个局限就是它们不能被用于包含任何左递归的语法规则中。比如，加入你需</div><div class="t m0 x5 h9 y97a ff1 fs3 fc0 sc0 ls0">要翻译下面这样一个规则：</div><div class="t m0 x5 hf y97b ff8 fs5 fc0 sc0 ls0 ws4">items ::<span class="fc6 ls32">=</span><span class="ws458">items <span class="ff9 fc9 ws13b">&apos;<span class="ff8 ls34">,</span><span class="ls33">&apos;</span></span>item</span></div><div class="t m0 x15 hf y97c ffd fs5 fc6 sc0 lsbd">|<span class="ff8 fc0 ls0">item</span></div><div class="t m0 x0 h9 y97d ff1 fs3 fc0 sc0 ls0 ws38">为了这样做，你可能会像下面这样使用 <span class="ff6 ws23a">items() </span>方法：</div><div class="t m0 x5 hf y97e ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">items<span class="fc0">(<span class="fca">self</span>):</span></span></div><div class="t m0 x15 hf y97f ff8 fs5 fc0 sc0 ls0 ws1f5">itemsval <span class="fc6 ls33">=</span><span class="fca ws13a">self<span class="fc6 ls34">.</span></span>items()</div><div class="t m0 x15 hf y980 ff7 fs5 fca sc0 ls0 ws157">if <span class="ff8 fc0 ws16d">itemsval </span><span class="ws139">and <span class="ff8 ws13a">self<span class="fc6 ls34">.</span><span class="fc0">_accept(<span class="ff9 fc9 ls34">&apos;</span><span class="fc9">,<span class="ff9 ls34">&apos;</span></span>):</span></span></span></div><div class="t m0 x16 hf y981 ff8 fs5 fc0 sc0 ls0 ws13a">itemsval<span class="fc6">.</span>append(<span class="fca">self<span class="fc6 ls34">.</span></span>item())</div><div class="t m0 x15 hf y982 ff7 fs5 fca sc0 ls0 ws156">else<span class="ff8 fc0">:</span></div><div class="t m0 x16 hf y983 ff8 fs5 fc0 sc0 ls0 ws1f5">itemsval <span class="fc6 ls33">=</span><span class="ls32">[</span><span class="fca ws13a">self<span class="fc6 ls34">.</span></span><span class="ws13b">item() ]</span></div><div class="t m0 x0 h9 y984 ff1 fs3 fc0 sc0 ls0">唯一的问题是这个方法根本不能工作，事实上，它会产生一个无限递归错误。</div><div class="t m0 x0 h9 y985 ff1 fs3 fc0 sc0 ls3a ws153">关于语法规则本身你可能也会碰到一些棘手的问题。比如，你可能想知道下面这个</div><div class="t m0 x5 h9 y986 ff1 fs3 fc0 sc0 ls0">简单扼语法是否表述得当：</div><div class="t m0 x5 hf y987 ff8 fs5 fc0 sc0 ls0 ws4">expr ::<span class="fc6 ls33">=</span><span class="ws13b">factor { (<span class="ff9 fc9 ls34">&apos;</span><span class="fc9 ws13a">+<span class="ff9 ls34">&apos;</span></span><span class="ffd fc6">|<span class="ff9 fc9 ls34">&apos;</span></span><span class="fc9 ws13a">-<span class="ff9 ls34">&apos;</span></span><span class="ffd fc6">|<span class="ff9 fc9 ls34">&apos;<span class="ff8">*</span><span class="ls0">&apos;</span></span>|<span class="ff9 fc9 ls34">&apos;<span class="ff8">/</span>&apos;</span></span>) factor }<span class="fc6">*</span></span></div><div class="t m0 x5 hf y988 ff8 fs5 fc0 sc0 ls0 ws4">factor ::<span class="fc6 ls32">=<span class="ff9 fc9 ls34">&apos;</span></span><span class="fc9 ws13a">(<span class="ff9 ls33">&apos;</span></span><span class="ws2a3">expression <span class="ff9 fc9 ls34">&apos;</span><span class="fc9 ws13a">)<span class="ff9">&apos;</span></span></span></div><div class="t m0 x15 hf y989 ffd fs5 fc6 sc0 lsbd">|<span class="ff8 fc0 ls0">NUM</span></div><div class="t m0 x0 h9 y616 ff1 fs3 fc0 sc0 ls30 ws138">这个语法看上去没啥问题，但是它却不能察觉到标准四则运算中的运算符优先级<span class="_ _c"></span>。</div><div class="t m0 x5 h7 y98a ff1 fs3 fc0 sc0 ls0 ws459">比如，表<span class="_ _6"></span>达式 <span class="ff6 ws45a">&quot;3 + 4 * 5&quot;<span class="_ _16"> </span></span><span class="ls18 ws45b">会得到 </span><span class="ff4 ws45c">35 </span><span class="ws45d">而<span class="_ _6"></span>不是<span class="_ _6"></span>期望的 <span class="ff4 ws45e">23. </span><span class="wsa0">分<span class="_ _6"></span>开使用<span class="ff4 ws45f">”expr” </span><span class="lsb">和</span><span class="ff4 ws460">”term” </span>规</span></span></div><div class="t m0 x5 h9 y98b ff1 fs3 fc0 sc0 ls0">则可以让它正确的工作。</div><div class="t m0 x0 h7 y98c ff1 fs3 fc0 sc0 ls49 ws461">对于复杂的语法<span class="_ _1"></span>，你最好是选择某个解析工具比如 <span class="ff4 ls0 ws462">PyP<span class="_ _1"></span>arsing <span class="ff1 ls49 ws463">或者是 </span><span class="wsa5">PL<span class="_ _8"></span>Y<span class="ff1 wsa0">。<span class="_ _6"></span>下<span class="_ _6"></span>面</span></span></span></div><div class="t m0 x5 h7 y98d ff1 fs3 fc0 sc0 ls0 ws38">是使用 <span class="ff4 ws427">PL<span class="_ _8"></span>Y <span class="ff1">来重写表达式求值程序的代码：</span></span></div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 ws21d">4.19.<span class="_ _5"> </span>2.19 <span class="ff1 ws42c">实现一个简单的递归下降分析器 </span>75</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
