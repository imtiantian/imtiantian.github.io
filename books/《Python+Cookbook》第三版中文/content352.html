<div id="pf160" class="pf w0 h0" data-page-no="160"><div class="pc pc160 w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg160.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x0 h9 y2a ff1 fs3 fc0 sc0 ls0 ws38">如果你仅仅只是想执行准备步骤，可以使用 <span class="ff6 ws23a">types.prepare<span class="_ _7"> </span>class() </span>。例如：</div><div class="t m0 x5 h10 y24ce ff7 fs5 fca sc0 ls0 ws146">import <span class="fcc">types</span></div><div class="t m0 x5 hf y24cf ff8 fs5 fc0 sc0 ls0 ws4">metaclass, kwargs, ns <span class="fc6 ls32">=</span><span class="ws13a">types<span class="fc6 ls34">.</span>prepare_class(<span class="ff9 fc9 ls34">&apos;</span><span class="fc9">Stock<span class="ff9 ls34">&apos;</span></span></span>, (), {<span class="ff9 fc9 ls34">&apos;</span><span class="fc9 ws13a">metaclass<span class="ff9 ls34">&apos;</span></span><span class="ls33">:</span><span class="fca ws13a">type</span>})</div><div class="t m0 x0 h9 y24d0 ff1 fs3 fc0 sc0 ls19 wsc79">它会查找合适的元类并调用它的 <span class="ff6 ls0 ws3db">prepare<span class="_ _e"> </span>() </span><span class="ws22a">方法。然后这个元类保存它的关键<span class="_ _1"></span></span></div><div class="t m0 x5 h9 y24d1 ff1 fs3 fc0 sc0 ls0">字参数，准备命名空间后被返回。</div><div class="t m0 x0 h7 y7cb ff1 fs3 fc0 sc0 ls0 wsa0">更多信息<span class="ff4 ls83">,</span><span class="ws38">请参考 <span class="ff4 fc3 wsd0">PEP 3115 <span class="fc0 ls83">,</span></span><span class="ws14">以及 <span class="ff4 fc3 wsd0">Python do<span class="_ _6"></span>cumen<span class="_ _1"></span>tation <span class="fc0">.</span></span></span></span></div><div class="t m0 x5 hd y24d2 ff2 fs4 fc4 sc0 ls0 ws211">11.19<span class="_ _e"> </span>9.19 <span class="ff1">在定义的时候初始化类的成员</span></div><div class="t m0 x5 he y16b5 ff2 fs2 fc4 sc0 ls0 wsadf">11.19.1 <span class="ff1">问题</span></div><div class="t m0 x0 h9 y15f5 ff1 fs3 fc0 sc0 ls0">你想在类被定义的时候就初始化一部分类的成员，而不是要等到实例被创建后。</div><div class="t m0 x5 he y24d3 ff2 fs2 fc4 sc0 ls0 wsadf">11.19.2 <span class="ff1">解决方案</span></div><div class="t m0 x0 h9 y24d4 ff1 fs3 fc0 sc0 ls3a ws153">在类定义时就执行初始化或设置操作是元类的一个典型应用场景。本质上讲，一个</div><div class="t m0 x5 h9 y1c48 ff1 fs3 fc0 sc0 ls0">元类会在定义时被触发，这时候你可以执行一些额外的操作。</div><div class="t m0 x0 h9 y24d5 ff1 fs3 fc0 sc0 ls14 wsc7a">下面是一个例子<span class="_ _1"></span>，利用这个思路来创建类似于 <span class="ff6 ls0 ws3a2">collections </span><span class="ws174">模块中的命名元组的<span class="_ _1"></span></span></div><div class="t m0 x5 h9 y24d6 ff1 fs3 fc0 sc0 ls0">类：</div><div class="t m0 x5 h10 y24d7 ff7 fs5 fca sc0 ls0 ws146">import <span class="fcc">operator</span></div><div class="t m0 x5 hf y24d8 ff7 fs5 fca sc0 ls0 ws16a">class <span class="fcc ws156">StructTupleMeta<span class="ff8 fc0 ls34">(</span></span><span class="ff8 ws13a">type<span class="fc0">):</span></span></div><div class="t m0 x15 hf y24d9 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">__init__<span class="fc0 ws15f">(cls, <span class="fc6 ls34">*</span>args, <span class="fc6 ls34">**</span>kwargs):</span></span></div><div class="t m0 x16 hf ye13 ff8 fs5 fca sc0 ls0 ws13a">super<span class="fc0">()<span class="fc6 ls34">.</span>__init__(<span class="fc6 ls34">*</span><span class="ws15f">args, <span class="fc6 ls34">**</span>kwargs)</span></span></div><div class="t m0 x16 hf y24da ff7 fs5 fca sc0 ls0 ws139">for <span class="ff8 fc0 ws13b">n, name </span><span class="ws157">in <span class="ff8 ws13a">enumerate<span class="fc0">(cls<span class="fc6 ls34">.</span>_fields):</span></span></span></div><div class="t m0 x17 hf y24db ff8 fs5 fca sc0 ls0 ws13a">setattr<span class="fc0 ws13b">(cls, name, </span>property<span class="fc0">(operator<span class="fc6 ls34">.</span>itemgetter(n)))</span></div><div class="t m0 x5 hf y24dc ff7 fs5 fca sc0 ls0 ws16a">class <span class="fcc ws156">StructTuple<span class="ff8 fc0 ls34">(</span></span><span class="ff8 ws13a">tuple<span class="fc0 ws13b">, metaclass</span><span class="fc6">=<span class="fc0">StructTupleMeta):</span></span></span></div><div class="t m0 x15 hf y24dd ff8 fs5 fc0 sc0 ls0 ws155">_fields <span class="fc6 ls32">=</span>[]</div><div class="t m0 x15 hf y24de ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">__new__<span class="fc0 ws15f">(cls, <span class="fc6 ls34">*</span>args):</span></span></div><div class="t m0 x16 hf y24df ff7 fs5 fca sc0 ls0 ws157">if <span class="ff8 ws13a">len<span class="fc0 ws145">(args) <span class="fc6 ws159">!= </span></span>len<span class="fc0">(cls<span class="fc6">.</span>_fields):</span></span></div><div class="t m0 x17 hf y24e0 ff7 fs5 fca sc0 ls0 ws16a">raise <span class="ff8 ws13a">ValueError<span class="fc0 ls34">(<span class="ff9 fc9">&apos;</span></span><span class="fc9 ws13b">{} arguments required<span class="ff9 ls34">&apos;<span class="ff8 fc6">.</span></span></span><span class="fc0">format(</span>len<span class="fc0">(cls<span class="fc6">.</span>_fields)))</span></span></div><div class="t m0 x16 hf y24e1 ff7 fs5 fca sc0 ls0 ws146">return <span class="ff8 ws13a">super<span class="fc0">()<span class="fc6 ls34">.</span>__new__(cls,args)</span></span></div><div class="t m0 x0 h9 y24e2 ff1 fs3 fc0 sc0 ls0">这段代码可以用来定义简单的基于元组的数据结构，如下所示：</div><div class="t m0 x5 hf y2498 ff7 fs5 fca sc0 ls0 ws16a">class <span class="fcc ws156">Stock<span class="ff8 fc0">(StructTuple):</span></span></div><div class="t m0 x15 hf y2499 ff8 fs5 fc0 sc0 ls0 ws155">_fields <span class="fc6 ls32">=</span><span class="ls34">[<span class="ff9 fc9">&apos;</span></span><span class="fc9 ws13a">name<span class="ff9 ws13b">&apos;</span></span><span class="ls33">,</span><span class="ff9 fc9 ws13b">&apos;<span class="ff8 ws13a">shares</span><span class="ls34">&apos;</span></span><span class="ls32">,<span class="ff9 fc9 ls34">&apos;</span></span><span class="fc9 ws13a">price<span class="ff9 ls34">&apos;</span></span>]</div><div class="t m0 x5 hf y24e3 ff7 fs5 fca sc0 ls0 ws16a">class <span class="fcc ws156">Point<span class="ff8 fc0">(StructTuple):</span></span></div><div class="t m0 x15 hf y24e4 ff8 fs5 fc0 sc0 ls0 ws155">_fields <span class="fc6 ls32">=</span><span class="ls34">[<span class="ff9 fc9">&apos;</span></span><span class="fc9 ws13a">x<span class="ff9 ls34">&apos;</span></span><span class="ls33">,</span><span class="ff9 fc9 ws13b">&apos;<span class="ff8 ls34">y<span class="ff9">&apos;</span></span></span>]</div><div class="t m0 x0 h9 y24e5 ff1 fs3 fc0 sc0 ls0">下面演示它如何工作：</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 wsae0">11.19.<span class="_ _5"> </span>9.19 <span class="ff1 wsb70">在定义的时候初始化类的成员 </span>343</div><a class="l" href="https://www.python.org/dev/peps/pep-3115/"><div class="d m1" style="border-style:none;position:absolute;left:279.987000px;bottom:983.871000px;width:51.216000px;height:16.821000px;background-color:rgba(255,255,255,0.000001);"></div></a><a class="l" href="https://docs.python.org/3/reference/datamodel.html#metaclasses"><div class="d m1" style="border-style:none;position:absolute;left:415.092000px;bottom:983.871000px;width:117.567000px;height:16.821000px;background-color:rgba(255,255,255,0.000001);"></div></a></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
