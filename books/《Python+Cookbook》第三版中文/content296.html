<div id="pf128" class="pf w0 h0" data-page-no="128"><div class="pc pc128 w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg128.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x15 hf y1e8 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">visit_Negate<span class="fc0">(<span class="fca">self</span><span class="ws4">, node):</span></span></span></div><div class="t m0 x16 hf y1e9 ff8 fs5 fca sc0 ls0 ws13a">self<span class="fc6">.<span class="fc0 ws5a4">unaryop(node, <span class="ff9 fc9 ws13b">&apos;</span></span><span class="fc9">NEG<span class="ff9 ws13b">&apos;</span><span class="fc0">)</span></span></span></div><div class="t m0 x0 h9 y1f52 ff1 fs3 fc0 sc0 ls0">使用示例：</div><div class="t m0 x5 hf y1f53 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls32">s<span class="fc6 ls33">=</span><span class="ls0">StackCode()</span></span></div><div class="t m0 x5 hf y1f54 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls34">s<span class="fc6 ls0 ws13a">.<span class="fc0">generate_code(t4)</span></span></span></div><div class="t m0 x5 hf y1f55 ff8 fs5 fc8 sc0 ls0 ws13a">[(<span class="ff9 ls34">&apos;</span>PUSH<span class="ff9 ls34">&apos;</span><span class="ws13b">, 1), (<span class="ff9 ls34">&apos;</span></span>PUSH<span class="ff9 ws13b">&apos;</span><span class="ws4">, 2), (<span class="ff9 ls34">&apos;</span></span>PUSH<span class="ff9 ls34">&apos;</span><span class="ws13b">, 3), (<span class="ff9 ls34">&apos;</span></span>PUSH<span class="ff9 ls34">&apos;</span><span class="ws4">, 4), (<span class="ff9 ls34">&apos;</span></span>SUB<span class="ff9 ls34">&apos;</span>,),</div><div class="t m0 x5 hf y1f56 ff8 fs5 fc8 sc0 ls34">(<span class="ff9 ls0 ws13b">&apos;</span><span class="ls0 ws13a">MUL<span class="ff9 ws13b">&apos;</span><span class="ws4">,), (</span></span><span class="ff9">&apos;</span><span class="ls0 ws13a">PUSH<span class="ff9 ws13b">&apos;</span><span class="ws4">, 5), (</span></span><span class="ff9">&apos;</span><span class="ls0 ws13a">DIV</span><span class="ff9">&apos;</span><span class="ls0 ws4">,), (<span class="ff9 ws13b">&apos;</span><span class="ws13a">ADD<span class="ff9 ws13b">&apos;</span>,)]</span></span></div><div class="t m0 x5 hf y1f57 ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x5 he y1f58 ff2 fs2 fc4 sc0 ls0 wsadf">10.21.3 <span class="ff1">讨论</span></div><div class="t m0 x0 h7 y1f59 ff1 fs3 fc0 sc0 ls48 wsb56">刚开始的时候你可能会写大量的 <span class="ff4 ls0 wsb57">if/<span class="_ _6"></span>else </span><span class="ws242">语句来实现<span class="_ _1"></span>，这里访问者模式的好处就是</span></div><div class="t m0 x5 h9 y1f5a ff1 fs3 fc0 sc0 ls0 ws14">通过 <span class="ff6 ws1d1">getattr() </span>来获取相应的方法，并利用递归来遍历所有的节点：</div><div class="t m0 x5 hf y1f5b ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">binop<span class="fc0">(<span class="fca">self</span><span class="ws4">, node, instruction):</span></span></span></div><div class="t m0 x15 hf y1f5c ff8 fs5 fca sc0 ls0 ws13a">self<span class="fc6 ls34">.</span><span class="fc0">visit(node<span class="fc6 ls34">.</span>left)</span></div><div class="t m0 x15 hf y1f5d ff8 fs5 fca sc0 ls0 ws13a">self<span class="fc6 ls34">.</span><span class="fc0">visit(node<span class="fc6 ls34">.</span>right)</span></div><div class="t m0 x15 hf y1f5e ff8 fs5 fca sc0 ls0 ws13a">self<span class="fc6 ls34">.</span><span class="fc0">instructions<span class="fc6 ls34">.</span>append((instruction,))</span></div><div class="t m0 x0 h7 y1f5f ff1 fs3 fc0 sc0 ls0 wsb58">还有一点需要指出的是，<span class="_ _1"></span>这种技术也是实现其他语言中 <span class="ff4 wsb59">switch </span><span class="ls187">或</span><span class="ff4 wsb5a">case </span>语句的方式。</div><div class="t m0 x5 h7 y1f60 ff1 fs3 fc0 sc0 ls0 ws38">比如，如果你正在写一个 <span class="ff4 ws86">HTTP </span>框架，你可能会写这样一个请求分发的控制器：</div><div class="t m0 x5 hf y736 ff7 fs5 fca sc0 ls0 ws16a">class <span class="fcc ws156">HTTPHandler<span class="ff8 fc0">:</span></span></div><div class="t m0 x15 hf y1f61 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">handle<span class="fc0 ls34">(</span><span class="fca">self<span class="fc0 ws13b">, request):</span></span></span></div><div class="t m0 x16 hf y1f62 ff8 fs5 fc0 sc0 ls0 ws1f5">methname <span class="fc6 ls33">=<span class="ff9 fc9 ls34">&apos;</span></span><span class="fc9 ws13a">do_<span class="ff9 ls32">&apos;</span><span class="fc6 ls33">+</span><span class="fc0">request<span class="fc6">.</span>request_method</span></span></div><div class="t m0 x16 hf y1f63 ff8 fs5 fca sc0 ls0 ws13a">getattr<span class="fc0 ls34">(</span>self<span class="fc0 ws13b">, methname)(request)</span></div><div class="t m0 x15 hf y1f64 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">do_GET<span class="fc0 ls34">(</span><span class="fca">self<span class="fc0 ws13b">, request):</span></span></span></div><div class="t m0 x16 h10 y1f65 ff7 fs5 fca sc0 ls0">pass</div><div class="t m0 x15 hf y1f66 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">do_POST<span class="fc0 ls34">(</span><span class="fca">self<span class="fc0 ws13b">, request):</span></span></span></div><div class="t m0 x16 h10 y1f67 ff7 fs5 fca sc0 ls0">pass</div><div class="t m0 x15 hf y1f68 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">do_HEAD<span class="fc0 ls34">(</span><span class="fca">self<span class="fc0 ws13b">, request):</span></span></span></div><div class="t m0 x16 h10 y1f69 ff7 fs5 fca sc0 ls0">pass</div><div class="t m0 x0 h9 y1f6a ff1 fs3 fc0 sc0 ls3a ws153">访问者模式一个缺点就是它严重依赖递归，如果数据结构嵌套层次太深可能会有问</div><div class="t m0 x5 h7 y1f6b ff1 fs3 fc0 sc0 ls0 ws14">题，有时候会超过 <span class="ff4 ws5c">Python </span><span class="ws38">的递归深度限制 <span class="ff4 ls1b">(</span></span>参考 <span class="ff6 wsb5b">sys.getrecursionlimit() <span class="ff4 ls1b">)</span></span>。</div><div class="t m0 x0 h7 y1f6c ff1 fs3 fc0 sc0 ls0 wsc">可以参照 <span class="ff4 wsca">8.22 </span>小节，利用生成器或迭代器来实现非递归遍历算法。</div><div class="t m0 x0 h7 y1f6d ff1 fs3 fc0 sc0 ls40 ws180">在跟解析和编译相关的编程中使用访问者模式是非常常见的<span class="_ _c"></span>。<span class="ff4 ls0 wsb5c">Python <span class="ff1 wsb5d">本<span class="_ _6"></span>身<span class="_ _6"></span>的 <span class="ff6">ast</span></span></span></div><div class="t m0 x5 h7 y1f6e ff1 fs3 fc0 sc0 ls0 wsa0">模块值的关注下，可以去看看源码。<span class="ff4 wsca">9.24 </span><span class="wsb5e">小节演示了一个利用 <span class="ff6 wsb5f">ast </span><span class="ws4ad">模块来处理 <span class="ff4">Python</span></span></span></div><div class="t m0 x5 h9 y1f6f ff1 fs3 fc0 sc0 ls0">源代码的例子。</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 wsae0">10.21.<span class="_ _5"> </span>8.21 <span class="ff1 wsb0f">实现访问者模式 </span>287</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
