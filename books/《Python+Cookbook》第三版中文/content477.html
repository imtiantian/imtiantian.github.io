<div id="pf1dd" class="pf w0 h0" data-page-no="1dd"><div class="pc pc1dd w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg1dd.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x0 h7 y2a ff1 fs3 fc0 sc0 ls0 ws1107">它会克隆 <span class="ff4 ws1108">Python </span><span class="ws1109">解释器，<span class="_ _d"></span>包括 <span class="ff4 ws110a">fork </span><span class="ws110b">时的所有程序状态。<span class="_ _d"></span>而在 <span class="ff4 ws110c">Windows </span><span class="wsa0">上，<span class="_ _8"></span>克隆解</span></span></span></div><div class="t m0 x5 h7 y2b ff1 fs3 fc0 sc0 ls0 ws110d">释器时不会克隆状态。<span class="_ _d"></span>实际的 <span class="ff4 ws110e">fork </span><span class="ws110f">操作会在第一次调用 <span class="ff6 ws1110">pool.map() </span><span class="ls203">或</span><span class="ff6">pool.submit()</span></span></div><div class="t m0 x5 h9 y2c ff1 fs3 fc0 sc0 ls0">后发生。</div><div class="t m0 x1f h9 y99 ffe fs3 fc0 sc0 lsbf">•<span class="ff1 ls0">当你混合使用进程池和多线程的时候要特别小心。</span></div><div class="t m0 x0 h7 y2f ff1 fs3 fc0 sc0 ls18 ws1111">你应该在创建任何线程之前先创建并激活进程池（比如在程序启动的 <span class="ff4 ls0 ws1112">main </span><span class="ws110">线程中</span></div><div class="t m0 x5 h9 y30 ff1 fs3 fc0 sc0 ls0 wsa0">创建进程池）<span class="_ _f"></span>。</div><div class="t m0 x5 hd y2f9a ff2 fs4 fc4 sc0 ls0 ws1113">14.9<span class="_ _e"> </span>12.9 Python <span class="ff1">的全局锁问题</span></div><div class="t m0 x5 he y2f9b ff2 fs2 fc4 sc0 ls0 ws212">14.9.1 <span class="ff1">问题</span></div><div class="t m0 x0 h7 y2f9c ff1 fs3 fc0 sc0 ls0 wsc">你已经听说过全局解释器锁 <span class="ff4 wsa5">GIL</span>，担心它会影响到多线程程序的执行性能。</div><div class="t m0 x5 he y2f9d ff2 fs2 fc4 sc0 ls0 ws212">14.9.2 <span class="ff1">解决方案</span></div><div class="t m0 x0 h7 y2443 ff1 fs3 fc0 sc0 ls0 ws1114">尽管 <span class="ff4 ws1115">Python </span><span class="wse8d">完全支持多线程编程，但是解释器的 <span class="ff4 ls204">C</span>语言实现部分在完全并行执行</span></div><div class="t m0 x5 h9 y2f9e ff1 fs3 fc0 sc0 ls1e ws111">时并不是线程安全的<span class="_ _1"></span>。实际上，解释<span class="_ _1"></span>器被一个全局解释器锁保护着，它确保任何<span class="_ _1"></span>时候</div><div class="t m0 x5 h7 y2f9f ff1 fs3 fc0 sc0 ls35 ws238">都只有一个 <span class="ff4 ls0 ws8a5">Python <span class="ff1 wsa0">线程执行。</span><span class="ws1116">GIL </span></span><span class="ws988">最大的问题就是 <span class="ff4 ls0 ws1117">Python </span><span class="ws144">的多线程程序并不能利用</span></span></div><div class="t m0 x5 h7 y2fa0 ff1 fs3 fc0 sc0 ls0 ws1118">多核 <span class="ff4 ws1119">CPU </span><span class="ls2b ws729">的优势（比如一个使用了多个线程的计算密集型程序只会在一个单 </span><span class="ff4 ws1119">CPU </span>上</div><div class="t m0 x5 h9 y2fa1 ff1 fs3 fc0 sc0 ls0 wsa0">面运行）<span class="_ _f"></span>。</div><div class="t m0 x0 h7 y161d ff1 fs3 fc0 sc0 ls49 ws111a">在讨论普通的 <span class="ff4 ls0 ws111b">GIL </span><span class="ws111c">之前<span class="_ _1"></span>，有一点要强调的是 <span class="ff4 ls0 ws111d">GIL </span><span class="ws111e">只会影响到那些严重依赖 <span class="ff4 ls0">CPU</span></span></span></div><div class="t m0 x5 h7 y2792 ff1 fs3 fc0 sc0 ls0 ws111f">的程序（比如计算型的）<span class="_ _f"></span>。如果你的程序大<span class="_ _6"></span>部分只会设计到 <span class="ff4 wsa5">I/O</span><span class="wsa0">，比如网络交互，那么</span></div><div class="t m0 x5 h9 y2793 ff1 fs3 fc0 sc0 ls1e ws111">使用多线程就很合适<span class="_ _1"></span>，因为它们大部分时间都在等待<span class="_ _1"></span>。实际上，你完全可以放心<span class="_ _1"></span>的创</div><div class="t m0 x5 h7 y2fa2 ff1 fs3 fc0 sc0 ls0 ws14">建几千个 <span class="ff4 ws5c">Python </span>线程，现代操作系统运行这么多线程没有任何压力，没啥可担心的。</div><div class="t m0 x0 h7 y2fa3 ff1 fs3 fc0 sc0 ls0 ws47c">而对于<span class="_ _6"></span>依赖 <span class="ff4 ws1120">CPU </span><span class="ls3d ws164">的程序，你需要弄清楚执行的计算的特点。例如，优化底层算法<span class="_ _1"></span></span></div><div class="t m0 x5 h7 y2fa4 ff1 fs3 fc0 sc0 ls0 ws1121">要比使用多线程运行快得多。类似的，由于 <span class="ff4 wsd5e">Python </span><span class="wsa0">是解释执行的，<span class="_ _1"></span>如果你将那些性能</span></div><div class="t m0 x5 h7 y2fa5 ff1 fs3 fc0 sc0 lse ws1122">瓶颈代码移到一个 <span class="ff4 ls20">C</span><span class="wsd8">语言扩展模块中，速度也会提升的很快。如果你要操作数组<span class="_ _1"></span>，那</span></div><div class="t m0 x5 h7 y2fa6 ff1 fs3 fc0 sc0 ls3d wsb67">么使用 <span class="ff4 ls0 ws1123">NumPy <span class="ff1 wsa0">这样的<span class="_ _6"></span>扩展<span class="_ _6"></span>会非常<span class="_ _6"></span>的高<span class="_ _6"></span>效。最后，<span class="_ _6"></span>你还<span class="_ _6"></span>可以考<span class="_ _6"></span>虑下其<span class="_ _6"></span>他可<span class="_ _6"></span>选实现<span class="_ _6"></span>方案，</span></span></div><div class="t m0 x5 h7 y2fa7 ff1 fs3 fc0 sc0 ls0 ws5d9">比<span class="_ _6"></span>如 <span class="ff4 wsa5">PyPy</span><span class="ws1124">，<span class="_ _6"></span>它<span class="_ _6"></span>通过<span class="_ _6"></span>一<span class="_ _6"></span>个 <span class="ff4 ws1125">JIT </span><span class="ls48 ws242">编译器来优化执行效率<span class="_ _6"></span>（<span class="_ _c"></span>不过<span class="_ _6"></span>在写这本书的时候它还不<span class="_ _1"></span></span></span></div><div class="t m0 x5 h7 y1342 ff1 fs3 fc0 sc0 ls0 ws38">能支持 <span class="ff4 ws9c">Python 3</span><span class="wsa0">）<span class="_ _f"></span>。</span></div><div class="t m0 x0 h7 y2fa8 ff1 fs3 fc0 sc0 ls3d ws1126">还有一点要注意的是，线程不是专门用来优化性能的<span class="_ _1"></span>。一个 <span class="ff4 ls0 ws1127">CPU </span><span class="ws164">依赖型程序可能</span></div><div class="t m0 x5 h7 y2b75 ff1 fs3 fc0 sc0 ls2d ws132">会使用线程来管理一个图形用户界面<span class="_ _1"></span>、一个网络连接或其他服务。这时候<span class="_ _c"></span>，<span class="ff4 ls0 ws1128">GIL <span class="ff1 wsa0">会<span class="_ _6"></span>产</span></span></div><div class="t m0 x5 h7 y2b76 ff1 fs3 fc0 sc0 ls6b ws1129">生一些问题，因为如果一个线程长期持有 <span class="ff4 ls0 ws112a">GIL </span><span class="ws112b">的话会导致其他非 <span class="ff4 ls0 ws10e8">CPU </span><span class="ws28f">型线程一直等<span class="_ _1"></span></span></span></div><div class="t m0 x5 h7 y2b77 ff1 fs3 fc0 sc0 lse ws112c">待。事实上<span class="_ _1"></span>，一个写的不好的 <span class="ff4 ls20">C</span><span class="wsd8">语言扩展会导致这个问题更加严重，尽管代码的计算</span></div><div class="t m0 x5 h9 y2fa9 ff1 fs3 fc0 sc0 ls0">部分会比之前运行的更快些。</div><div class="t m0 x0 h7 y2faa ff1 fs3 fc0 sc0 ls13 ws112d">说了这么多<span class="_ _1"></span>，现在想说的是我们有两种策略来解决 <span class="ff4 ls0 ws112e">GIL <span class="ff1 wsa0">的<span class="_ _6"></span>缺<span class="_ _6"></span>点。<span class="_ _6"></span>首先，<span class="_ _6"></span>如<span class="_ _6"></span>果<span class="_ _6"></span>你<span class="_ _6"></span>完</span></span></div><div class="t m0 x5 h7 y2b7a ff1 fs3 fc0 sc0 ls0 ws112f">全<span class="_ _6"></span>工作<span class="_ _6"></span>于 <span class="ff4 ws1130">Python </span><span class="ws1131">环<span class="_ _6"></span>境<span class="_ _6"></span>中，你<span class="_ _6"></span>可<span class="_ _6"></span>以<span class="_ _6"></span>使<span class="_ _6"></span>用 <span class="ff6 ws1132">multiprocessing </span><span class="wsa0">模块<span class="_ _6"></span>来<span class="_ _6"></span>创<span class="_ _6"></span>建<span class="_ _6"></span>一个<span class="_ _6"></span>进<span class="_ _6"></span>程<span class="_ _6"></span>池，<span class="_ _6"></span>并</span></span></div><div class="t m0 x5 h9 y54e ff1 fs3 fc0 sc0 ls0">像协同处理器一样的使用它。例如，加入你有如下的线程代码：</div><div class="t m0 x5 h11 y2fab ffa fs5 fcd sc0 ls0 ws4"># Performs a large calculation (CPU bound)</div><div class="t m0 x5 hf y2fac ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">some_work<span class="fc0">(args):</span></span></div><div class="t m0 x15 hf y2fad ff8 fs5 fc6 sc0 ls0 ws13a">...</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 ws1133">14.9.<span class="_ _36"> </span>12.9 Python <span class="ff1 ws1134">的全局锁问题 </span>468</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
