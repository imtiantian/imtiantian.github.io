<div id="pf156" class="pf w0 h0" data-page-no="156"><div class="pc pc156 w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg156.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x15 h10 y181 ff7 fs5 fc12 sc0 ls0">@classmethod</div><div class="t m0 x15 hf y182 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">__prepare__<span class="fc0 ws13b">(cls, name, bases, </span><span class="fc6">*<span class="fc0 ws4">, debug</span><span class="ls34">=</span><span class="fca">False<span class="fc0 ws13b">, synchronize</span></span><span class="ls34">=</span><span class="fca">False<span class="fc0">):</span></span></span></span></div><div class="t m0 x16 h11 y183 ffa fs5 fcd sc0 ls0 ws13b"># Custom processing</div><div class="t m0 x16 h10 y184 ff7 fs5 fca sc0 ls0">pass</div><div class="t m0 x16 hf y185 ff7 fs5 fca sc0 ls0 ws146">return <span class="ff8 ws13a">super<span class="fc0">()<span class="fc6 ls34">.</span><span class="ws13b">__prepare__(name, bases)</span></span></span></div><div class="t m0 x15 h11 y187 ffa fs5 fcd sc0 ls0 ws13b"># Required</div><div class="t m0 x15 hf y188 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">__new__<span class="fc0 ws4">(cls, name, bases, ns, </span><span class="fc6">*<span class="fc0 ws4">, debug</span><span class="ls34">=</span><span class="fca">False<span class="fc0 ws13b">, synchronize</span></span><span class="ls34">=</span><span class="fca">False<span class="fc0">):</span></span></span></span></div><div class="t m0 x16 h11 y98e ffa fs5 fcd sc0 ls0 ws13b"># Custom processing</div><div class="t m0 x16 h10 y98f ff7 fs5 fca sc0 ls0">pass</div><div class="t m0 x16 hf y990 ff7 fs5 fca sc0 ls0 ws146">return <span class="ff8 ws13a">super<span class="fc0">()<span class="fc6 ls34">.</span><span class="ws4">__new__(cls, name, bases, ns)</span></span></span></div><div class="t m0 x15 h11 y992 ffa fs5 fcd sc0 ls0 ws13b"># Required</div><div class="t m0 x15 hf y993 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">__init__<span class="fc0">(<span class="fca">self</span><span class="ws4">, name, bases, ns, <span class="fc6 ls34">*</span><span class="ws13b">, debug<span class="fc6 ls34">=</span></span></span><span class="fca">False</span><span class="ws4">, synchronize</span><span class="fc6">=<span class="fca">False</span></span>):</span></span></div><div class="t m0 x16 h11 ya70 ffa fs5 fcd sc0 ls0 ws13b"># Custom processing</div><div class="t m0 x16 h10 y994 ff7 fs5 fca sc0 ls0">pass</div><div class="t m0 x16 hf y995 ff8 fs5 fca sc0 ls0 ws13a">super<span class="fc0">()<span class="fc6 ls34">.</span><span class="ws13b">__init__(name, bases, ns)</span></span></div><div class="t m0 x5 he y23d8 ff2 fs2 fc4 sc0 ls0 wsadf">11.15.3 <span class="ff1">讨论</span></div><div class="t m0 x0 h9 y23d9 ff1 fs3 fc0 sc0 ls3a ws153">给一个元类添加可选关键字参数需要你完全弄懂类创建的所有步骤，因为这些参数</div><div class="t m0 x5 h9 y23da ff1 fs3 fc0 sc0 ls0 wsc2f">会被传递给每一个相关的方法。 <span class="ff6 wsc30">prepare<span class="_ _e"> </span>() </span><span class="ls1f ws113">方法在所有类定义开始执行前首先被调</span></div><div class="t m0 x5 h9 y23db ff1 fs3 fc0 sc0 ls1e ws111">用<span class="_ _1"></span>，用来创建类命名空间。通常来讲<span class="_ _c"></span>，这个方法只是简单的返回一个字典或其他映射<span class="_ _1"></span></div><div class="t m0 x5 h9 y23dc ff1 fs3 fc0 sc0 ls0 wsc31">对<span class="_ _6"></span>象。 <span class="ff6 wsc32">new<span class="_ _e"> </span>() </span><span class="ls63 ws21f">方法被用来实例化最终的类对象<span class="_ _1"></span>。它在类的主体被执行完后开始执</span></div><div class="t m0 x5 h9 y23dd ff1 fs3 fc0 sc0 ls0 ws592">行。 <span class="ff6 ws308">init<span class="_ _e"> </span>() </span>方法最后被调用，用来执行其他的一些初始化工作。</div><div class="t m0 x0 h9 y1566 ff1 fs3 fc0 sc0 ls2c wsc33">当我们构造元类的时候，通常只需要定义一个 <span class="ff6 ls0 wsc34">new<span class="_ _e"> </span>() </span><span class="ls15c">或<span class="ff6 ls0 ws9c8">init<span class="_ _e"> </span>() <span class="ff1 wsa0">方法，但<span class="_ _6"></span>不</span></span></span></div><div class="t m0 x5 h9 y23de ff1 fs3 fc0 sc0 ls0 wsa0">是<span class="_ _6"></span>两个<span class="_ _6"></span>都<span class="_ _6"></span>定<span class="_ _6"></span>义。<span class="_ _6"></span>但<span class="_ _6"></span>是，如<span class="_ _6"></span>果<span class="_ _6"></span>需<span class="_ _6"></span>要<span class="_ _6"></span>接<span class="_ _6"></span>受其<span class="_ _6"></span>他<span class="_ _6"></span>的<span class="_ _6"></span>关<span class="_ _6"></span>键<span class="_ _6"></span>字<span class="_ _6"></span>参数<span class="_ _6"></span>的<span class="_ _6"></span>话，<span class="_ _6"></span>这<span class="_ _6"></span>两<span class="_ _6"></span>个方<span class="_ _6"></span>法<span class="_ _6"></span>就<span class="_ _6"></span>要<span class="_ _6"></span>同<span class="_ _6"></span>时提</div><div class="t m0 x5 h9 y23df ff1 fs3 fc0 sc0 ls24 wsc35">供<span class="_ _c"></span>，并且都要提供对应的参数签名<span class="_ _1"></span>。默认的 <span class="ff6 ls0 wsc36">prepare<span class="_ _e"> </span>() </span><span class="ws11d">方法接受任意的关键字参<span class="_ _c"></span></span></div><div class="t m0 x5 h9 y23e0 ff1 fs3 fc0 sc0 ls13 wse5">数<span class="_ _1"></span>，但是会忽略它们，所以只有当这些额外的参数可能会影响到类命名空间的创建时<span class="_ _c"></span></div><div class="t m0 x5 h9 y23e1 ff1 fs3 fc0 sc0 ls0 ws911">你才需要去定义 <span class="ff6 ws308">prepare<span class="_ _e"> </span>() </span>方法。</div><div class="t m0 x0 h9 y23e2 ff1 fs3 fc0 sc0 ls63 ws21f">通过使用强制关键字参数<span class="_ _c"></span>，在类的创建过程中我们必须通过关键字来指定这些参<span class="_ _1"></span></div><div class="t m0 x5 h9 y23e3 ff1 fs3 fc0 sc0 ls0">数。</div><div class="t m0 x0 h9 y23e4 ff1 fs3 fc0 sc0 ls0">使用关键字参数配置一个元类还可以视作对类变量的一种替代方式。例如：</div><div class="t m0 x5 hf y23e5 ff7 fs5 fca sc0 ls0 ws16a">class <span class="fcc ws156">Spam<span class="ff8 fc0 ws13a">(metaclass<span class="fc6">=</span>MyMeta):</span></span></div><div class="t m0 x15 hf y23e6 ff8 fs5 fc0 sc0 ls0 ws15f">debug <span class="fc6 ls33">=</span><span class="fca">True</span></div><div class="t m0 x15 hf y23e7 ff8 fs5 fc0 sc0 ls0 ws208">synchronize <span class="fc6 ls32">=</span><span class="fca">True</span></div><div class="t m0 x15 h10 y23e8 ff7 fs5 fca sc0 ls0">pass</div><div class="t m0 x0 h9 y23e9 ff1 fs3 fc0 sc0 ls3a ws153">将这些属性定义为参数的好处在于它们不会污染类的名称空间，这些属性仅仅只从</div><div class="t m0 x5 h9 y23ea ff1 fs3 fc0 sc0 ls1f ws254">属于类的创建阶段，而不是类中的语句执行阶段。另外，它们在 <span class="ff6 ls0 ws255">prepare<span class="_ _e"> </span>() <span class="ff1 wsa0">方法中</span></span></div><div class="t m0 x5 h9 y21e9 ff1 fs3 fc0 sc0 ls13 wse5">是可以被访问的<span class="_ _1"></span>，因为这个方法会在所有类主体执行前被执行。但是类变量只能在元<span class="_ _c"></span></div><div class="t m0 x5 h9 y23eb ff1 fs3 fc0 sc0 ls0 ws592">类的 <span class="ff6 ws255">new<span class="_ _e"> </span>() </span><span class="ls17a">和</span><span class="ff6 ws308">init<span class="_ _e"> </span>() </span>方法中可见。</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 wsae0">11.15.<span class="_ _5"> </span>9.15 <span class="ff1 wsaf4">定义有可选参数的元类 </span>333</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
