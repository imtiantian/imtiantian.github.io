<div id="pf243" class="pf w0 h0" data-page-no="243"><div class="pc pc243 w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg243.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 he y137 ff2 fs2 fc4 sc0 ls0 ws212">17.7.3 <span class="ff1">讨论</span></div><div class="t m0 x0 h7 y236 ff1 fs3 fc0 sc0 ls18 ws144a">只有当你确保没有 <span class="ff4 ls0 ws4c0">Python C API </span><span class="ws144b">函数在 <span class="ff4 ls245">C</span><span class="ws144c">中执行的时候你才能安全的释放 <span class="ff4 ls0 wsa5">GIL<span class="ff1">。</span></span></span></span></div><div class="t m0 x5 h7 y237 ff4 fs3 fc0 sc0 ls0 ws144d">GIL <span class="ff1 ls18 wsa66">需要被释放的常见的场景是在计算密集型代码中需要在 </span><span class="ls26f">C</span><span class="ff1 wsa0">数组上<span class="_ _6"></span>执行计<span class="_ _6"></span>算（比<span class="_ _6"></span>如</span></div><div class="t m0 x5 h7 y238 ff1 fs3 fc0 sc0 ls8f">在<span class="ff4 ls0 ws144e">n<span class="_ _1"></span>ump<span class="_ _1"></span>y <span class="ff1 ws144f">中）或者是要执行阻塞的 </span><span class="ws1450">I/O <span class="ff1 wsa0">操作时（比如在一个文件描述符上读取或写入</span></span></span></div><div class="t m0 x5 h9 yea6 ff1 fs3 fc0 sc0 ls0 wsa0">时）<span class="_ _f"></span>。</div><div class="t m0 x0 h7 y279 ff1 fs3 fc0 sc0 ls270">当<span class="ff4 ls0 ws1451">GIL </span><span class="ls0 ws1452">被 释 放 后， 其 他<span class="_ _2b"> </span><span class="ff4 ws1453">Python </span>线 程 才 被 允 许 在 解 释 器 中 执 行。</span></div><div class="t m0 x5 h7 y27a ff6 fs3 fc0 sc0 ls0 ws23a">Py<span class="_ _7"> </span>END<span class="_ _16"> </span>ALLOW<span class="_ _7"> </span>THREADS <span class="ff1 ws38">宏会阻塞执行直到调用线程重新获取了 <span class="ff4 wsa5">GIL</span>。</span></div><div class="t m0 x5 hd y187e ff2 fs4 fc4 sc0 ls0 ws1454">17.8<span class="_ _e"> </span>15.8 C <span class="ff1 lsac">和</span><span class="ws73e">Python <span class="ff1">中的线程混用</span></span></div><div class="t m0 x5 he y187f ff2 fs2 fc4 sc0 ls0 ws212">17.8.1 <span class="ff1">问题</span></div><div class="t m0 x0 h7 y1880 ff1 fs3 fc0 sc0 ls2b ws1455">你有一个程序需要混合使用 <span class="ff4 ls0 wsa5">C</span><span class="ls1d6">、<span class="ff4 ls0 wsea1">Python </span></span><span class="ws6b6">和线程，有些线程是在 <span class="ff4 ls271">C</span><span class="ls0 wsa0">中创建的，超<span class="_ _6"></span>出</span></span></div><div class="t m0 x5 h7 y4f6 ff1 fs3 fc0 sc0 ls4">了<span class="ff4 ls0 ws5c">Python </span><span class="ls0 ws63">解释器的控制范围。并且一些线程还使用了 <span class="ff4 wsd0">Python C API </span>中的函数。</span></div><div class="t m0 x5 he y37b7 ff2 fs2 fc4 sc0 ls0 ws212">17.8.2 <span class="ff1">解决方案</span></div><div class="t m0 x0 h7 y37b8 ff1 fs3 fc0 sc0 ls0 ws1456">如<span class="_ _12"></span>果<span class="_ _0"></span>你<span class="_ _12"></span>想<span class="_ _12"></span>将 <span class="ff4 ls269">C</span><span class="ls272">、</span><span class="ff4 ws1457">Python </span><span class="ls224 ws127c">和线程混合在一起<span class="_ _8"></span>，你需要确保正确的初始化和管理<span class="_ _8"></span></span></div><div class="t m0 x5 h7 yaed ff4 fs3 fc0 sc0 ls0 ws7ac">Python <span class="ff1 wsa0">的全<span class="_ _6"></span>局解<span class="_ _6"></span>释器<span class="_ _6"></span>锁（</span><span class="wsa5">GIL<span class="ff1 ls42 ws1458">）<span class="_ _f"></span>。要想这样做，可以将下列代码放到你的 <span class="ff4 ls273">C</span><span class="ls0 wsa0">代码中<span class="_ _6"></span>并</span></span></span></div><div class="t m0 x5 h9 y37b9 ff1 fs3 fc0 sc0 ls0">确保它在任何线程被创建之前被调用。</div><div class="t m0 x5 hf y37ba ff8 fs5 fc0 sc0 ls0 ws4">#include &lt;Python.h&gt;</div><div class="t m0 x19 hf y37bb ff8 fs5 fc0 sc0 ls0">...</div><div class="t m0 x19 hf y37bc ff8 fs5 fc0 sc0 ls0 ws4">if (!PyEval_ThreadsInitialized()) {</div><div class="t m0 x15 hf y2c4 ff8 fs5 fc0 sc0 ls0">PyEval_InitThreads();</div><div class="t m0 x19 hf y37bd ff8 fs5 fc0 sc0 ls0">}</div><div class="t m0 x19 hf y37be ff8 fs5 fc0 sc0 ls0">...</div><div class="t m0 x0 h7 y1a8b ff1 fs3 fc0 sc0 ls0 ws1459">对于任何调用 <span class="ff4 ws1062">Python </span><span class="ws4ad">对象或 <span class="ff4 wsa9f">Python C API </span><span class="ls5">的<span class="ff4 ls25e">C</span></span><span class="wsa0">代码，确保你首先已经正确地获</span></span></div><div class="t m0 x5 h7 yc79 ff1 fs3 fc0 sc0 ls2b ws145a">取和释放了 <span class="ff4 ls0 wsa5">GIL</span>。这可以用 <span class="ff6 ls0 ws266">PyGILState<span class="_ _7"> </span>Ensure() </span><span class="ls128">和<span class="ff6 ls0 ws874">PyGILState Release() <span class="ff1 wsa0">来<span class="_ _6"></span>做到，</span></span></span></div><div class="t m0 x5 h9 y37bf ff1 fs3 fc0 sc0 ls0">如下所示：</div><div class="t m0 x5 hf y37c0 ff8 fs5 fc0 sc0 ls0">...</div><div class="t m0 x5 hf y37c1 ff8 fs5 fc0 sc0 ls0 ws4">/* Make sure we own the GIL */</div><div class="t m0 x5 hf y37c2 ff8 fs5 fc0 sc0 ls0 ws4">PyGILState_STATE state = PyGILState_Ensure();</div><div class="t m0 x5 hf y37c3 ff8 fs5 fc0 sc0 ls0 ws4">/* Use functions in the interpreter */</div><div class="t m0 x5 hf y37c4 ff8 fs5 fc0 sc0 ls0">...</div><div class="t m0 x5 hf y37c5 ff8 fs5 fc0 sc0 ls0 ws4">/* Restore previous GIL state and return */</div><div class="t m0 x5 hf y37c6 ff8 fs5 fc0 sc0 ls0">PyGILState_Release(state);</div><div class="t m0 x5 hf y37c7 ff8 fs5 fc0 sc0 ls0">...</div><div class="t m0 x0 h7 y149a ff1 fs3 fc0 sc0 ls0 wsc">每次调用 <span class="ff6 ws1f3">PyGILState<span class="_ _7"> </span>Ensure() </span><span class="ws38">都要相应的调用 <span class="ff6 ws1d1">PyGILState<span class="_ _16"> </span>Release() <span class="ff4">.</span></span></span></div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 ws1133">17.8.<span class="_ _36"> </span>15.8 C <span class="ff1 ls7f">和</span><span class="wscda">Python <span class="ff1 ws145b">中的线程混用 </span>570</span></div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
