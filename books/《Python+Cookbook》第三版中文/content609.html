<div id="pf261" class="pf w0 h0" data-page-no="261"><div class="pc pc261 w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg261.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 hf y1e8 ff8 fs5 fc0 sc0 ls0 ws4">PyObject *obj = PyUnicode_DecodeFSDefaultAndSize(filename, filename_len);</div><div class="t m0 x5 he y3a6e ff2 fs2 fc4 sc0 ls0 wsadf">17.17.3 <span class="ff1">讨论</span></div><div class="t m0 x0 h7 y3a6f ff1 fs3 fc0 sc0 ls18 ws15d3">以可移植方式来处理文件名是一个很棘手的问题，最后交由 <span class="ff4 ls0 ws453">Python <span class="ff1 wsa0">来处理。<span class="_ _6"></span>如果</span></span></div><div class="t m0 x5 h7 y3a70 ff1 fs3 fc0 sc0 ls0 ws8c4">你在扩展代码中使用本节的技术，文件名的处理方式和和 <span class="ff4 ws347">Python </span><span class="wsa0">中是一致的。<span class="_ _1"></span>包括编</span></div><div class="t m0 x5 h7 y3a71 ff1 fs3 fc0 sc0 lsb">码<span class="ff4 ls0 wsa5">/<span class="ff1">界面字节，处理坏字符，代理转换和其他复杂情况。</span></span></div><div class="t m0 x5 hd y3a72 ff2 fs4 fc4 sc0 ls0 wsd91">17.18<span class="_ _e"> </span>15.18 <span class="ff1 ws357">传递已打开的文件给 </span><span class="ls23d">C</span><span class="ff1">扩展</span></div><div class="t m0 x5 he y2524 ff2 fs2 fc4 sc0 ls0 wsadf">17.18.1 <span class="ff1">问题</span></div><div class="t m0 x0 h7 y3a73 ff1 fs3 fc0 sc0 ls0 ws1114">你在 <span class="ff4 ws1115">Python </span><span class="ws709">中有一个打开的文件对象，但是需要将它传给要使用这个文件的 <span class="ff4 ls2a9">C</span>扩</span></div><div class="t m0 x5 h9 y3a74 ff1 fs3 fc0 sc0 ls0">展。</div><div class="t m0 x5 he y3a75 ff2 fs2 fc4 sc0 ls0 wsadf">17.18.2 <span class="ff1">解决方案</span></div><div class="t m0 x0 h9 y3a76 ff1 fs3 fc0 sc0 ls0 ws14">要将一个文件转换为一个整型的文件描述符，使用 <span class="ff6 ws1f3">PyFile<span class="_ _7"> </span>FromFd() </span>，如下：</div><div class="t m0 x5 hf y3a77 ff8 fs5 fc0 sc0 ls0 ws4">PyObject *fobj;<span class="_ _1a"> </span>/* File object (already obtained somehow) */</div><div class="t m0 x5 hf y3a78 ff8 fs5 fc0 sc0 ls0 ws4">int fd = PyObject_AsFileDescriptor(fobj);</div><div class="t m0 x5 hf y3a79 ff8 fs5 fc0 sc0 ls0 ws4">if (fd &lt; 0) {</div><div class="t m0 x3c hf y1ad6 ff8 fs5 fc0 sc0 ls0 ws4">return NULL;</div><div class="t m0 x5 hf y3a7a ff8 fs5 fc0 sc0 ls0">}</div><div class="t m0 x0 h9 y3a7b ff1 fs3 fc0 sc0 ls10 ws197">结果文件描述符是通过调用 <span class="ff6 ls0 ws3e1">fobj <span class="ff1 ws3a8">中的 </span><span class="ws5ed">fileno() </span></span><span class="wsdf">方法获得的。因此<span class="_ _1"></span>，任何以这种</span></div><div class="t m0 x5 h9 y3a7c ff1 fs3 fc0 sc0 ls0 wsa0">方<span class="_ _6"></span>式<span class="_ _6"></span>暴<span class="_ _6"></span>露<span class="_ _6"></span>给<span class="_ _6"></span>一<span class="_ _6"></span>个<span class="_ _0"></span>描述<span class="_ _6"></span>器<span class="_ _0"></span>的对<span class="_ _0"></span>象都<span class="_ _6"></span>适<span class="_ _0"></span>用（比<span class="_ _6"></span>如<span class="_ _0"></span>文件、<span class="_ _0"></span>套接<span class="_ _6"></span>字<span class="_ _0"></span>等）<span class="_ _f"></span>。一<span class="_ _6"></span>旦<span class="_ _0"></span>你有<span class="_ _6"></span>了<span class="_ _0"></span>这个<span class="_ _6"></span>描<span class="_ _0"></span>述</div><div class="t m0 x5 h7 y3a7d ff1 fs3 fc0 sc0 ls0 ws14">器，它就能被传递给多个低级的可处理文件的 <span class="ff4 ls8">C</span>函数。</div><div class="t m0 x0 h7 y3a7e ff1 fs3 fc0 sc0 ls2aa ws15d4">如果你需要转换一个整型文件描述符为一个 <span class="ff4 ls0 ws15d5">Python <span class="ff1 ws15d6">对 象， 适 用 下 面 的</span></span></div><div class="t m0 x5 h7 y3a7f ff6 fs3 fc0 sc0 ls0 ws1f3">PyFile<span class="_ _7"> </span>FromFd() <span class="ff4">:</span></div><div class="t m0 x5 hf y32ec ff8 fs5 fc0 sc0 ls0 ws4">int fd;<span class="_ _1a"> </span>/* Existing file descriptor (already open) */</div><div class="t m0 x5 hf y3a80 ff8 fs5 fc0 sc0 ls0 ws4">PyObject *fobj = PyFile_FromFd(fd, &quot;filename&quot;,&quot;r&quot;,-1,NULL,NULL,NULL,1);</div><div class="t m0 x0 h7 y3a81 ff6 fs3 fc0 sc0 ls0 wsc6f">PyFile FromFd() <span class="ff1 ls22 ws15d7">的参数对应内置的 </span><span class="ws3cf">open() <span class="ff1 wsa0">函数。<span class="_ _6"></span><span class="ff4 ws15d8">NULL </span>表<span class="_ _6"></span>示编<span class="_ _6"></span>码、<span class="_ _6"></span>错误<span class="_ _6"></span>和<span class="_ _6"></span>换行</span></span></div><div class="t m0 x5 h9 y3a82 ff1 fs3 fc0 sc0 ls0">参数使用默认值。</div><div class="t m0 x5 he y3a83 ff2 fs2 fc4 sc0 ls0 wsadf">17.18.3 <span class="ff1">讨论</span></div><div class="t m0 x0 h7 y3a84 ff1 fs3 fc0 sc0 ls35 ws48d">如果将 <span class="ff4 ls0 ws8a5">Python </span><span class="ws52e">中的文件对象传给 <span class="ff4 ls269">C</span><span class="ls0 wsa0">，有一些注意<span class="_ _6"></span>事项。首先，<span class="ff4 ws8a5">Python </span><span class="ws8a4">通过 <span class="ff6 ws15d9">io </span>模</span></span></span></div><div class="t m0 x5 h7 y3a85 ff1 fs3 fc0 sc0 ls0 ws12e4">块执行自己的 <span class="ff4 ws15da">I/O </span><span class="ws15db">缓<span class="_ _6"></span>冲。在传递任何类<span class="_ _6"></span>型的文件描述符给 <span class="ff4 ls2ab">C</span><span class="wsa0">之<span class="_ _6"></span>前，你都要首先在相<span class="_ _6"></span>应</span></span></div><div class="t m0 x5 h7 y1164 ff1 fs3 fc0 sc0 ls0 ws38">文件对象上刷新 <span class="ff4 ws59">I/O </span>缓冲。不然的话，你会打乱文件系统上面的数据。</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 wsd97">17.18.<span class="_ _36"> </span>15.18 <span class="ff1 ws36c">传递已打开的文件给 </span><span class="ls246">C</span><span class="ff1 ws15dc">扩展 </span>600</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
