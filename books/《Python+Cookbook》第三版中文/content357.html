<div id="pf165" class="pf w0 h0" data-page-no="165"><div class="pc pc165 w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg165.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 hf y1ab ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls32">e<span class="fc6 ls33">=</span><span class="ls0">Date()</span></span></div><div class="t m0 x5 hf y1ac ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls34">e<span class="fc6 ls0 ws13a">.<span class="fc0">year</span></span></span></div><div class="t m0 x5 hf y1ad ff8 fs5 fc8 sc0 ls0">2012</div><div class="t m0 x5 hf y1ae ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls34">e<span class="fc6 ls0 ws13a">.<span class="fc0">month</span></span></span></div><div class="t m0 x5 hf y1af ff8 fs5 fc8 sc0 ls0">12</div><div class="t m0 x5 hf y1b0 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls34">e<span class="fc6 ls0 ws13a">.<span class="fc0">day</span></span></span></div><div class="t m0 x5 hf y355 ff8 fs5 fc8 sc0 ls0">3</div><div class="t m0 x5 hf y410 ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x5 he y2522 ff2 fs2 fc4 sc0 ls0 wsadf">11.20.3 <span class="ff1">讨论</span></div><div class="t m0 x0 h9 y2523 ff1 fs3 fc0 sc0 ls0 wsa0">坦白来讲，相对于通常<span class="_ _6"></span>的代码而已本节使用到了<span class="_ _6"></span>很多的魔法代码。但是，它<span class="_ _6"></span>却能让</div><div class="t m0 x5 h9 y1bfa ff1 fs3 fc0 sc0 ls1e ws111">我们深入理解元类和描述器的底层工作原理<span class="_ _c"></span>，并能加深对这些概念的印象。因此<span class="_ _c"></span>，<span class="_ _6"></span>就<span class="_ _1"></span></div><div class="t m0 x5 h9 y2524 ff1 fs3 fc0 sc0 lsd3 ws4b2">算你并不会立即去应用本节的技术<span class="_ _c"></span>，它的<span class="_ _6"></span>一些底层思想却会影响到其它涉及到元类<span class="_ _c"></span>、<span class="_ _1"></span></div><div class="t m0 x5 h9 y1f5a ff1 fs3 fc0 sc0 ls0">描述器和函数注解的编程技术。</div><div class="t m0 x0 h9 yb2e ff1 fs3 fc0 sc0 ls180 wsb15">本节的实现中的主要思路其实是很简单的<span class="_ _f"></span>。<span class="_ _6"></span><span class="ff6 ls0 wsc90">MutipleMeta </span>元类使用它的<span class="_ _2d"></span></div><div class="t m0 x32 h9 y145 ff6 fs3 fc0 sc0 ls0 wsc91">prepare<span class="_ _e"> </span>() <span class="ff1 ls52 wsc92">方法来提供一个作为 </span><span class="wsc93">MultiDict <span class="ff1 ls52 ws276">实例的自定义字典<span class="_ _8"></span>。这个跟普通字<span class="_ _d"></span></span></span></div><div class="t m0 x5 h9 y2525 ff1 fs3 fc0 sc0 ls0 ws5dd">典不一样的是， <span class="ff6 wsc94">MultiDict </span><span class="wsa0">会在元素被设置的时候检查是否已经存在，如果存在的话，</span></div><div class="t m0 x5 h9 y2526 ff1 fs3 fc0 sc0 ls0 ws38">重复的元素会在 <span class="ff6 ws133">MultiMethod </span>实例中合并。</div><div class="t m0 x0 h9 y2527 ff6 fs3 fc0 sc0 ls0 wsc95">MultiMethod <span class="ff1 ls1a3 wsc96">实例通过构建从类型签名到函数的映射来收集方法<span class="_ _1d"></span>。在这个<span class="_ _1f"></span></span></div><div class="t m0 x5 h9 y2528 ff1 fs3 fc0 sc0 ls11d ws6e9">构建过程中<span class="_ _1d"></span>，函数注解被用来收集这些签名然后构建这个映射<span class="_ _1f"></span>。<span class="_ _6"></span>这个过程在<span class="_ _1d"></span></div><div class="t m0 x5 h9 y2529 ff6 fs3 fc0 sc0 ls0 wsc97">MultiMethod.register() <span class="ff1 ls1a4 wsc98">方法中实现<span class="_ _d"></span>。这种映射的一个关键特点是对于多个方法<span class="_ _d"></span>，<span class="_ _d"></span></span></div><div class="t m0 x5 h9 y252a ff1 fs3 fc0 sc0 ls0">所有参数类型都必须要指定，否则就会报错。</div><div class="t m0 x0 h9 y252b ff1 fs3 fc0 sc0 ls13 wsc99">为了让 <span class="ff6 ls0 ws84e">MultiMethod <span class="ff1 wsc9a">实<span class="_ _6"></span>例模<span class="_ _6"></span>拟<span class="_ _6"></span>一<span class="_ _6"></span>个<span class="_ _6"></span>调<span class="_ _6"></span>用，它<span class="_ _6"></span>的 </span><span class="wsc9b">call<span class="_ _e"> </span>() <span class="ff1 wsa0">方<span class="_ _6"></span>法<span class="_ _6"></span>被<span class="_ _6"></span>实<span class="_ _6"></span>现了。<span class="_ _6"></span>这<span class="_ _6"></span>个<span class="_ _6"></span>方</span></span></span></div><div class="t m0 x5 h7 y252c ff1 fs3 fc0 sc0 ls0 wsc9c">法从<span class="_ _6"></span>所有<span class="_ _6"></span>排<span class="_ _6"></span>除 <span class="ff6 wsc9d">slef </span><span class="ls12 wsc9e">的参数中构建一个类型元组<span class="_ _1"></span>，在内部 <span class="ff4 ls0 wsc9f">map </span><span class="wse4">中查找这个方法，然后<span class="_ _1"></span></span></span></div><div class="t m0 x5 h9 y252d ff1 fs3 fc0 sc0 ls35 ws8ef">调用相应的方法。为了能让 <span class="ff6 ls0 wsafe">MultiMethod </span><span class="wsca0">实例在类定义时正确操作， <span class="ff6 ls0 ws359">get<span class="_ _e"> </span>() </span><span class="ws144">是必须</span></span></div><div class="t m0 x5 h9 y206d ff1 fs3 fc0 sc0 ls0">得实现的。它被用来构建正确的绑定方法。比如：</div><div class="t m0 x5 hf y480 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls32">b<span class="fc6 ls33">=</span><span class="ls34">s<span class="fc6 ls0 ws13a">.<span class="fc0">bar</span></span></span></span></div><div class="t m0 x5 hf y252e ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0">b</span></div><div class="t m0 x5 hf y252f ff8 fs5 fc8 sc0 ls0 ws4">&lt;bound method Spam.bar of &lt;__main__.Spam object at 0x1006a46d0&gt;&gt;</div><div class="t m0 x5 hf y2530 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls34">b<span class="fc6 ls0 ws13a">.<span class="fc0">__self__</span></span></span></div><div class="t m0 x5 hf y2531 ff8 fs5 fc8 sc0 ls0 ws4">&lt;__main__.Spam object at 0x1006a46d0&gt;</div><div class="t m0 x5 hf y2532 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls34">b<span class="fc6 ls0 ws13a">.<span class="fc0">__func__</span></span></span></div><div class="t m0 x5 hf y2533 ff8 fs5 fc8 sc0 ls0 ws4">&lt;__main__.MultiMethod object at 0x1006a4d50&gt;</div><div class="t m0 x5 hf y2534 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws13a">b(<span class="fc7 ls34">2</span><span class="ls33">,</span><span class="fc7">3</span>)</span></div><div class="t m0 x5 hf y2535 ff8 fs5 fc8 sc0 ls0 ws4">Bar 1: 2 3</div><div class="t m0 x5 hf y2536 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws13a">b(<span class="ff9 fc9 ls34">&apos;</span><span class="fc9">hello<span class="ff9 ws13b">&apos;</span></span>)</span></div><div class="t m0 x5 hf y2537 ff8 fs5 fc8 sc0 ls0 ws4">Bar 2: hello 0</div><div class="t m0 x5 hf y2538 ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x0 h9 y2539 ff1 fs3 fc0 sc0 ls0">不过本节的实现还有一些限制，其中一个是它不能使用关键字参数。例如：</div><div class="t m0 x5 hf y177a ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls34">s<span class="fc6 ls0 ws13a">.<span class="fc0">bar(x</span><span class="ls34">=</span><span class="fc7">2<span class="fc0 ws4">, y</span></span>=</span><span class="fc7">3</span><span class="ls0">)</span></span></div><div class="t m0 x5 hf y253a ff8 fs5 fce sc0 ls0 ws4">Traceback (most recent call last):</div><div class="t m0 x15 hf y253b ff8 fs5 fc0 sc0 ls0 ws13c">File <span class="fc9 ws13a">&quot;&lt;stdin&gt;&quot;</span><span class="ws145">, line <span class="fc7 ls34">1</span><span class="ls32">,</span><span class="ff7 fca ws160">in </span><span class="fc6 ws13a">&lt;<span class="fc0">module</span>&gt;</span></span></div><div class="t m0 x5 hf y253c ff8 fs5 fc2 sc0 ls0 ws13a">TypeError<span class="fc0 ws4">: __call__() got an unexpected keyword argument <span class="ff9 ls34">&apos;<span class="ff8">y</span><span class="ls0">&apos;</span></span></span></div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 wsae0">11.20.<span class="_ _5"> </span>9.20 <span class="ff1 wsc0a">利用函数注解实现方法重载 </span>348</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
