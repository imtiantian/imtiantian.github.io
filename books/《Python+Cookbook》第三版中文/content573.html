<div id="pf23d" class="pf w0 h0" data-page-no="23d"><div class="pc pc23d w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg23d.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 h7 y2a ff1 fs3 fc0 sc0 ls0 ws14">中保存这个胶囊，例如 <span class="ff6 ws15e">sample.<span class="_ _7"> </span>point<span class="_ _16"> </span>api <span class="ff4">.</span></span></div><div class="t m0 x0 h7 y76 ff1 fs3 fc0 sc0 ls10 wsdf">其他模块能够在导入时获取到这个属性并提取底层的指针<span class="_ _1"></span>。事实上，<span class="ff4 ls0 ws49f">Python <span class="ff1 wsa0">提供</span></span></div><div class="t m0 x5 h9 y8dd ff1 fs3 fc0 sc0 ls267">了<span class="ff6 ls0 ws140c">PyCapsule<span class="_ _7"> </span>Import() </span><span class="ls0 wsa0">工具函数，为了完成所有的步骤。你只需提供属性的名字即可</span></div><div class="t m0 x38 h7 y99 ff1 fs3 fc0 sc0 ls0 ws38">（比如 <span class="ff4 ws140d">sample. p<span class="_ _6"></span>oin<span class="_ _1"></span>t api<span class="ff1 wsa0">）<span class="_ _f"></span>，然后他就会一次性找到胶囊对象并提取出指针来。</span></span></div><div class="t m0 x0 h7 y2f ff1 fs3 fc0 sc0 ls13 ws140e">在将被导出函数变为其他模块中普通函数时<span class="_ _1"></span>，有一些 <span class="ff4 ls263">C</span><span class="ls0 wsa0">编程<span class="_ _6"></span>陷<span class="_ _6"></span>阱<span class="_ _6"></span>需<span class="_ _6"></span>要指<span class="_ _6"></span>出<span class="_ _6"></span>来。<span class="_ _6"></span>在</span></div><div class="t m0 x5 h9 y30 ff6 fs3 fc0 sc0 ls0 wscdf">pysample.h <span class="ff1 ws140f">文<span class="_ _6"></span>件<span class="_ _6"></span>中，<span class="_ _6"></span>一<span class="_ _6"></span>个 </span><span class="ws27d">point api <span class="ff1 ls6f ws2a7">指针被用来指向在导出模块中被初始化的方法</span></span></div><div class="t m0 x5 h9 y31 ff1 fs3 fc0 sc0 ls0 ws1410">表。一<span class="_ _6"></span>个<span class="_ _6"></span>相关<span class="_ _6"></span>的<span class="_ _6"></span>函<span class="_ _6"></span>数 <span class="ff6 ws2a1">import sample() </span><span class="wsa0">被用<span class="_ _6"></span>来<span class="_ _6"></span>指向<span class="_ _6"></span>胶<span class="_ _6"></span>囊导<span class="_ _6"></span>入<span class="_ _6"></span>并初<span class="_ _6"></span>始<span class="_ _6"></span>化这<span class="_ _6"></span>个<span class="_ _6"></span>指<span class="_ _6"></span>针。这<span class="_ _6"></span>个</span></div><div class="t m0 x5 h9 y32 ff1 fs3 fc0 sc0 ls16 wsf3">函数必须在任何函数被使用之前被调用<span class="_ _c"></span>。通常来讲<span class="_ _1"></span>，它会在模块初始化时被调用到<span class="_ _1"></span>。<span class="_ _c"></span></div><div class="t m0 x5 h7 y33 ff1 fs3 fc0 sc0 ls0 wsa0">最后，<span class="ff4 ls245">C</span><span class="ls18 ws1411">的预处理宏被定义，被用来通过方法表去分发这些 </span><span class="ff4 ws1412">API </span><span class="ls18 ws110">函数。用户只需要使</span></div><div class="t m0 x5 h9 y34 ff1 fs3 fc0 sc0 ls0">用这些原始函数名称即可，不需要通过宏去了解其他信息。</div><div class="t m0 x0 h9 y278e ff1 fs3 fc0 sc0 ls68 ws23f">最后，还有一个重要的原因让你去使用这个技术来链接模块—<span class="_ _8"></span>—它非常简单并且可</div><div class="t m0 x5 h9 y978 ff1 fs3 fc0 sc0 ls13 wse5">以使得各个模块很清晰的解耦<span class="_ _1"></span>。如果你不想使用本机的技术，那你就必须使用共享库<span class="_ _c"></span></div><div class="t m0 x5 h7 y9f ff1 fs3 fc0 sc0 ls3d ws1413">的高级特性和动态加载器来链接模块。例如<span class="_ _1"></span>，将一个普通的 <span class="ff4 ls0 ws1414">API </span><span class="ws164">函数放入一个共享库</span></div><div class="t m0 x5 h9 ya0 ff1 fs3 fc0 sc0 ls1e ws111">并确保所有扩展模块链接到那个共享库<span class="_ _1"></span>。这种方法确实可行<span class="_ _1"></span>，但是它相对繁琐<span class="_ _1"></span>，特别</div><div class="t m0 x5 h7 ya1 ff1 fs3 fc0 sc0 ls0 ws528">是在大型系统中。本节演示了如何通过 <span class="ff4 wse61">Python </span>的普通导入机制和仅仅几个胶囊调用来</div><div class="t m0 x5 h9 ya2 ff1 fs3 fc0 sc0 ls1e ws111">将多个模块链接起来的魔法<span class="_ _1"></span>。对于模块的编译<span class="_ _1"></span>，你只需要定义头文件，而不需要<span class="_ _1"></span>考虑</div><div class="t m0 x5 h9 ya3 ff1 fs3 fc0 sc0 ls0">函数库的内部细节。</div><div class="t m0 x0 h7 y72 ff1 fs3 fc0 sc0 ls0 wsc">更多关于利用 <span class="ff4 ws9c">C API </span><span class="ws14">来构造扩展模块的信息可以参考 <span class="ff4 fc3 ws5c">Python <span class="ff1">的文档</span></span></span></div><div class="t m0 x5 hd y3730 ff2 fs4 fc4 sc0 ls0 ws211">17.6<span class="_ _e"> </span>15.6 <span class="ff1 lsac">从</span><span class="ls23d">C</span><span class="ff1 ws7d2">语言中调用 </span><span class="wsce8">Python <span class="ff1">代码</span></span></div><div class="t m0 x5 he y3731 ff2 fs2 fc4 sc0 ls0 ws212">17.6.1 <span class="ff1">问题</span></div><div class="t m0 x0 h7 y3732 ff1 fs3 fc0 sc0 ls0 wsa4d">你想<span class="_ _6"></span>在 <span class="ff4 ls268">C</span><span class="ls12 ws1415">中安全的执行某个 </span><span class="ff4 wsd26">Python </span><span class="ls12 ws1415">调用并返回结果给 <span class="ff4 ls269">C</span></span><span class="ws1416">。例<span class="_ _6"></span>如，<span class="_ _6"></span>你想<span class="_ _6"></span>在 <span class="ff4 ls268">C</span><span class="wsa0">语言</span></span></div><div class="t m0 x5 h7 y3733 ff1 fs3 fc0 sc0 ls0 ws38">中使用某个 <span class="ff4 ws5c">Python </span>函数作为一个回调。</div><div class="t m0 x5 he y3734 ff2 fs2 fc4 sc0 ls0 ws212">17.6.2 <span class="ff1">解决方案</span></div><div class="t m0 x0 h7 y3735 ff1 fs3 fc0 sc0 ls115">在<span class="ff4 ls207">C</span><span class="ls0 ws1417">语言<span class="_ _6"></span>中<span class="_ _6"></span>调用 <span class="ff4 ws1345">Python </span></span><span class="ls6b ws1418">非常简单，不过设计到一些小窍门。下面的 <span class="ff4 ls240">C</span><span class="ws28f">代码告诉<span class="_ _c"></span></span></span></div><div class="t m0 x5 h9 y3736 ff1 fs3 fc0 sc0 ls0">你怎样安全的调用：</div><div class="t m0 x5 hf y3737 ff8 fs5 fc0 sc0 ls0 ws4">#include &lt;Python.h&gt;</div><div class="t m0 x5 hf y3738 ff8 fs5 fc0 sc0 ls0 ws4">/* Execute func(x,y) in the Python interpreter.<span class="_ _29"> </span>The</div><div class="t m0 x3c hf y3739 ff8 fs5 fc0 sc0 ls0 ws4">arguments and return result of the function must</div><div class="t m0 x3c hf y373a ff8 fs5 fc0 sc0 ls0 ws4">be Python floats */</div><div class="t m0 x5 hf y373b ff8 fs5 fc0 sc0 ls0 ws4">double call_func(PyObject *func, double x, double y) {</div><div class="t m0 x19 hf y2539 ff8 fs5 fc0 sc0 ls0 ws4">PyObject *args;</div><div class="t m0 x19 hf y373c ff8 fs5 fc0 sc0 ls0 ws4">PyObject *kwargs;</div><div class="t m0 x19 hf y373d ff8 fs5 fc0 sc0 ls0 ws4">PyObject *result = 0;</div><div class="t m0 x19 hf y373e ff8 fs5 fc0 sc0 ls0 ws4">double retval;</div><div class="t m0 x19 hf y373f ff8 fs5 fc0 sc0 ls0 ws4">/* Make sure we own the GIL */</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 ws21d">17.6.<span class="_ _36"> </span>15.6 <span class="ff1 ls81">从</span><span class="ls260">C</span><span class="ff1 ws7da">语言中调用 </span><span class="wscda">Python <span class="ff1 ws42c">代码 </span>564</span></div><a class="l" href="http://docs.python.org/3/extending/extending.html"><div class="d m1" style="border-style:none;position:absolute;left:564.042000px;bottom:720.174000px;width:77.326000px;height:16.821000px;background-color:rgba(255,255,255,0.000001);"></div></a></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
