<div id="pf14f" class="pf w0 h0" data-page-no="14f"><div class="pc pc14f w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg14f.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 he y137 ff2 fs2 fc4 sc0 ls0 wsadf">11.12.3 <span class="ff1">讨论</span></div><div class="t m0 x0 h9 y236 ff1 fs3 fc0 sc0 ls0 wsa0">类装<span class="_ _6"></span>饰<span class="_ _6"></span>器通<span class="_ _6"></span>常<span class="_ _6"></span>可<span class="_ _6"></span>以作<span class="_ _6"></span>为<span class="_ _6"></span>其他<span class="_ _6"></span>高<span class="_ _6"></span>级技<span class="_ _6"></span>术<span class="_ _6"></span>比如<span class="_ _6"></span>混<span class="_ _6"></span>入或<span class="_ _6"></span>元<span class="_ _6"></span>类<span class="_ _6"></span>的一<span class="_ _6"></span>种<span class="_ _6"></span>非常<span class="_ _6"></span>简<span class="_ _6"></span>洁的<span class="_ _6"></span>替<span class="_ _6"></span>代方<span class="_ _6"></span>案。</div><div class="t m0 x5 h9 y237 ff1 fs3 fc0 sc0 ls0">比如，上面示例中的另外一种实现使用到继承：</div><div class="t m0 x5 hf y231b ff7 fs5 fca sc0 ls0 ws16a">class <span class="fcc ws156">LoggedGetattribute<span class="ff8 fc0">:</span></span></div><div class="t m0 x15 hf y231c ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">__getattribute__<span class="fc0 ls34">(</span><span class="fca">self<span class="fc0 ws4">, name):</span></span></span></div><div class="t m0 x16 hf y231d ff7 fs5 fca sc0 ls0 ws156">print<span class="ff8 fc0 ls34">(<span class="ff9 fc9">&apos;<span class="ff8 ls0 ws13a">getting:<span class="ff9 ws13b">&apos;</span><span class="fc0 ws4">, name)</span></span></span></span></div><div class="t m0 x16 hf y2113 ff7 fs5 fca sc0 ls0 ws146">return <span class="ff8 ws13a">super<span class="fc0">()<span class="fc6 ls34">.</span>__getattribute__(name)</span></span></div><div class="t m0 x5 h11 y2115 ffa fs5 fcd sc0 ls0 ws4"># Example:</div><div class="t m0 x5 hf y231e ff7 fs5 fca sc0 ls0 ws16a">class <span class="fcc ls34">A</span><span class="ff8 fc0">(LoggedGetattribute):</span></div><div class="t m0 x15 hf y231f ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">__init__<span class="fc0">(<span class="fca">self</span>,x):</span></span></div><div class="t m0 x16 hf y2320 ff8 fs5 fca sc0 ls0 ws13a">self<span class="fc6">.<span class="fc0 ls33">x</span><span class="ls32">=</span><span class="fc0">x</span></span></div><div class="t m0 x15 hf y2321 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">spam<span class="fc0">(<span class="fca">self</span>):</span></span></div><div class="t m0 x16 h10 y29b ff7 fs5 fca sc0 ls0">pass</div><div class="t m0 x0 h9 y2322 ff1 fs3 fc0 sc0 ls68 ws23f">这种方案也行得通，但是为了去理解它，你就必须知道方法调用顺序、<span class="ff6 ls0 wsc16">super() <span class="ff1">以</span></span></div><div class="t m0 x5 h7 y2323 ff1 fs3 fc0 sc0 ls0 ws6a2">及其它 <span class="ff4 wsc17">8.7 </span><span class="wsa0">小节介绍的继承知识。<span class="_ _1"></span>某种程度上来讲，<span class="_ _1"></span>类装饰器方案就显得更加直观，<span class="_ _1"></span>并</span></div><div class="t m0 x5 h9 y2324 ff1 fs3 fc0 sc0 lsa8 ws6b2">且它不会引入新的继承体系。它的运行速度也更快一些<span class="_ _1"></span>，因为他并不依赖 <span class="ff6 ls0 ws3dd">super() <span class="ff1">函</span></span></div><div class="t m0 x5 h9 y2325 ff1 fs3 fc0 sc0 ls0">数。</div><div class="t m0 x0 h9 y2326 ff1 fs3 fc0 sc0 ls30 ws138">如果你系想在一个类上面使用多个类装饰器<span class="_ _1"></span>，那么就需要注意下顺序问题。例如<span class="_ _c"></span>，</div><div class="t m0 x5 h7 y2327 ff1 fs3 fc0 sc0 ls0 ws4ad">一个装饰器 <span class="ff4 ls2f">A</span><span class="wsc18">会将其装饰的方法完整替换成另一种实现，而另一个装饰器 <span class="ff4 ls193">B</span><span class="wsa0">只是简单</span></span></div><div class="t m0 x5 h7 y2328 ff1 fs3 fc0 sc0 ls0 wsc19">的在其装饰的方法中添加点额外逻辑。那么这时候装饰器 <span class="ff4 ls194">A</span><span class="wsc1a">就需要放在装饰器 <span class="ff4 ls193">B</span>的前</span></div><div class="t m0 x5 h9 y2329 ff1 fs3 fc0 sc0 ls0">面。</div><div class="t m0 x0 h7 y232a ff1 fs3 fc0 sc0 ls0 wsc">你还可以回顾一下 <span class="ff4 wsca">8.13 </span>小节另外一个关于类装饰器的有用的例子。</div><div class="t m0 x5 hd y232b ff2 fs4 fc4 sc0 ls0 ws211">11.13<span class="_ _e"> </span>9.13 <span class="ff1">使用元类控制实例的创建</span></div><div class="t m0 x5 he y232c ff2 fs2 fc4 sc0 ls0 wsadf">11.13.1 <span class="ff1">问题</span></div><div class="t m0 x0 h9 y232d ff1 fs3 fc0 sc0 ls0">你想通过改变实例创建方式来实现单例、缓存或其他类似的特性。</div><div class="t m0 x5 he y9ce ff2 fs2 fc4 sc0 ls0 wsadf">11.13.2 <span class="ff1">解决方案</span></div><div class="t m0 x0 h7 y232e ff4 fs3 fc0 sc0 ls0 ws49f">Python <span class="ff1 ls10 wsdf">程序员都知道<span class="_ _1"></span>，如果你定义了一个类，就能像函数一样的调用它来创建实<span class="_ _c"></span></span></div><div class="t m0 x5 h9 y232f ff1 fs3 fc0 sc0 ls0">例，例如：</div><div class="t m0 x5 hf y2330 ff7 fs5 fca sc0 ls0 ws16a">class <span class="fcc ws156">Spam<span class="ff8 fc0">:</span></span></div><div class="t m0 x15 hf y2331 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">__init__<span class="fc0">(<span class="fca">self</span><span class="ws4">, name):</span></span></span></div><div class="t m0 x16 hf y2332 ff8 fs5 fca sc0 ls0 ws13a">self<span class="fc6">.<span class="fc0 ws13c">name </span><span class="ls33">=</span><span class="fc0">name</span></span></div><div class="t m0 x5 hf y2333 ff8 fs5 fc0 sc0 ls32">a<span class="fc6 ls33">=</span><span class="ls0 ws13a">Spam(<span class="ff9 fc9 ws13b">&apos;</span><span class="fc9">Guido<span class="ff9 ls34">&apos;</span></span>)</span></div><div class="t m0 x5 hf y2334 ff8 fs5 fc0 sc0 ls32">b<span class="fc6 ls33">=</span><span class="ls0 ws13a">Spam(<span class="ff9 fc9 ws13b">&apos;</span><span class="fc9">Diana<span class="ff9 ls34">&apos;</span></span>)</span></div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 wsae0">11.13.<span class="_ _5"> </span>9.13 <span class="ff1 wsb03">使用元类控制实例的创建 </span>326</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
