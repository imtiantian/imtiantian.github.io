<div id="pf148" class="pf w0 h0" data-page-no="148"><div class="pc pc148 w0 h0"><img class="bi x13 y5 w2 ha" alt="" src="bg148.png"/><div class="t m0 xd h9 y75 ff1 fs3 fc0 sc0 lsb">《<span class="ff2 ls0 wsce">Python Co<span class="_ _6"></span>okb<span class="_ _6"></span>o<span class="_ _6"></span>ok</span><span class="ls0 wsa0">》第三版<span class="ff2 wsce">, Release 2.0.0</span></span></div><div class="t m0 x5 he y137 ff2 fs2 fc4 sc0 ls0 ws212">11.9.3 <span class="ff1">讨论</span></div><div class="t m0 x0 h9 y675 ff1 fs3 fc0 sc0 ls3a ws153">将装饰器定义成类通常是很简单的。但是这里还是有一些细节需要解释下，特别是</div><div class="t m0 x5 h9 y676 ff1 fs3 fc0 sc0 ls0">当你想将它作用在实例方法上的时候。</div><div class="t m0 x0 h9 y1575 ff1 fs3 fc0 sc0 ls0 wsbf9">首<span class="_ _6"></span>先，<span class="_ _6"></span>使<span class="_ _6"></span>用 <span class="ff6 ws167">functools.wraps() </span><span class="wsa0">函<span class="_ _6"></span>数<span class="_ _6"></span>的<span class="_ _6"></span>作<span class="_ _6"></span>用<span class="_ _6"></span>跟<span class="_ _6"></span>之<span class="_ _6"></span>前还<span class="_ _6"></span>是<span class="_ _6"></span>一<span class="_ _6"></span>样，<span class="_ _6"></span>将<span class="_ _6"></span>被<span class="_ _6"></span>包<span class="_ _6"></span>装<span class="_ _6"></span>函<span class="_ _6"></span>数<span class="_ _6"></span>的<span class="_ _6"></span>元</span></div><div class="t m0 x5 h9 y1576 ff1 fs3 fc0 sc0 ls0">信息复制到可调用实例中去。</div><div class="t m0 x0 h9 y67a ff1 fs3 fc0 sc0 ls17 wsbfa">其次，通常很容易会忽视上面的 <span class="ff6 ls0 ws589">get<span class="_ _e"> </span>() </span><span class="wsf6">方法<span class="_ _1"></span>。如果你忽略它，保持其他代码不<span class="_ _1"></span></span></div><div class="t m0 x5 h9 y2257 ff1 fs3 fc0 sc0 ls0">变再次运行，你会发现当你去调用被装饰实例方法时出现很奇怪的问题。例如：</div><div class="t m0 x5 hf y2258 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls32">s<span class="fc6 ls33">=</span><span class="ls0">Spam()</span></span></div><div class="t m0 x5 hf y2259 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls34">s<span class="fc6 ls0 ws13a">.<span class="fc0">bar(</span></span><span class="fc7">3</span><span class="ls0">)</span></span></div><div class="t m0 x5 hf y225a ff8 fs5 fce sc0 ls0 ws4">Traceback (most recent call last):</div><div class="t m0 x5 h11 y225b ffa fs5 fcd sc0 ls0">...</div><div class="t m0 x5 hf y9f ff8 fs5 fc2 sc0 ls0 ws13a">TypeError<span class="fc0 ws4">: bar() missing 1 required positional argument: <span class="ff9 ls34">&apos;<span class="ff8">x</span><span class="ls0">&apos;</span></span></span></div><div class="t m0 x0 h9 y225c ff1 fs3 fc0 sc0 ls42 wsbfb">出错原因是当方法函数在一个类中被查找时，它们的 <span class="ff6 ls0 wsbfc">get<span class="_ _e"> </span>() </span><span class="ws186">方法依据描述器协<span class="_ _1"></span></span></div><div class="t m0 x5 h7 y1410 ff1 fs3 fc0 sc0 ls0 wsbfd">议被<span class="_ _6"></span>调<span class="_ _6"></span>用，在 <span class="ff4 wsadc">8.9 </span><span class="ls12 wsbfe">小节已经讲述过描述器协议了。在这里， </span><span class="ff6 wsbff">get<span class="_ _e"> </span>() </span><span class="ls12 wse4">的目的是创建一<span class="_ _c"></span></span></div><div class="t m0 x5 h7 y1411 ff1 fs3 fc0 sc0 ls0 ws38">个绑定方法对象 <span class="ff4 ls1b">(</span><span class="ws14">最终会给这个方法传递 <span class="ff4 wsc00">self </span><span class="wsa0">参数<span class="ff4 wsa5">)</span>。下面是一个例子来演示底层原理：</span></span></div><div class="t m0 x5 hf y225d ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ls32">s<span class="fc6 ls33">=</span><span class="ls0">Spam()</span></span></div><div class="t m0 x5 hf y225e ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="fca">def <span class="ff8 fcb ws13a">grok<span class="fc0">(<span class="fca">self</span><span class="ws4">, x):</span></span></span></span></div><div class="t m0 x5 h10 y225f ff7 fs5 fc5 sc0 ls0 ws1a2">... <span class="fca">pass</span></div><div class="t m0 x5 h10 y2260 ff7 fs5 fc5 sc0 ls0">...</div><div class="t m0 x5 hf y2261 ff7 fs5 fc5 sc0 ls0 ws139">&gt;&gt;&gt; <span class="ff8 fc0 ws13a">grok<span class="fc6 ls34">.</span><span class="ws13b">__get__(s, Spam)</span></span></div><div class="t m0 x5 hf y2262 ff8 fs5 fc8 sc0 ls0 ws4">&lt;bound method Spam.grok of &lt;__main__.Spam object at 0x100671e90&gt;&gt;</div><div class="t m0 x5 hf y2263 ff8 fs5 fc8 sc0 ls0">&gt;&gt;&gt;</div><div class="t m0 x31 h9 y2264 ff6 fs3 fc0 sc0 ls0 wsa3e">get<span class="_ _e"> </span>() <span class="ff1 ls42 wsc01">方法是为了确保绑定方法对象能被正确的创建。 </span><span class="wsc02">type.MethodType() <span class="ff1">手</span></span></div><div class="t m0 x5 h9 yb57 ff1 fs3 fc0 sc0 ls13 wse5">动创建一个绑定方法来使用<span class="_ _1"></span>。只有当实例被使用的时候绑定方法才会被创建。如果这<span class="_ _c"></span></div><div class="t m0 x5 h7 y2265 ff1 fs3 fc0 sc0 ls35 wsbac">个方法是在类上面来访问，那么 <span class="ff6 ls0 ws359">get<span class="_ _e"> </span>() <span class="ff1 ws366">中的 <span class="ff4 wsc03">instance </span></span></span><span class="wsc04">参数会被设置成 <span class="ff4 ls0 wsc05">None <span class="ff1 wsa0">并直接</span></span></span></div><div class="t m0 x5 h9 y1ff8 ff1 fs3 fc0 sc0 ls0 ws14">返回 <span class="ff6 ws1f3">Profiled </span>实例本身。这样的话我们就可以提取它的 <span class="ff6 ws25d">ncalls </span>属性了。</div><div class="t m0 x0 h9 y22e ff1 fs3 fc0 sc0 ls3d wsc06">如果你想避免一些混乱，也可以考虑另外一个使用闭包和 <span class="ff6 ls0 ws214">nonlocal <span class="ff1 wsa0">变量实现<span class="_ _6"></span>的装</span></span></div><div class="t m0 x5 h7 y2266 ff1 fs3 fc0 sc0 ls0 ws14">饰器，这个在 <span class="ff4 ws2b4">9.5 </span>小节有讲到。例如：</div><div class="t m0 x5 h10 y2267 ff7 fs5 fca sc0 ls0 ws146">import <span class="fcc">types</span></div><div class="t m0 x5 hf y2268 ff7 fs5 fca sc0 ls0 ws15a">from <span class="fcc ws285">functools </span><span class="ws146">import <span class="ff8 fc0">wraps</span></span></div><div class="t m0 x5 hf y2269 ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">profiled<span class="fc0">(func):</span></span></div><div class="t m0 x15 hf y226a ff8 fs5 fc0 sc0 ls0 ws145">ncalls <span class="fc6 ls32">=</span><span class="fc7">0</span></div><div class="t m0 x15 hf y226b ff7 fs5 fc12 sc0 ls0 ws156">@wraps<span class="ff8 fc0">(func)</span></div><div class="t m0 x15 hf y226c ff7 fs5 fca sc0 ls0 ws139">def <span class="ff8 fcb ws13a">wrapper<span class="fc0 ls34">(</span><span class="fc6">*<span class="fc0 ws458">args, </span>**<span class="fc0">kwargs):</span></span></span></div><div class="t m0 x16 hf y226d ff8 fs5 fc0 sc0 ls0 ws13b">nonlocal ncalls</div><div class="t m0 x16 hf y226e ff8 fs5 fc0 sc0 ls0 ws145">ncalls <span class="fc6 ws23d">+= <span class="fc7">1</span></span></div><div class="t m0 x16 hf y226f ff7 fs5 fca sc0 ls0 ws146">return <span class="ff8 fc0 ws13a">func(<span class="fc6">*</span><span class="ws458">args, </span><span class="fc6">**</span>kwargs)</span></div><div class="t m0 x15 hf y2270 ff8 fs5 fc0 sc0 ls0 ws13a">wrapper<span class="fc6 ls34">.</span><span class="ws145">ncalls <span class="fc6 ls32">=</span><span class="ff7 fca ws156">lambda</span><span class="ws13b">: ncalls</span></span></div><div class="t m0 x15 hf y2271 ff7 fs5 fca sc0 ls0 ws146">return <span class="ff8 fc0">wrapper</span></div><div class="t m0 x5 h11 y2272 ffa fs5 fcd sc0 ls0 ws4"># Example</div><div class="t m0 x5 h10 y2273 ff7 fs5 fc12 sc0 ls0">@profiled</div><div class="t m0 x5 h9 y29 ff2 fs3 fc0 sc0 ls0 ws9da">11.9.<span class="_ _5"> </span>9.9 <span class="ff1 ws2a4">将装饰器定义为类 </span>319</div></div><div class="pi" data-data='{"ctm":[1.500000,0.000000,0.000000,1.500000,0.000000,0.000000]}'></div></div>
